{"meta":{"title":"iZdo's Blog","subtitle":"bonbolu","description":null,"author":"iZdo","url":"https://izdo.github.io"},"pages":[{"title":"tags","date":"2017-03-23T05:20:30.000Z","updated":"2017-03-23T05:21:03.042Z","comments":false,"path":"tags/index.html","permalink":"https://izdo.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-03-23T14:14:27.000Z","updated":"2017-03-23T14:14:51.149Z","comments":true,"path":"categories/index.html","permalink":"https://izdo.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"内存优化(下)","slug":"内存优化(下)","date":"2017-09-03T07:24:49.475Z","updated":"2017-09-03T07:23:51.030Z","comments":true,"path":"2017/09/03/内存优化(下)/","link":"","permalink":"https://izdo.github.io/2017/09/03/内存优化(下)/","excerpt":"","text":"内存优化(下)内存优化—减少内存使用（Reduce）如果减少某些不必要内存的使用，也可以达到内存优化的目的。 比如说Bitmap。它在使用时会花掉较多的内存。那我们就可以考虑在应用bitmap时减少某些不必要内存的使用。 边界压缩：一张拍出来的图片分辨率可能会很大，如果不做压缩去展示的话，会消耗大量内存，可能造成OOM，通过BitmapFactory.Options去设置inSampleSize，可以对图片进行边界的压缩，减少内存开销。（做法：先设置BitmapFactory.inJustDecodeBounds为true，然后decodeFile，这样将会只去解析图片大小等信息，避免了将原图加载进内存。拿到原图尺寸信息后，根据业务逻辑换算比例，设置inSampleSize，接着设置BitmapFactory.inJustDecodeBounds为false，最后再去decodeFile，从而实现对图片边界大小进行了压缩再展示。） 色彩压缩：除此之外，还可以通过设置Bitmap图片的Config配置来减少内存使用。配置有以下四种： ALPHA_8（Alpha由8位组成，代表8位Alpha位图） ARGB_4444（由4个4位组成即16位，代表16位ARGB位图） ARGB_8888（由4个8位组成即32位，代表32位ARGB位图，图片质量最佳） RGB_565（R为5位，G为6位，B为5位，共16位，它是没有透明度的） 如果配置不一样，需要的内存也不同。比如ARGB4444、ARGB8888、RGB565。配置的位数越高，图片质量越佳，当然需要的内存就越多。如果图片不需要透明度，就采用RGB565的配置。通过Bitmap.Config配置，也可以起到压缩图片大小作用。 在实际中，可以通过以下代码来进行图片转bitmap解码时的Config。 123BitmapFactory.Options options = new BitmapFactory.Options();options.inPreferredConfig = Bitmap.Config.RGB_565;Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.ic_menu_add, options); 如果通过在列表中展示缩略图的形式来加载图片，如果需要查看高清图片，另启动一个页面（对话框）来加载高清图片，这样可以避免在列表中加载太多高清图片，减少内存开销。 内存优化—回收（Recycle）一些资源时使用时记得回收，比如说BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap、TypeArray等资源的代码，应该在使用之后或者Activity销毁时及时关闭或者注销，否则这些资源可能将不会被回收，造成内存泄漏。 内存优化—重用（Reuse）对象池在程序里面经常会遇到的一个问题是短时间内创建大量的对象，导致内存紧张，从而触发GC导致性能问题。对于这个问题，我们可以使用对象池技术来解决它。通常对象池中的对象可能是bitmaps，views，messages等等。 比如说Message.obtain()方法。通过handler去发消息Message时，通过Message.obtain()来获得一个消息，就比直接通过new一个Message要更好。因为Message中内部就维护了一个对象池用来存放消息，通过obtain方法来取消息的话，会先从内部的对象池中去取，如果取不到，再去新创建一个消息进行使用。 关于对象池的操作原理，请看下面的图示： 使用对象池技术有很多好处，它可以避免内存抖动，提升性能，但是在使用的时候有一些内容是需要特别注意的。通常情况下，初始化的对象池里面都是空白的，当使用某个对象的时候先去对象池查询是否存在，如果不存在则创建这个对象然后加入对象池。 但是我们也可以在程序刚启动的时候就事先为对象池填充一些即将要使用到的数据，这样可以在需要使用到这些对象的时候提供更快的首次加载速度，这种行为就叫做预分配。 使用对象池也有不好的一面，我们需要手动管理这些对象的分配与释放，所以我们需要慎重地使用这项技术，避免发生对象的内存泄漏。为了确保所有的对象能够正确被释放，我们需要保证加入对象池的对象和其他外部对象没有互相引用的关系。 缓存无论是为了提高CPU的计算速度还是提高数据的访问速度，在绝大多数的场景下，我们都会使用到缓存。 例如缓存到内存里面的图片资源，网络请求返回数据的缓存等等。凡是可能需要反复读取的数据，都建议使用合适的缓存策略。比如图片三级缓存、ListView中的Adapter使用contentView进行复用、使用holder避免重复的findViewById。再比如以下的代码，都是缓存的体现。 1234567891011121314//原代码for (int i = 0; i &lt; 1024; i++) &#123; if(i&lt;getCount())&#123; Log.d(\"TAG\", \"some log\" + i); &#125;&#125;//有缓存体现的代码，避免重复调用1024次getCount方法int count = getCount();for (int i = 0; i &lt; 1024; i++) &#123; if(i&lt;count)&#123; Log.d(\"TAG\", \"some log\" + i); &#125;&#125; 缓存中的lru算法lru算法（Least Recently Use），即最近最少使用算法，在Android中比较常用。当内存超过限定大小时，凡是近时间内最少使用的那一个对象，就会从缓存容器中被移除掉。 LRU Cache的基础构建用法如下： 1234//往缓存中添加图片，PicUrl是图片的地址，将其作为key，bitmap位图则作为valuebitmapLRUCache.put(picUrl,bitmap);//通过picUrl图片地址，从缓存中取bitmapbitmapLRUCache.get(picUrl); 为了给LRU Cache设置一个比较合理的缓存大小值，我们通常是用下面的方法来做界定的： 1234//当前应用最大可用内存long maxMemory = Runtime.getRuntime().maxMemory();//创建一个LRUCache，设置缓存大小界限为最大可用内存的八分之一BitmapLRUCache bitmapLRUCache = new BitmapLRUCache((int)maxMemory / 8); 使用LRU Cache时为了能够让Cache知道每个加入的Item的具体大小，我们需要Override下面的方法： 123456789101112public class BitmapLRUCache extends LruCache&lt;String,Bitmap&gt; &#123; public BitmapLRUCache(int maxSize) &#123; super(maxSize); &#125; @Override protected int sizeOf(String key, Bitmap value) &#123; int byteCount = value.getByteCount();//该bitmap位图所占用的内存字节数 return byteCount; &#125;&#125; 内存优化—检查（Review）代码写完了只是个开始。比较规范的编码，都需要Review的。代码检查时的注意点可参考上述内容。 接下来要提到的是UI检查。 查看UI布局是否过度绘制（overdraw）查看的前提是：移动设备已经开启了开发者选项。 在开发者选项中，点击“调试GPU过度绘制”，将弹出对话框，然后选择“显示过度绘制区域”，如下图所示： 屏幕这时候会变得花花绿绿的. 这些颜色是用来帮助你诊断应用程序的显示行为的。 这些颜色用于表示每个像素被重绘的次数, 含义如下： 真实颜色: 没有被重绘 蓝色: 重绘一次 绿色: 重绘两次 粉色: 重绘三次 红色: 重绘四次或更多次 通过这个工具，可以实现这些事情： 展示一个APP在何处做了不必要的渲染绘制。 帮助你查看在哪里可以减少渲染绘制。 有些重绘是不可避免的. 尽量调整APP的用户界面, 目标是让大部分的屏幕都是真实的颜色以及重绘一次的蓝色。 查看UI布局的渲染速度查看的前提是：移动设备已经开启了开发者选项。 在开发者选项中，点击“GPU呈现模式分析”，将弹出对话框，然后选择“在屏幕上显示为条形图”，如下图所示： 这时，将会在屏幕下方出现条形图，如下图所示： 该工具会为每个可见的APP显示一个图表，水平轴即时间流逝, 垂直轴表示每帧经过的时间,单位是毫秒。 在与APP的交互中, 垂直栏会显示在屏幕上, 从左到右移动, 随着时间推移，绘制帧的性能将会迅速体现出来。 绿色的线是用于标记16毫秒的分隔线（PS：人眼的原因, 1秒24帧的动画才能感到顺畅. 所以每帧的时间大概有41ms多一点点(1000ms/24). 但是但是, 注意了, 这41ms不是全都留给你Java代码, 而是所有java native 屏幕等等的, 最后留给我们用java级别代码发挥的时间, 只有16~17ms），只要有一帧超过了绿线, 你的APP就会丢失一帧。 查看UI布局的层级和实现方式有的UI界面写的效率比较低，我们可以通过一些工具来进行UI方面的视图检查。Hierarchy Viewer工具可以展示当前手机界面的View层级。 使用该工具的前提是：只能在模拟器或开发版手机上才能用，普通的商业手机是无法连上的。主要是出于安全考虑，普通商业手机中view server这个服务是没有开启的. Hierarchy Viewer就无法连接到机器获取view层级信息。（PS：如果愿意花功夫捣鼓，也可以在真机上强行开启View Server，详情见[网上资料][http://blog.csdn.net/autumn_xl/article/details/40741835]） 先打开模拟器运行要查看的页面，然后打开Hierarchy Viewer工具，它位于android的sdk所在目录中，具体位置为…\\sdk\\tools\\hierarchyviewer.bat。打开后如图所示： 列表展示手机中已打开的页面（包括状态栏等）。这里以电话应用中的DialtactsActivity为例，双击DialtactsActivity，将会打开关于该页面的树状图。如下图所示： 图中标出了3个部分： ① Tree View： 树状图的形式展示该Activity中的View层级结构。可以放大缩小，每个节点代表一个View，点击可以弹出其属性的当前值，并且在LayoutView中会显示其在界面中相应位置。 ② Tree Overview 它是Tree View的概览图。有一个选择框， 可以拖动选择查看。选中的部分会在Tree View中显示 ③ Layout View 匹配手机屏幕的视图，如果在Tree View中点击了某个节点，呢么这个节点在手机中的真是位置将会在Layout View中以红框的形式被标出。 接下来介绍点击Tree View中某个节点时，它所展示的信息类似于下图： 下面的三个圆点，依次表示Measure、Layout、Draw，可以理解为对应View的onMeasure，onLayout，onDraw三个方法的执行速度。 绿色：表示该View的此项性能比该View Tree中超过50%的View都要快。 黄色：表示该View的此项性能比该View Tree中超过50%的View都要慢。 红色：表示该View的此项性能是View Tree中最慢的。 如果界面中的Tree View中红点较多，那就需要注意了。一般的布局可能有以下几点： Measure红点，可能是布局中多次嵌套RelativeLayout，或是嵌套的LinearLayout都使用了weight属性。 Layout红点，可能是布局层级太深。 Draw红点，可能是自定义View的绘制有问题，复杂计算等。 UI布局优化避免过度绘制(Overdraw)减少布局层级复用（id、style）使用include、merge、viewStub标签include标签include标签常用于将布局中的公共部分提取出来供其他layout共用，以实现布局模块化，这在布局编写上提供了大大的便利。 下面以在一个布局main.xml中用include引入另一个布局foot.xml为例。main.mxl代码如下 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;ListView android:id=\"@+id/simple_list_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_marginBottom=\"@dimen/dp_80\" /&gt; &lt;include layout=\"@layout/foot.xml\" /&gt;&lt;/RelativeLayout&gt; 其中include引入的foot.xml为公用的页面底部，foot.xml代码如下 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;Button android:id=\"@+id/button\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/dp_40\" android:layout_above=\"@+id/text\"/&gt; &lt;TextView android:id=\"@+id/text\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/dp_40\" android:layout_alignParentBottom=\"true\" android:text=\"@string/app_name\" /&gt;&lt;/RelativeLayout&gt; &lt;include&gt;标签唯一需要的属性是layout属性，指定需要包含的布局文件。在该标签中，还可以定义android:id和android:layout_*属性来覆盖被引入布局根节点的对应属性值。注意重新定义android:id后，子布局的顶结点i就变化了。 merge标签在使用了include后可能导致布局嵌套过多，多余不必要的layout节点，从而导致解析变慢，不必要的节点和嵌套可通过上文中提到的hierarchy viewer来查看。而merge标签可以消除那些include时不必要的layout节点。 merge标签可用于两种典型情况： 布局顶结点是FrameLayout且不需要设置background或padding等属性，可以用merge代替，因为Activity内容试图的parent view就是个FrameLayout，所以可以用merge消除只剩一个。 某布局作为子布局被其他布局include时，使用merge当作该布局的顶节点，这样在被引入时顶结点会自动被忽略，而将其子节点全部合并到主布局中 以上一节中的&lt;include&gt;标签的示例为例，用hierarchy viewer查看main.xml布局如下图： 可以发现多了一层没必要的RelativeLayout，将foot.xml中RelativeLayout改为merge，如下： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;Button android:id=\"@+id/button\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/dp_40\" android:layout_above=\"@+id/text\"/&gt; &lt;TextView android:id=\"@+id/text\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/dp_40\" android:layout_alignParentBottom=\"true\" android:text=\"@string/app_name\" /&gt;&lt;/merge&gt; 运行后再次用hierarchy viewer查看main.xml布局如下图： 这样就不会有多余的RelativeLayout节点了。 viewStub标签viewstub标签同include标签一样可以用来引入一个外部布局，不同的是，viewstub引入的布局默认不会扩张，即既不会占用显示也不会占用位置，从而在解析layout时节省cpu和内存。 viewstub常用来引入那些默认不会显示，只在特殊情况下显示的布局，如进度布局、网络失败显示的刷新布局、信息出错出现的提示布局等。 下面以在一个布局main.xml中加入网络错误时的提示页面network_error.xml为例。main.mxl代码如下： 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; …… &lt;ViewStub android:id=\"@+id/network_error_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout=\"@layout/network_error\" /&gt;&lt;/RelativeLayout&gt; 其中network_error.xml为只有在网络错误时才需要显示的布局，默认不会被解析，示例代码如下： 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;Button android:id=\"@+id/network_setting\" android:layout_width=\"@dimen/dp_160\" android:layout_height=\"wrap_content\" android:layout_centerHorizontal=\"true\" android:text=\"@string/network_setting\" /&gt; &lt;Button android:id=\"@+id/network_refresh\" android:layout_width=\"@dimen/dp_160\" android:layout_height=\"wrap_content\" android:layout_below=\"@+id/network_setting\" android:layout_centerHorizontal=\"true\" android:layout_marginTop=\"@dimen/dp_10\" android:text=\"@string/network_refresh\" /&gt;&lt;/RelativeLayout&gt; 在java中通过(ViewStub)findViewById(id)找到ViewStub，通过stub.inflate()展开ViewStub，然后得到子View，如下 1234567891011121314151617private View networkErrorView;private void showNetError() &#123; // not repeated infalte if (networkErrorView != null) &#123; networkErrorView.setVisibility(View.VISIBLE); return; &#125; ViewStub stub = (ViewStub)findViewById(R.id.network_error_layout); networkErrorView = stub.inflate(); Button networkSetting = (Button)networkErrorView.findViewById(R.id.network_setting); Button refresh = (Button)findViewById(R.id.network_refresh);&#125;private void showNormal() &#123; if (networkErrorView != null) &#123; networkErrorView.setVisibility(View.GONE); &#125;&#125; 在上面showNetError()中展开了ViewStub，同时我们对networkErrorView进行了保存，这样下次不用继续inflate。 上面展开ViewStub部分代码 12ViewStub stub = (ViewStub)findViewById(R.id.network_error_layout);networkErrorView = stub.inflate(); 也可以写成下面的形式 123View viewStub = findViewById(R.id.network_error_layout);viewStub.setVisibility(View.VISIBLE); // ViewStub被展开后的布局所替换networkErrorView = findViewById(R.id.network_error_layout); // 获取展开后的布局 两者效果一致，只是不用显示的转换为ViewStub。通过viewstub的原理我们可以知道将一个view设置为GONE不会被解析，从而提高layout解析速度，而VISIBLE和INVISIBLE这两个可见性属性会被正常解析。 AsncTask简介系统提供的轻量级后台加载的异步任务类Thread池+Handler3.0之前 线程池是并行的(内部有好几个线程在同时工作)3.0之后 串行(默认线程池中只有一个线程在工作) 原因：先前的并行，一旦工作任务量很大，导致线程不够用而崩溃/卡顿。可以手动改回并行","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"},{"name":"note","slug":"note","permalink":"https://izdo.github.io/tags/note/"}]},{"title":"内存优化(上)","slug":"内存优化(上)","date":"2017-09-03T07:24:49.472Z","updated":"2017-09-03T06:29:25.917Z","comments":true,"path":"2017/09/03/内存优化(上)/","link":"","permalink":"https://izdo.github.io/2017/09/03/内存优化(上)/","excerpt":"","text":"内存优化(上)前言为什么内存优化？ 在一个商业项目中，很有可能因为工程师的疏忽，导致代码质量不佳，影响到程序的运行效率，从而让用户感知到应用的卡顿、崩溃。而Android开发中，每个Android应用在手机上申请的内存空间都是有限的。虽然手机发展越来越快，可申请到的内存越来越大，但是也不能大手大脚，随便浪费应用可使用的内存空间。内存一旦不够时，你这个应用就会因为OOM（out of memory）而崩溃。因此，内存优化这一块内容，在开发应用时是非常重要的。 内存优化的关键点—避免内存泄露内存优化中非常关键的一点，就是避免内存泄露。因为内存泄露会严重的导致内存浪费，所以避免内存泄露，是内存优化中必不可少的。 java中的四种引用类型java引用类型不是指像int、char等这些基本的数据类型。java中的引用类型有四种：强引用、软引用、弱引用、虚引用。这四种引用类型，它们关于对象的可及性是由强到弱的。 强引用最常见的强引用方式如下： 123//强引用 对象类型 对象名 = new 对象构造方法();//比如下列代码String str = new String(\"abc\"); 在上述代码中，这个str对象就是强可及对象。强可及对象永远不会被GC回收。它宁愿被抛出OOM异常，也不会回收掉强可及对象。 清除强引用对象中的引用链如下： 123String str = new String(\"abc\");//置空str = null; 软应用软引用方式如下： 12//软引用SoftReferenceSoftReference&lt;String&gt; softReference = new SoftReference&lt;String&gt;(str); 在上述代码中，这个str对象就是软可及对象。当系统内存不足时，软可及对象会被GC回收。 清除软引用对象中的引用链可以通过模拟系统内存不足来清除，也可以手动清除，手动清除如下： 12SoftReference&lt;String&gt; softReference = new SoftReference&lt;String&gt;(str);softReference.clear(); 弱引用弱引用方式如下： 12//弱引用WeakReferenceWeakReference&lt;String&gt; weakReference = new WeakReference&lt;&gt;(str); 在上述代码中，这个str对象就是弱可及对象。当每次GC时，弱可及对象就会被回收。 清除弱引用对象中的引用链可以通过手动调用gc代码来清除，如下： 12WeakReference&lt;String&gt; weakReference = new WeakReference&lt;&gt;(str);System.gc(); 当然，也可以通过类似软引用，调用clear()方法也可以。 虚引用虚引用方式如下： 12//虚引用PhantomReferencePhantomReference phantomReference = new PhantomReference&lt;&gt;(arg0, arg1); 虚引用一般在代码中出现的频率极低，主要目的是为了检测对象是否已经被系统回收。它在一些用来检测内存是否泄漏的开源项目中使用到过，如LeakCanary。 补充 一个对象的可及性由最强的那个来决定。 System.gc()方法只会回收堆内存中存放的对象。 1234String str = \"abc\";//弱引用WeakReferenceWeakReference&lt;String&gt; weakReference = new WeakReference&lt;&gt;(str);System.gc(); ​ 像这样的代码，即使gc后，str对象仍然可以通过弱引用拿到。因为像”abc”这种，并没有存放在堆内 存中，它被存放在常量池里，所以gc不会去回收。 内存泄露的原因对无用对象的引用一直未被释放，就会导致内存泄露。如果对象已经用不到了，但是因为疏忽，导致代码中对该无用对象的引用一直没有被清除掉，就会造成内存泄露。 比如你按back键关掉了一个Activity，那么这个Activity页面就暂时没用了。但是某个后台任务如果一直持有着对该Activity对象的引用，这个时候就会导致内存泄露。 检测内存泄露—LeakCanary在全球最大的同性交友网站github中，有一个非常流行的开源项目LeakCanary，它能很方便的检测到当前开发的java项目中是否存在内存泄露。 LeakCanary的使用官方使用文档描述从LeakCanary的文档描述中，可以得知使用方式，简单翻译为如下步骤： 在你的项目中，找到moudle级别的build.gradle文件，并在dependencies标签里加上以下代码： 123456dependencies &#123;//... 你项目中以前声明的一些依赖 debugCompile 'com.squareup.leakcanary:leakcanary-android:1.5' releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.5' testCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.5'&#125; 在你Android项目中，找到先前写的Application类（PS：如果没有，那么请自行新建并在AndroidManifest中声明），并添加如下代码： 12345678910111213public class ExampleApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); if (LeakCanary.isInAnalyzerProcess(this)) &#123; // This process is dedicated to LeakCanary for heap analysis. // You should not init your app in this process. return; &#125; LeakCanary.install(this); // Normal app init code... &#125;&#125; 导入完毕！当你的应用出现内存泄露时，LeakCanary会在通知栏上进行通知，注意查看。下图是一个LeakCanary检测到内存泄露时的实示例。 检测Fragment上述步骤默认会检测Activity，但是不会去检测Fragment，如果需要对某个Fragment检测的话，需要利用到LeakCanary的其他写法。 首先，在先前的Application类中，改写为以下代码： 1234567891011public class MyApplication extends Application &#123; public static RefWatcher mRefWatcher; @Override public void onCreate() &#123; super.onCreate(); //... mRefWatcher = LeakCanary.install(this); // Normal app init code... &#125;&#125; 然后在Fragment中的onDestroy方法中，去使用这个静态的RefWatcher进行观察，如果onDestroy了当前这个Fragment还没被回收，说明该Fragment产生了内存泄露。 12345@Overridepublic void onDestroy() &#123; super.onDestroy(); MyApplication.mRefWatcher.watch(this);&#125; 检测某个特定对象有时候如果需要检测某个特定的可疑对象在某个时机下是否内存泄露，那么只需要执行如下代码 （假如对象名为someObjNeedGced）： 1234 //... RefWatcher refWatcher = MyApplication.refWatcher; refWatcher.watch(someObjNeedGced);//... 当执行了refWatcher.watch方法时，如果这个对象还在内存中被其他对象引用，就会在 logcat 里看到内存泄漏的提示。 LeakCanary的原理简介LeakCanary的代码执行流程图如下： LeakCanary 的机制如下： RefWatcher.watch() 会以监控对象来创建一个KeyedWeakReference 弱引用对象 在AndroidWatchExecutor的后台线程里，来检查弱引用已经被清除了，如果没被清除，则执行一次 GC 如果弱引用对象仍然没有被清除，说明内存泄漏了，系统就导出 hprof 文件，保存在 app 的文件系统目录下 HeapAnalyzerService启动一个单独的进程，使用HeapAnalyzer来分析 hprof 文件。它使用另外一个开源库 HAHA。 HeapAnalyzer 通过查找KeyedWeakReference 弱引用对象来查找内在泄漏 HeapAnalyzer计算KeyedWeakReference所引用对象的最短强引用路径，来分析内存泄漏，并且构建出对象引用链出来。 内存泄漏信息送回给DisplayLeakService，它是运行在 app 进程里的一个服务。然后在设备通知栏显示内存泄漏信息。 常见的内存泄露内部类导致内存泄露内部类实例会隐式的持有外部类的引用。 比如说在Activity中去创建一个内部类实例，然后在内部类实例中去执行一些需要耗时间的任务。任务在执行过程中，将Activity关掉，这个时候Activity对象是不会被释放的，因为那个内部类还持有着对Activity的引用。但是Activity此时已经是个没用的Activity了，所有这时，内存泄露就出现了。 隐式持有外部类的说明：内部类可以直接去调用外部类的方法，如果没有持有外部类的引用，内部类是没办法去调用外部类的属性和方法的，但是内部类又没有明显的去指定和声明引用，所以称之为隐式引用。 Thread线程在Activity中创建一个内部类去继承Thread，然后让该Thread执行一些后台任务，未执行完时，关闭Activity，此时会内存泄露。核心代码如下： 123456789101112131415161718192021222324252627public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.button).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startThread(); &#125; &#125;); &#125; private void startThread() &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; SystemClock.sleep(1000); &#125; &#125; &#125;; thread.start(); &#125;&#125; 当点击页面按钮执行startThread()后，再按下back键关闭Activity，几秒后LeakCanary就会提示内存泄露了。 为了避免此种Thread相关内存泄露，只需要避免这个内部类去隐式引用外部类Activity即可。 解决方案：让这个内部类声明为静态类。代码如下： 12345678910111213141516171819202122public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; ...与先前相比未做变化，不再描述 &#125; private void startThread() &#123; Thread thread = new MyStaticThread(); thread.start(); &#125; private static class MyStaticThread extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 200; i++) &#123; SystemClock.sleep(1000); &#125; &#125; &#125;&#125; 这样声明为静态类后，该内部类将不会再去隐式持有外部类的应用。 如果像这样的循环操作，为了效率和优化，建议通过申明一个boolean类型的标志位来控制后台任务。比如在外部类Activity的onDestory退出方法中，将boolean值进行修改，使后台任务退出循环。代码如下： 123456789101112131415161718192021222324public class MainActivity extends AppCompatActivity &#123; ... //Activity页面是否已经destroy private static boolean isDestroy = false; private static class MyStaticThread extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; if(!isDestroy)&#123; SystemClock.sleep(1000); &#125; &#125; &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); isDestroy = true; &#125;&#125; 因为申明为了静态内部类，该内部类不再持有外部类Activity的引用，所以此时不能再去使用外部类中的方法、变量。除非外部类的那些方法、变量是静态的。 Q：在防止内存泄露的前提下，如果一定要去使用那些外部类中非静态的方法、变量，该怎么做？ A：通过使用弱引用或者软引用的方式，来引用外部类Activity。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; ... &#125; private void startThread() &#123; Thread thread = new MyStaticThread(MainActivity.this); thread.start(); &#125; private boolean isDestroy = false;//Activity页面是否已经destroy private static class MyStaticThread extends Thread &#123; private WeakReference&lt;MainActivity&gt; softReference = null; MyStaticThread(MainActivity mainActivity)&#123; this.softReference = new WeakReference&lt;MainActivity&gt;(mainActivity); &#125; @Override public void run() &#123; //能够isDestroy变量是非静态的，它属于MainActivity，我们只要拿到了MainActivity对象，就能拿到isDestroy MainActivity mainActivity = softReference.get(); for (int i = 0; i &lt; 200; i++) &#123; //使用前最好对MainActivity对象做非空判断，如果它已经被回收，就不再执行后台任务 if(mainActivity!=null&amp;&amp;!mainActivity.isDestroy)&#123; SystemClock.sleep(1000); &#125; &#125; &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); isDestroy = true; &#125;&#125; Handler在使用Handler时，经常可以看到有人在Activity、Fragment中写过内部类形式的Handler，比如说写一个内部类形式的handler来执行一个延时的任务，像这样： 1234567891011121314151617181920212223242526272829303132333435363738public class MainActivity extends AppCompatActivity &#123; private static final int MESSAGE_DELAY = 0; private Button mButton; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mButton = (Button) findViewById(R.id.button); mButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startDelayTask(); &#125; &#125;); &#125; private void startDelayTask() &#123; //发送一条消息，该消息会被延时10秒后才处理 Message message = Message.obtain(); message.obj = \"按钮点击15秒后再弹出\"; message.what = MESSAGE_DELAY; mHandler.sendMessageDelayed(message, 15000); &#125; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MESSAGE_DELAY: Toast.makeText(MainActivity.this, (String) msg.obj, Toast.LENGTH_SHORT).show(); mButton.setText(\"延时修改了按钮的文本\"); break; &#125; &#125; &#125;;&#125; 当点击了按钮后会发送出一条消息，该消息将会15秒后再进行处理，如果中途退出Activity，不一会LeakCanary就会检测到内存泄露。 上述代码发生内存泄露也是因为内部类持有外部类的引用。这个内部类Handler会拿着外部类Activity的引用，而那个Message又拿着Handler的引用。这个Message又要在消息队列里排队等着被handler中的死循环来取消息。从而形成了一个引用链，最后导致关于外部类Activity的引用不会被释放。 该情况的的解决方案，是与上一节的Thread线程相同的。只要将Handler设置为static的静态内部类方式，就解决了handler持有外部类引用的问题。 如果handler已申明为静态内部类，那么Handler就不再持有外部类的引用，无法使用外部类中非静态的方法、变量了。 如果想在避免内存泄露的同时，想使用非静态的方法、变量，同样可以用弱（软）引用来做。 123456789101112131415161718192021222324252627282930313233343536373839public class MainActivity extends AppCompatActivity &#123; private static final int MESSAGE_DELAY = 0; private Button mButton; @Override protected void onCreate(Bundle savedInstanceState) &#123; ... &#125; private void startDelayTask() &#123; //发送一条消息，该消息会被延时10秒后才处理 ... &#125; private Handler mHandler = new InsideHandler(MainActivity.this); private static class InsideHandler extends Handler &#123; private WeakReference&lt;MainActivity&gt; mSoftReference; InsideHandler(MainActivity activity) &#123; mSoftReference = new WeakReference&lt;MainActivity&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; MainActivity mainActivity = mSoftReference.get(); if (mainActivity != null) &#123; switch (msg.what) &#123; case MESSAGE_DELAY: Toast.makeText(mainActivity, (String) msg.obj, Toast.LENGTH_SHORT).show(); //通过软引用中的mainActivity可以拿到那个非静态的button对象 mainActivity.mButton.setText(\"延时修改了按钮的文本\"); break; &#125; &#125; &#125; &#125;&#125; 最后，更完美的做法是在这些做法的基础上，再添加这段逻辑：当Activity页面退出时，将handler中的所有消息进行移除，做到滴水不漏。 其实就是在onDestroy中写上： 123456@Overrideprotected void onDestroy() &#123; super.onDestroy(); //参数为null时，handler中所有消息和回调都会被移除 mHandler.removeCallbacksAndMessages(null);&#125; PS：弱引用和软引用的区别：弱引用会很容易被回收掉，软引用没那么快。如果你希望能尽快清掉这块内存使用就使用弱引用；如果想在内存实在不足的情况下才清掉，使用软引用。 下图是在内部类Handler使用软引用时LeakCanary出现的提示。 因为使用软引用，GC会有点偷懒，所以leakCanary会检测到一些异常，出现这样的提示。 非静态内部类的静态实例有时候会使用，代码如下： 123456789101112131415161718192021public class MainActivity extends AppCompatActivity &#123; private static User sUser = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initData(); &#125; private void initData() &#123; if(sUser==null)&#123; sUser = new User(); &#125; &#125; private class User&#123; User()&#123; &#125; &#125;&#125; 在代码中，非静态的内部类创建了一个静态实例。非静态内部类会持有外部类Activity的引用，后来又创建了一个这个内部类的静态实例。 这个静态实例不会在Activity被关掉时一块被回收（静态实例的生命周期跟Activity可不一样，你Activity挂了，但是写在Activity中的静态实例还是会在，静态实例的生命周期跟应用的生命周期一样长）。 非静态内部类持有外部引用，而该内部类的静态实例不会及时回收，所以才导致了内存泄露。 解决方案：将内部类申明为静态的内部类。 12345678public class MainActivity extends AppCompatActivity &#123; ... private static class User&#123; ... &#125;&#125; Context导致内存泄露有时候我们会创建一个静态类，比如说AppManager、XXXManager。这些静态类可能还是以单例的形式存在。而这些静态类需要做一个关于UI的处理，所以传递了一个Context进来，代码如下： 1234567891011121314151617181920212223242526public class ToastManager &#123; private Context mContext; ToastManager(Context context)&#123; mContext = context; &#125; private static ToastManager mManager = null; public void showToast(String str)&#123; if(mContext==null)&#123; return; &#125; Toast.makeText(mContext, str, Toast.LENGTH_SHORT).show(); &#125; public static ToastManager getInstance(Context context)&#123; if(mManager==null)&#123; synchronized (ToastManager.class)&#123; if(mManager==null)&#123; mManager = new ToastManager(context); &#125; &#125; &#125; return mManager; &#125;&#125; 而在使用时是这样写的： 12345678public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; ... ToastManager instance = ToastManager.getInstance(MainActivity.this); &#125;&#125; 这个时候代码也会发生内存泄露。因为静态实例比Activity生命周期长，你在使用静态类时将Activity作为context参数传了进来，即时Activity被关掉，但是静态实例中还保有对它的应用，所以会导致Activity没法被及时回收，造成内存泄露。 解决方案：在传Context上下文参数时，尽量传跟Application应用相同生命周期的Context。比如getApplicationContext()，因为静态实例的生命周期跟应用Application一致。 123456789public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ToastManager instance = ToastManager.getInstance(getApplicationContext()); &#125;&#125; Context的作用域系统中的Context的具体实现子类有：Activity、Application、Service。 虽然Context能做很多事，但并不是随便拿到一个Context实例就可以为所欲为，它的使用还是有一些规则限制的。在绝大多数场景下，Activity、Service和Application这三种类型的Context都是可以通用的。不过有几种场景比较特殊，比如启动Activity，还有弹出Dialog。 出于安全原因的考虑，Android是不允许Activity或Dialog凭空出现的，一个Activity的启动必须要建立在另一个Activity的基础之上，也就是以此形成的返回栈。而Dialog则必须在一个Activity上面弹出（除非是System Alert类型的Dialog），因此在这种场景下，我们只能使用Activity类型的Context，否则将会出错。 上图中Application和Service所不推荐的两种使用情况： 如果我们用ApplicationContext去启动一个LaunchMode为standard的Activity的时候会报错 1javaandroid.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want? 这是因为非Activity类型的Context并没有所谓的任务栈，所以待启动的Activity就找不到栈了。解决这个问题的方法就是为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就为它创建一个新的任务栈，而此时Activity是以singleTask模式启动的。所有这种用Application启动Activity的方式不推荐使用，Service的原因跟Application一致。 在Application和Service中去layout inflate也是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。所以这种方式也不推荐使用。一句话总结：凡是跟UI相关的，都建议使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例Context都可以，当然了，注意Context引用的持有，防止内存泄漏。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"},{"name":"note","slug":"note","permalink":"https://izdo.github.io/tags/note/"}]},{"title":"音乐播放器","slug":"音乐播放器","date":"2017-09-01T02:53:16.754Z","updated":"2017-09-01T02:52:45.969Z","comments":true,"path":"2017/09/01/音乐播放器/","link":"","permalink":"https://izdo.github.io/2017/09/01/音乐播放器/","excerpt":"","text":"音乐播放器 今天主要讲的是如何自己动手写一个音乐播放器。直接进入主题。 新建MyMusic工程布局文件activity_main 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" &gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"65dp\" android:background=\"@drawable/actionbar_bg\" &gt; &lt;ImageView android:id=\"@+id/back\" android:layout_width=\"38sp\" android:layout_height=\"38sp\" android:layout_alignParentLeft=\"true\" android:layout_centerVertical=\"true\" android:layout_marginLeft=\"16sp\" android:contentDescription=\"@+id/actionbar_left_icon\" android:src=\"@drawable/back_left\" /&gt; &lt;TextView android:id=\"@+id/center_content\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerHorizontal=\"true\" android:layout_centerVertical=\"true\" android:textColor=\"#FFF\" android:textSize=\"21sp\" android:text=\"Justin Bieber-Baby\" /&gt; &lt;ImageView android:id=\"@+id/right_icon\" android:layout_width=\"38sp\" android:layout_height=\"38sp\" android:layout_alignParentRight=\"true\" android:layout_centerVertical=\"true\" android:layout_marginRight=\"16sp\" android:contentDescription=\"@+id/actionbar_right_icon\" android:src=\"@drawable/actionbar_right\" /&gt; &lt;/RelativeLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:background=\"@drawable/cover\" android:gravity=\"bottom\" &gt; &lt;RelativeLayout android:id=\"@+id/play_element\" android:layout_width=\"match_parent\" android:layout_height=\"125sp\" android:layout_weight=\"0\" android:background=\"@drawable/banner_bg\" android:gravity=\"center_horizontal\" &gt; &lt;TextView android:id=\"@+id/music_author\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"5sp\" android:gravity=\"center_horizontal\" android:text=\"Justin Bieber\" android:textColor=\"#FFFFFF\" android:textSize=\"16sp\" /&gt; &lt;LinearLayout android:id=\"@+id/horizontal_music\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_below=\"@+id/music_author\" android:layout_marginTop=\"6sp\" android:gravity=\"center_horizontal|center_vertical\" android:orientation=\"horizontal\" &gt; &lt;ImageView android:id=\"@+id/reduce_vol\" android:layout_width=\"30sp\" android:layout_height=\"30sp\" android:contentDescription=\"@+id/reduce_vol\" android:src=\"@drawable/reduce_vol\" /&gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" &gt; &lt;SeekBar android:id=\"@+id/music_progress\" style=\"?android:attr/progressBarStyleHorizontal\" android:layout_width=\"220sp\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"8sp\" android:clickable=\"true\" android:focusable=\"false\" android:max=\"100\" android:paddingLeft=\"5sp\" android:progressDrawable=\"@drawable/play_seekbar_style\" android:thumb=\"@drawable/play_seekbar_thumb\" android:thumbOffset=\"5dip\" /&gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" &gt; &lt;TextView android:id=\"@+id/time_progress\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentLeft=\"true\" android:layout_marginLeft=\"20sp\" android:text=\"时长：\" android:textColor=\"#FFFFFF\" android:textSize=\"12sp\" /&gt; &lt;TextView android:id=\"@+id/music_duration\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentRight=\"true\" android:layout_marginLeft=\"20sp\" android:layout_marginRight=\"15sp\" android:text=\"04:25\" android:textColor=\"#FFFFFF\" android:textSize=\"12sp\" /&gt; &lt;/RelativeLayout&gt; &lt;/LinearLayout&gt; &lt;ImageView android:id=\"@+id/increase_vol\" android:layout_width=\"30sp\" android:layout_height=\"30sp\" android:layout_marginLeft=\"8sp\" android:contentDescription=\"@+id/increase_vol\" android:src=\"@drawable/increase_vol\" /&gt; &lt;/LinearLayout&gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_below=\"@+id/horizontal_music\" android:layout_marginTop=\"6sp\" android:gravity=\"center_horizontal\" &gt; &lt;ImageView android:id=\"@+id/pre_music\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerVertical=\"true\" android:contentDescription=\"@+id/pre_music\" android:src=\"@drawable/previous\" /&gt; &lt;ImageView android:id=\"@+id/play_pause_music\" android:layout_width=\"42sp\" android:layout_height=\"425sp\" android:layout_marginLeft=\"30sp\" android:layout_toRightOf=\"@+id/pre_music\" android:contentDescription=\"pause\" android:src=\"@drawable/play\" android:onClick=\"play\" /&gt; &lt;ImageView android:id=\"@+id/next_music\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerVertical=\"true\" android:layout_marginLeft=\"30sp\" android:layout_toRightOf=\"@+id/play_pause_music\" android:contentDescription=\"@+id/next_music\" android:src=\"@drawable/next\" /&gt; &lt;/RelativeLayout&gt; &lt;/RelativeLayout&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 同时将相应的图片资源文件放到工程中。布局比较简单，与市面上大多数音乐播放软件是相似的，就不再阐述。 众所周知，在我们运行音乐的时候，无论是在前台，还是按HOME键退出界面时，音乐都在播放，那么如何实现音乐在前台和后台都能正常的运行呢？我们自然而然地想到了Service。 新建MusicService类1234567891011121314151617181920212223242526272829package com.izdo.mymusic;import android.app.Service;import android.content.Intent;import android.os.IBinder;import java.io.IOException;/** * Created by iZdo on 2017/6/28. */public class MusicService extends Service &#123; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override public void onDestroy() &#123; super.onDestroy(); &#125;&#125; 新建类时只有onBind()方法，我们需要手动重写onCreate()方法和onDestroy()方法。 MainActivity1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private String TAG = \"MainActivity\"; private ImageView play_pause_music; private SeekBar sb; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); &#125; /** * 初始化控件 */ private void initView() &#123; play_pause_music = (ImageView) findViewById(R.id.play_pause_music); sb = (SeekBar) findViewById(R.id.music_progress); play_pause_music.setOnClickListener(this); sb.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123; @Override public void onProgressChanged(SeekBar seekBar, int i, boolean b) &#123; &#125; &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123; &#125; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123; &#125; &#125;); &#125; @Override public void onClick(View view) &#123; &#125;&#125; 基本初始化工作完成后，我们就可以开始对服务的初始化了。这里我们在onCreate()方法中绑定服务，绑定服务需要用到bindService()方法，而这个方法需要三个参数，第一个参数是一个Intent，表示你将要绑定的服务来自于哪个类，第二个参数是一个ServiceConnection对象，而ServiceConnection是一个接口，我们通常会写一个类继承它然后拿到这个类的对象作为参数，第三个参数是一个整型常量，这里我们传入Context.BIND_AUTO_CREATE即可。 修改MainActivity和MusicService类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private String TAG = \"MainActivity\"; private ImageView play_pause_music; private SeekBar sb; private MyServiceConnection conn; private MusicService musicService; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); Intent service = new Intent(this, MusicService.class); conn = new MyServiceConnection(); // 开启服务 this.startService(service); // 连接服务 this.bindService(service, conn, Context.BIND_AUTO_CREATE); &#125; private class MyServiceConnection implements ServiceConnection &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; // 连接成功 MusicService.MyBinder binder = (MusicService.MyBinder) iBinder; musicService = binder.getService(); Log.d(TAG, \"连接成功\"); &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (conn != null) &#123; this.unbindService(conn); //解绑 &#125; &#125; ... &#125;public class MusicService extends Service &#123; MyBinder binder = new MyBinder(); @Override public IBinder onBind(Intent intent) &#123; return binder; &#125; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override public void onDestroy() &#123; super.onDestroy(); &#125; class MyBinder extends Binder &#123; public MusicService getService() &#123; return MusicService.this; &#125; &#125;&#125; 这里为了方便，在onCreate()方法中我们直接开启服务。在MyServiceConnection的onServiceConnected()方法中，我们需要将IBinder参数转为供我们使用的binder，我们需要通过MusicService去获取Binder，一般我们在MusicService类中写一个继承于Binder类的MyBinder，并通过MyBinder类中的方法将服务返回给调用者。回到onServiceConnected()方法中，我们将IBinder强制转型为MyBinder类，并通过它拿到当前正在运行的服务。注意:在程序销毁时，我们需要将服务解绑。 运行结果16-28 15:41:44.827 2687-2687/com.izdo.mymusic D/MainActivity: 连接成功 修改MusicService类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class MusicService extends Service &#123; MyBinder binder = new MyBinder(); MediaPlayer player = new MediaPlayer(); // 媒体播放 @Override public IBinder onBind(Intent intent) &#123; return binder; &#125; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override public void onDestroy() &#123; super.onDestroy(); &#125; class MyBinder extends Binder &#123; public MusicService getService() &#123; return MusicService.this; &#125; &#125; /** * 开始播放 */ public void play(String path) &#123; player.reset(); // 重置 try &#123; player.setDataSource(path); // 设置音乐路径 player.prepare(); // 缓冲 player.setOnPreparedListener(new MediaPlayer.OnPreparedListener() &#123; @Override public void onPrepared(MediaPlayer mediaPlayer) &#123; player.start(); // 缓冲完成后开始播放 &#125; &#125;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 暂停播放 */ public void pause()&#123; if(player.isPlaying())&#123; player.pause(); // 暂停 &#125; &#125; /** * 继续播放 */ public void continue_music()&#123; player.start(); // 继续 &#125; /** * 停止播放 */ public void stop()&#123; player.stop(); // 停止 player.release(); &#125;&#125; 这次我们新加入四个方法，分别是开始播放，暂停播放，继续播放和停止播放，这里主要讲解一下开始播放方法，在播放之前我们需要重置一下播放器，并且一定要先prepare()让播放器缓冲并准备好开始播放。 修改MainActivity1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private String TAG = \"MainActivity\"; private ImageView play_pause_music; private SeekBar sb; private MyServiceConnection conn; private MusicService musicService; private MediaPlayer player; private String[] musics = new String[]&#123; \"1.mp3\", \"2.mp3\", \"3.mp3\" &#125;; private int index = 0; @Override protected void onCreate(Bundle savedInstanceState) &#123; ... &#125; private class MyServiceConnection implements ServiceConnection &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; // 连接成功 MusicService.MyBinder binder = (MusicService.MyBinder) iBinder; musicService = binder.getService(); player = musicService.player; // 获取播放器 if (!player.isPlaying()) &#123; // 当播放器不在播放才开始播放音乐 musicService.play(MyConstant.SD_PATH + \"/\" + musics[index]); // 播放音乐 play_pause_music.setImageResource(R.drawable.play); &#125; else &#123; play_pause_music.setImageResource(R.drawable.pause); &#125; &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; &#125; &#125; @Override public void onClick(View view) &#123; // 开始播放音乐 if (player != null) &#123; if (player.isPlaying()) &#123; musicService.pause(); play_pause_music.setImageResource(R.drawable.play); &#125; else &#123; musicService.continue_music(); play_pause_music.setImageResource(R.drawable.pause); &#125; &#125; &#125; ... &#125; 新建MyConstant类作为常量类1234567891011package com.izdo.mymusic;import android.os.Environment;/** * Created by iZdo on 2017/6/28. */public class MyConstant &#123; public final static String SD_PATH = Environment.getExternalStorageDirectory().getAbsolutePath().toString();&#125; 加入的逻辑都比较简单，将所需要的音乐文件放入手机内存中后，部署之后便可听到音乐，由于文章中无法听到音乐效果，所以也不贴效果图了。ps:读取SD卡需要在清单文件中加入权限。 接下来我们要加入进度条自动滚动和拖动进度条并让音乐播放到进度条位置的功能。 修改MainActivity 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; ... private Handler handler = new Handler(); private Runnable run_music = new Runnable() &#123; @Override public void run() &#123; // 检查音乐进度，更新seekbar sb.setProgress(player.getCurrentPosition()); // 设置seekbar当前刻度为音乐当前进度 handler.postDelayed(run_music, 100); &#125; &#125;; private class MyServiceConnection implements ServiceConnection &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; // 连接成功 MusicService.MyBinder binder = (MusicService.MyBinder) iBinder; musicService = binder.getService(); player = musicService.player; // 获取播放器 if (!player.isPlaying()) &#123; // 当播放器不在播放才开始播放音乐 musicService.play(MyConstant.SD_PATH + \"/\" + musics[index]); // 播放音乐 play_pause_music.setImageResource(R.drawable.play); &#125; else &#123; play_pause_music.setImageResource(R.drawable.pause); &#125; sb.setMax(player.getDuration()); // 设置进度条最大值为音乐长度 handler.removeCallbacks(run_music); // 先清空消息队列里的runnable handler.post(run_music); &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; &#125; &#125; /** * 初始化控件 */ private void initView() &#123; play_pause_music = (ImageView) findViewById(R.id.play_pause_music); sb = (SeekBar) findViewById(R.id.music_progress); play_pause_music.setOnClickListener(this); sb.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123; @Override public void onProgressChanged(SeekBar seekBar, int i, boolean b) &#123; if (b) &#123; if (player != null) &#123; player.seekTo(i); &#125; &#125; &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123; &#125; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123; &#125; &#125;); &#125; ... &#125; 首先说一下进度条自动滚动的功能，进度条的滚动自然牵扯到UI更新的问题，众所周知主线程不能更新UI，所以我们需要用到Handler，通过Runnable中的run()方法获取到当前进度值并设置到seekBar上，然后在onServiceConnected()方法中调用post()方法。只需要seekBar的监听事件的onProgressChanged()方法中调用seekTo()方法即可。 运行效果 接下来要加入的是上一首下一首按钮功能和播放完一首歌自动切换到下一首歌功能的实现。 修改MyConstant类123456public class MyConstant &#123; public final static String SD_PATH = Environment.getExternalStorageDirectory().getAbsolutePath().toString(); public final static int NEXT = 0; public final static int PRE = 1; public final static int CURRENT = 2;&#125; 这里加入了三个常量，分别代表下一首，上一首和当前的歌曲。 修改MainActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private ImageView play_pause_music, pre, next; ... private class MyServiceConnection implements ServiceConnection &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; // 连接成功 MusicService.MyBinder binder = (MusicService.MyBinder) iBinder; musicService = binder.getService(); player = musicService.player; // 获取播放器 if (!player.isPlaying()) &#123; // 当播放器不在播放才开始播放音乐 //musicService.play(MyConstant.SD_PATH + \"/\" + musics[index]); // 播放音乐 playMusicByStatue(MyConstant.CURRENT);// 播放音乐 play_pause_music.setImageResource(play); player.setOnCompletionListener(new MediaPlayer.OnCompletionListener() &#123; @Override public void onCompletion(MediaPlayer mediaPlayer) &#123; // 当前音乐播放完了 playMusicByStatue(MyConstant.NEXT); &#125; &#125;); &#125; else &#123; play_pause_music.setImageResource(R.drawable.pause); &#125; sb.setMax(player.getDuration()); // 设置进度条最大值为音乐长度 handler.removeCallbacks(run_music); // 先清空消息队列里的runnable handler.post(run_music); &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; &#125; &#125; public void playMusicByStatue(int statue) &#123; switch (statue) &#123; case 0: // 下一首 index++; if (index == musics.length) &#123; index = 0; &#125; break; case 1: // 上一首 index--; if (index == -1) &#123; index = musics.length - 1; &#125; break; case 2: // 当前 break; default: break; &#125; musicService.play(MyConstant.SD_PATH + \"/\" + musics[index]); sb.setMax(player.getDuration()); // 设置进度条最大值为音乐长度 &#125; /** * 初始化控件 */ private void initView() &#123; play_pause_music = (ImageView) findViewById(R.id.play_pause_music); pre = (ImageView) findViewById(R.id.pre_music); next = (ImageView) findViewById(R.id.next_music); sb = (SeekBar) findViewById(R.id.music_progress); play_pause_music.setOnClickListener(this); pre.setOnClickListener(this); next.setOnClickListener(this); ... &#125; @Override public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.play_pause_music: // 开始播放音乐 if (player != null) &#123; if (player.isPlaying()) &#123; musicService.pause(); play_pause_music.setImageResource(play); &#125; else &#123; musicService.continue_music(); play_pause_music.setImageResource(R.drawable.pause); &#125; &#125; break; case R.id.pre_music: playMusicByStatue(MyConstant.PRE); break; case R.id.next_music: playMusicByStatue(MyConstant.NEXT); break; default: break; &#125; &#125;&#125; 首先将上一首和下一首的控件初始化并设置监听事件，这里主要加入了playMusicByStatue()方法，通过传入的statue判断是上一首、下一首还是当前，并将onServiceConnected()方法中的musicService.play(MyConstant.SD_PATH + “/“ + musics[index]); 改为playMusicByStatue(MyConstant.CURRENT);，同时将onClick()方法修改为用switch语句判断点击的按钮，最后加入的逻辑即可。自动切歌功能比较简单，在onServiceConnected()方法中为MediaPlayer添加一个OnCompletionListener()，在其onCompletion()中调用playMusicByStatue()方法播放下一首即可。 接下来我们要完善一下这个音乐播放器。完善的部分会有较大的改动。 新建MusicInfo类123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.izdo.mymusic;/** * Created by iZdo on 2017/6/28. */public class MusicInfo &#123; private String musicPath; private String musicName; private String musicArtist; public String getMusicArtist() &#123; return musicArtist; &#125; public void setMusicArtist(String musicArtist) &#123; this.musicArtist = musicArtist; &#125; private int duration; public String getMusicPath() &#123; return musicPath; &#125; public void setMusicPath(String musicPath) &#123; this.musicPath = musicPath; &#125; public String getMusicName() &#123; return musicName; &#125; public void setMusicName(String musicName) &#123; this.musicName = musicName; &#125; public int getDuration() &#123; return duration; &#125; public void setDuration(int duration) &#123; this.duration = duration; &#125;&#125; 修改MainActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261package com.izdo.mymusic;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.database.Cursor;import android.media.MediaPlayer;import android.net.Uri;import android.os.Bundle;import android.os.Handler;import android.os.IBinder;import android.provider.MediaStore;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.View;import android.widget.ImageView;import android.widget.SeekBar;import android.widget.TextView;import java.text.DecimalFormat;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private String TAG = \"MainActivity\"; private TextView musicProgress; // 音乐当前时间 private TextView musicDuration; // 音乐的时长 private TextView musicName; // 音乐名 private TextView musicArtist; // 歌手名 private ImageView play_pause_music; // 开始暂停按钮 private ImageView pre; // 上一首 private ImageView next; // 下一首 private SeekBar sb; // 滚动条 private MyServiceConnection conn; private MusicService musicService; // 音乐核心服务 private MediaPlayer player; // 媒体播放器 // private String[] musics = new String[]&#123; // \"1.mp3\", \"2.mp3\", \"3.mp3\" // &#125;; private List&lt;MusicInfo&gt; musics = new ArrayList&lt;MusicInfo&gt;(); // 音乐数组 private int index = 0; private Handler handler = new Handler(); private Runnable run_music = new Runnable() &#123; @Override public void run() &#123; // 检查音乐进度，更新seekbar sb.setProgress(player.getCurrentPosition()); // 设置seekbar当前刻度为音乐当前进度 musicProgress.setText(millsSecondToString(player.getCurrentPosition())); // 设置时长 handler.postDelayed(run_music, 100); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); // 从手机里获取音乐 Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI; Cursor cursor = this.getContentResolver().query(uri, null, null, null, null); while (cursor != null &amp;&amp; cursor.moveToNext()) &#123; MusicInfo info = new MusicInfo(); // 获得音乐的物理路径 String path = cursor.getString(cursor.getColumnIndex(MediaStore.Audio.Media.DATA)); info.setMusicPath(path); // 获得音乐的名字 String musicName = cursor.getString(cursor.getColumnIndex(MediaStore.Audio.Media.TITLE)); info.setMusicName(musicName); // 获得歌手的名字 String musicArtist = cursor.getString(cursor.getColumnIndex(MediaStore.Audio.Media.ARTIST)); info.setMusicArtist(musicArtist); // 获得音乐的时长 int duration = cursor.getInt(cursor.getColumnIndex(MediaStore.Audio.Media.DURATION)); info.setDuration(duration); // 当音乐名和物理路径不为空并且时长不为0时才添加进集合 if (!musicName.equals(\"\") &amp;&amp; !path.equals(\"\") &amp;&amp; duration != 0) &#123; musics.add(info); Log.d(TAG, \"onCreate: \" + info.getMusicPath()); &#125; &#125; Intent service = new Intent(this, MusicService.class); conn = new MyServiceConnection(); // 开启服务 this.startService(service); // 绑定服务 this.bindService(service, conn, Context.BIND_AUTO_CREATE); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (conn != null) &#123; this.unbindService(conn); //解绑 &#125; &#125; private class MyServiceConnection implements ServiceConnection &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; // 绑定成功 MusicService.MyBinder binder = (MusicService.MyBinder) iBinder; musicService = binder.getService(); player = musicService.player; // 获取播放器 if (!player.isPlaying()) &#123; // 当播放器不在播放才开始播放音乐 //musicService.play(MyConstant.SD_PATH + \"/\" + musics[index]); // 播放音乐 playMusicByStatue(MyConstant.CURRENT);// 播放音乐 play_pause_music.setImageResource(R.drawable.pause); player.setOnCompletionListener(new MediaPlayer.OnCompletionListener() &#123; @Override public void onCompletion(MediaPlayer mediaPlayer) &#123; // 当前音乐播放完了 playMusicByStatue(MyConstant.NEXT); &#125; &#125;); &#125; else &#123; play_pause_music.setImageResource(R.drawable.pause); &#125; sb.setMax(player.getDuration()); // 设置进度条最大值为音乐长度 handler.removeCallbacks(run_music); // 先清空消息队列里的runnable handler.post(run_music); &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; &#125; &#125; public void playMusicByStatue(int statue) &#123; switch (statue) &#123; case 0: // 下一首 index++; if (index == musics.size()) &#123; index = 0; &#125; break; case 1: // 上一首 index--; if (index == -1) &#123; index = musics.size() - 1; &#125; break; case 2: // 当前 break; default: break; &#125; playMusic(index); // musicService.play(MyConstant.SD_PATH + \"/\" + musics.get(index)); // sb.setMax(player.getDuration()); // 设置进度条最大值为音乐长度 &#125; /** * 根据音乐数组下标播放对应的音乐 */ private void playMusic(int index2) &#123; if (musics.size() &gt; 0) &#123; musicService.play(musics.get(index2).getMusicPath()); // 设置音乐名 musicName.setText(musics.get(index2).getMusicName()); // 设置歌手 musicArtist.setText(musics.get(index2).getMusicArtist()); // 设置音乐时长 musicDuration.setText(millsSecondToString(musics.get(index2).getDuration())); &#125; // 设置进度条最大值为音乐长度 sb.setMax(player.getDuration()); &#125; /** * 转换时长为标准时间格式 */ public String millsSecondToString(int mills) &#123; // 将毫秒转化成秒 int seconds = mills / 1000; // 算出余数即为秒钟 int second = seconds % 60; // 计算出分钟数 int minute = (seconds - second) / 60; DecimalFormat decimalFormat = new DecimalFormat(\"00\"); return decimalFormat.format(minute) + \":\" + decimalFormat.format(second); &#125; /** * 初始化控件 */ private void initView() &#123; play_pause_music = (ImageView) findViewById(R.id.play_pause_music); pre = (ImageView) findViewById(R.id.pre_music); next = (ImageView) findViewById(R.id.next_music); sb = (SeekBar) findViewById(R.id.music_progress); musicName = (TextView) findViewById(R.id.center_content); musicProgress = (TextView) findViewById(R.id.time_progress); musicArtist = (TextView) findViewById(R.id.music_artist); musicDuration = (TextView) findViewById(R.id.music_duration); play_pause_music.setOnClickListener(this); pre.setOnClickListener(this); next.setOnClickListener(this); sb.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123; @Override public void onProgressChanged(SeekBar seekBar, int i, boolean b) &#123; if (b) &#123; if (player != null) &#123; player.seekTo(i); &#125; &#125; &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123; &#125; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123; &#125; &#125;); &#125; @Override public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.play_pause_music: // 开始播放音乐 if (player != null) &#123; if (player.isPlaying()) &#123; musicService.pause(); play_pause_music.setImageResource(R.drawable.play); &#125; else &#123; musicService.continue_music(); play_pause_music.setImageResource(R.drawable.pause); &#125; &#125; break; case R.id.pre_music: playMusicByStatue(MyConstant.PRE); break; case R.id.next_music: playMusicByStatue(MyConstant.NEXT); break; default: break; &#125; &#125;&#125; 首先拿到界面上音乐当前时间和时长的TextView，然后将存放音乐的数组改为用集合存放，并且音乐文件不再是通过具体路径获得，改为由内容提供者获取SD卡中所有音频文件。新增的playMusic()方法用于根据设置相关的信息到界面上，millsSecondToString()方法用于将获取到的音乐时长从毫秒值转换为标准的时间格式。而通过ContentResolver拿到的音乐信息可以参考以下网址:MediaStore部分属性解释 运行效果 这样一个简单的音乐播放器就完成了，当然一个音乐播放器不止这么简单，还有很多功能是我们可以实现的，但是由于文章篇幅问题，这个简单的demo就先到这里了。后续的修改也不以文章的形式发表，完善更多功能后有时间的话会把完整的项目发布。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"},{"name":"demo","slug":"demo","permalink":"https://izdo.github.io/tags/demo/"}]},{"title":"抽象工厂模式","slug":"抽象工厂模式","date":"2017-06-25T14:36:27.120Z","updated":"2017-06-25T14:35:14.680Z","comments":true,"path":"2017/06/25/抽象工厂模式/","link":"","permalink":"https://izdo.github.io/2017/06/25/抽象工厂模式/","excerpt":"","text":"抽象工厂模式什么是抽象工厂模式 抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的。抽象工厂模式可以向客户端提供一个接口，使得客户端在不必指定产品的具体类型的情况下，能够创建多个产品族的产品对象。 同样先看一个例子。 新建AbstractFactory工程新建Fruit类 123456public interface Fruit &#123; /* * 采摘 */ public void get();&#125; 新建Apple类和Banana类1234567891011121314151617public abstract class Apple implements Fruit &#123; /* * 采摘苹果 */ @Override public abstract void get();&#125;public abstract class Banana implements Fruit &#123; /* * 采摘香蕉 */ @Override public abstract void get();&#125; 新建NorthApple类和SouthApple类12345678910111213141516171819public class NorthApple extends Apple &#123; @Override public void get() &#123; // TODO Auto-generated method stub System.out.println(\"采摘北方苹果\"); &#125;&#125;public class SouthApple extends Apple &#123; @Override public void get() &#123; // TODO Auto-generated method stub System.out.println(\"采摘南方苹果\"); &#125;&#125; 新建NorthBanana类和SouthBanana类1234567891011121314151617181920public class NorthBanana extends Banana &#123; @Override public void get() &#123; // TODO Auto-generated method stub System.out.println(\"采摘北方香蕉\"); &#125;&#125;public class SouthBanana extends Banana &#123; @Override public void get() &#123; // TODO Auto-generated method stub System.out.println(\"采摘南方香蕉\"); &#125;&#125; 也就是说，现在Apple类和Banana类都是抽象类，而苹果和香蕉都有南北方之分，这时候只要让南北方苹果的类继承自Apple类即可。让具体的某种水果的抽象工厂去实现具体的产品族，这就是抽象工厂的好处。同样地，对于水果工厂，我们也可以让其分为南方水果工厂和北方水果工厂，通过工厂(南方工厂、被反工厂)来划分而不是通过水果(苹果工厂、香蕉工厂)来划分。 新建FruitFactory类1234567public interface FruitFactory &#123; // 实例化Apple public Fruit getApple(); // 实例化Banana public Fruit getBanana();&#125; 新建NorthFrutFactory类和SouthFruitFactory类12345678910111213141516171819202122232425262728293031public class NorthFrutFactory implements FruitFactory &#123; @Override public Fruit getApple() &#123; // TODO Auto-generated method stub return new NorthApple(); &#125; @Override public Fruit getBanana() &#123; // TODO Auto-generated method stub return new NorthBanana(); &#125;&#125;public class SouthFruitFactory implements FruitFactory &#123; @Override public Fruit getApple() &#123; // TODO Auto-generated method stub return new SouthApple(); &#125; @Override public Fruit getBanana() &#123; // TODO Auto-generated method stub return new SouthBanana(); &#125;&#125; 新建MainClass类12345678910111213141516171819public class MainClass &#123; public static void main(String[] args) &#123; FruitFactory ff = new NorthFrutFactory(); Fruit apple = ff.getApple(); apple.get(); Fruit banana = ff.getBanana(); banana.get(); FruitFactory ff2 = new SouthFruitFactory(); Fruit apple2 = ff2.getApple(); apple2.get(); Fruit banana2 = ff2.getBanana(); banana2.get(); &#125;&#125; 运行效果1234采摘北方苹果采摘北方香蕉采摘南方苹果采摘南方香蕉 这样我们就可以通过相应地方的工厂获得相应的水果。那么现在我们要新增一种温室水果应该怎样做？ 新建WenshiApple类和WenshiBanana类12345678910111213141516171819public class WenshiApple extends Apple &#123; @Override public void get() &#123; // TODO Auto-generated method stub System.out.println(\"采摘温室苹果\"); &#125;&#125;public class WenshiBanana extends Banana &#123; @Override public void get() &#123; // TODO Auto-generated method stub System.out.println(\"采摘温室香蕉\"); &#125;&#125; 新建WenshiFruitFactory类123456789101112131415public class WenshiFruitFactory implements FruitFactory &#123; @Override public Fruit getApple() &#123; // TODO Auto-generated method stub return new WenshiApple(); &#125; @Override public Fruit getBanana() &#123; // TODO Auto-generated method stub return new WenshiBanana(); &#125;&#125; 修改main方法12345678910111213141516171819202122232425262728public class MainClass &#123; public static void main(String[] args) &#123; FruitFactory ff = new NorthFrutFactory(); Fruit apple = ff.getApple(); apple.get(); Fruit banana = ff.getBanana(); banana.get(); FruitFactory ff2 = new SouthFruitFactory(); Fruit apple2 = ff2.getApple(); apple2.get(); Fruit banana2 = ff2.getBanana(); banana2.get(); FruitFactory ff3 = new WenshiFruitFactory(); Fruit apple3 = ff3.getApple(); apple3.get(); Fruit banana3 = ff3.getBanana(); banana3.get(); &#125;&#125; 简单的说，当我们要加入温室苹果时，我们需要新建出温室苹果，然后创建出一个专门用来生产温室水果的工厂类即可。 工厂方法模式中包含的角色及其职责 抽象工厂(Creator)角色:抽象工厂模式的核心，包含对多个产品结构的声明，任何工厂类都必须实现这个接口。 具体工厂(Concrete Creator)角色:具体工厂类是抽象工厂的一个实现，负责实例化某个产品族中的产品对象。 抽象(Product)产品角色:抽象工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。 具体产品(Concrete Product)角色:抽象工厂模式所创建的具体实例对象。 对照图 抽象工厂模式的优缺点 每种模式都有其优势，但是世界上是没有完美的东西的，在得到某些东西的同时，也必须舍弃一些东西，所以抽象工厂模式同样也有其劣势。抽象工厂模式一个显著的优点是分离接口与实现，客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已，使其从具体的产品实现中解耦，同时基于接口与实现的分离，使抽象工厂方法模式在切换产品类时更加灵活、容易。而抽象工厂模式的缺点有两个，一是对类文件的爆炸性增加，每次我们需要新增一种水果时，就需要新建许多类，比如现在我们要加入Pear类，这时候我们就需要创建Pear实体类、NonthPear类、SouthPear类以及WenshiPear类，并且在Fruit类和FruitFactory类中做出相应的修改，这样的工作是比较繁琐的，二是不太容易扩展新的产品类，第一点也说过，每当我们新增一个产品类就需要修改抽象工厂，这样的话所有的具体工厂类均会被修改了。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://izdo.github.io/tags/Java/"},{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"https://izdo.github.io/tags/设计模式/"}]},{"title":"工厂方法模式","slug":"工厂方法模式","date":"2017-06-25T14:36:23.292Z","updated":"2017-06-25T14:35:04.193Z","comments":true,"path":"2017/06/25/工厂方法模式/","link":"","permalink":"https://izdo.github.io/2017/06/25/工厂方法模式/","excerpt":"","text":"工厂方法模式什么是工厂方法模式 工厂方法模式同样属于类的创建型模式又被称为多态工厂模式。工厂方法模式我的意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类称为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。 同样先看一个例子。 新建FactoryMethod工程将上一篇简单工厂模式工程中的所有类都拷贝过来。回顾一下简单工厂模式，如果我们要添加一种水果，应该怎样做？ 新建Pear类123456789public class Pear implements Fruit &#123; @Override public void get() &#123; // TODO Auto-generated method stub System.out.println(\"采摘梨子\"); &#125;&#125; 修改FruitFactory类1234567891011121314public class FruitFactory &#123; public static Fruit getFruit(String type) throws InstantiationException, IllegalAccessException &#123; if (type.equalsIgnoreCase(\"apple\")) &#123; return Apple.class.newInstance(); &#125; else if (type.equalsIgnoreCase(\"banana\")) &#123; return Banana.class.newInstance(); &#125; else if (type.equalsIgnoreCase(\"pear\")) &#123; return Pear.class.newInstance(); &#125; else &#123; System.out.println(\"找不到相应的实例化类\"); return null; &#125; &#125;&#125; 修改main方法1234567891011public class MainClass &#123; public static void main(String[] args) throws InstantiationException, IllegalAccessException &#123; Fruit apple = FruitFactory.getFruit(\"Apple\"); Fruit banana = FruitFactory.getFruit(\"Banana\"); Fruit pear = FruitFactory.getFruit(\"pear\"); apple.get(); banana.get(); pear.get(); &#125;&#125; 这就是简单工厂模式，而上一篇文章结尾也说了简单工厂模式的缺点是有时候需要我们去修改工厂类，扩展性并不好。那么这个时候工厂方法模式就起作用了。 将FruitFactory修改为接口123public interface FruitFactory &#123; public Fruit getFruit();&#125; 新建AppleFactory类和BananaFactory类12345678910111213141516171819public class AppleFactory implements FruitFactory &#123; @Override public Fruit getFruit() &#123; // TODO Auto-generated method stub return new Apple(); &#125;&#125;public class BananaFactory implements FruitFactory &#123; @Override public Fruit getFruit() &#123; // TODO Auto-generated method stub return new Banana(); &#125;&#125; 修改main方法123456789101112131415public class MainClass &#123; public static void main(String[] args) &#123; // 获得AppleFactory FruitFactory ff = new AppleFactory(); // 通过AppleFactory获得Apple实例对象 Fruit apple = ff.getFruit(); apple.get(); // 获得BananaFactory FruitFactory ff2 = new BananaFactory(); // 通过AppleFactory获得Apple实例对象 Fruit banana = ff2.getFruit(); banana.get(); &#125;&#125; 运行结果12采摘苹果采摘香蕉 可以看到，我们将FruitFactory修改为接口后，想要加入一种水果的话，只要新建相对应的具体水果类和水果工厂并实现FruitFactory接口，然后通过该水果工厂的实例去获取相应水果的实例即可。那么如果我们要加入Pear这种水果应该怎么做？ 新建PearFactory类12345678public class PearFactory implements FruitFactory &#123; @Override public Fruit getFruit() &#123; // TODO Auto-generated method stub return new Pear(); &#125;&#125; 修改main方法123456789101112131415161718192021public class MainClass &#123; public static void main(String[] args) &#123; // 获得AppleFactory FruitFactory ff = new AppleFactory(); // 通过AppleFactory获得Apple实例对象 Fruit apple = ff.getFruit(); apple.get(); // 获得BananaFactory FruitFactory ff2 = new BananaFactory(); // 通过BananaFactory获得Apple实例对象 Fruit banana = ff2.getFruit(); banana.get(); // 获得Pearactory FruitFactory ff3 = new PearFactory(); // 通过PearFactory获得Apple实例对象 Fruit pear = ff3.getFruit(); pear.get(); &#125;&#125; 运行效果123采摘苹果采摘香蕉采摘梨子 可以看到，当我们需要加入一种新的水果时，完全不需要修改FruitFactory类，只需要加入相应的工厂并实现FruitFactory和一个具体对象即可，当我们需要修改某种特定水果的方法时，只需要找出其工厂类并做出相应的修改。 工厂方法模式中包含的角色及其职责 抽象工厂(Creator)角色:工厂方法模式的核心，任何工厂类都必须实现这个接口。 具体工厂(Concrete Creator)角色:具体工厂类是抽象工厂的一个实现，负责实例化产品对象。 抽象(Product)产品角色:工厂方法模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。 具体产品(Concrete Product)角色:工厂方法模式所创建的具体实例对象。 对照图 工厂方法模式和简单工厂模式比较 工厂方法模式与简单工厂模式在结构上的不同不是很明显。工厂方法类的核心是一个抽象工厂类，而简单工厂模式把核心放在一个具体类上。工厂方法模式之所以有一个别名叫多态性工厂模式是因为具体工厂类都有共同的接口，或者有共同的抽象父类。当系统扩展需要添加新的产品对象时，仅仅需要添加一个具体对象以及一个具体工厂对象，原有工厂对象不需要进行任何修改，也不需要修改客户端，很好的符合了”开放-封闭”原则。而简单工厂模式在添加新产品对象后不得不修改工厂方法，扩展性不好。工厂方法模式退化后可以演变成简单工厂模式。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://izdo.github.io/tags/Java/"},{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"https://izdo.github.io/tags/设计模式/"}]},{"title":"简单工厂模式","slug":"简单工厂模式","date":"2017-06-25T14:36:08.101Z","updated":"2017-06-25T14:34:01.870Z","comments":true,"path":"2017/06/25/简单工厂模式/","link":"","permalink":"https://izdo.github.io/2017/06/25/简单工厂模式/","excerpt":"","text":"简单工厂模式什么是简单工厂模式 简单工厂模式属于类的创建型模式，又叫做静态工厂方法模式。通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 首先看一个例子 新建SimpleFactory工程新建Apple类和Banana类 12345678public class Apple &#123; /* * 采摘苹果 */ public void get() &#123; System.out.println(\"采摘苹果\"); &#125;&#125; 12345678public class Banana &#123; /* * 采摘香蕉 */ public void get() &#123; System.out.println(\"采摘香蕉\"); &#125;&#125; 在主函数中实例化两个类1234567891011public class MainClass &#123; public static void main(String[] args) &#123; // 实例化一个Apple Apple apple = new Apple(); // 实例化一个Banana Banana banana = new Banana(); apple.get(); banana.get(); &#125;&#125; 运行结果12采摘苹果采摘香蕉 这是Java基础，相信很容易看懂，而我们能看到Apple类和Banana类都是属于水果，里面都只有一个get()方法，那么我们可以定义一个Fruit接口，然后让具体的实现类去实现这个接口。 新建Fruit接口123456public interface Fruit &#123; /* * 采摘 */ public void get();&#125; 实现类实现接口123456789101112131415161718192021222324public class Apple implements Fruit&#123; /* * 采摘苹果 */ @Override public void get() &#123; // TODO Auto-generated method stub System.out.println(\"采摘苹果\"); &#125;&#125;public class Banana implements Fruit &#123; /* * 采摘香蕉 */ @Override public void get() &#123; // TODO Auto-generated method stub System.out.println(\"采摘香蕉\"); &#125;&#125; 修改main函数123456789101112131415161718public class MainClass &#123; public static void main(String[] args) &#123; // // 实例化一个Apple // Apple apple = new Apple(); // // 实例化一个Banana // Banana banana = new Banana(); // apple.get(); // banana.get(); // 使用多态实例化一个Apple Fruit apple = new Apple(); // 使用多态实例化一个Banana Fruit banana = new Banana(); apple.get(); banana.get(); &#125;&#125; 运行结果12采摘苹果采摘香蕉 可以看到由于接口是不能实例化的，所以这里运用多态实例化了具体类，运行结果是一样的。那么接下来进入正题，所谓工厂模式，就是需要一个工厂来生产出我们所需要的产品而不需要我们自己动手去做，所以我们现在需要一个创建出一个工厂。 新建FruitFactory工厂类123456789101112131415public class FruitFactory &#123; /* * 获得Apple类的实例 */ public Fruit getApple() &#123; return new Apple(); &#125; /* * 获得Banana类的实例 */ public Fruit getBanana() &#123; return new Banana(); &#125;&#125; 修改main方法1234567891011121314151617181920212223242526public class MainClass &#123; public static void main(String[] args) &#123; // // 实例化一个Apple // Apple apple = new Apple(); // // 实例化一个Banana // Banana banana = new Banana(); // apple.get(); // banana.get(); // // 使用多态实例化一个Apple // Fruit apple = new Apple(); // // 使用多态实例化一个Banana // Fruit banana = new Banana(); // apple.get(); // banana.get(); // 实例化一个Apple Fruit apple = new FruitFactory().getApple(); // 实例化一个Banana Fruit banana = new FruitFactory().getBanana(); apple.get(); banana.get(); &#125;&#125; 运行结果12采摘苹果采摘香蕉 运行结果还是一样的。但是我们发现要实例化一个具体类我们需要new FruitFactory().getXXX(); 创建一个匿名对象，这样未免也太麻烦了，所以我们可以将FruitFacotory中的两个方法都改为静态方法，这样就可以直接通过类名调用该方法，而不需要去创建对象了。 1234567891011121314151617181920212223242526272829public class FruitFactory &#123; /* * 获得Apple类的实例 */ public static Fruit getApple() &#123; return new Apple(); &#125; /* * 获得Banana类的实例 */ public static Fruit getBanana() &#123; return new Banana(); &#125;&#125;public class MainClass &#123; public static void main(String[] args) &#123; ... // 实例化一个Apple Fruit apple = FruitFactory.getApple(); // 实例化一个Banana Fruit banana = FruitFactory.getBanana(); apple.get(); banana.get(); &#125;&#125; 工厂模式中包含的角色及其职责 工厂(Creator)角色: 简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。 抽象产品(Product)角色:简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。 具体产品(Concrete Product)角色:简单工厂模式所创建的具体实例对象。 对照图 回到刚才的工程中，我们在Fruit工厂类中定义了两个方法，一个用于获取Apple的实例，另一个用于获取Banana的实例，但是水果有很多种，如果我们要获取许多种类的水果的实例，那我们岂不是需要写一堆方法了吗？所以我们可以将这些水果放在一个方法中。 修改FruitFactory类1234567891011121314151617public class FruitFactory &#123; ... /* * 获得所有产品对象 */ public static Fruit getFruit(String type) throws InstantiationException, IllegalAccessException &#123; if (type.equalsIgnoreCase(\"apple\")) &#123; return Apple.class.newInstance(); &#125; else if (type.equalsIgnoreCase(\"banana\")) &#123; return Banana.class.newInstance(); &#125; else &#123; System.out.println(\"找不到相应的实例化类\"); return null; &#125; &#125;&#125; 现在我们将获取Apple和Banana实例的方法都放在getFruit()方法中，通过传入的type判断所需要的是什么类型的水果的实例再将其实例返回给调用者，这样就避免的方法过多的情况。 修改main方法1234567891011public class MainClass &#123; public static void main(String[] args) throws InstantiationException, IllegalAccessException &#123; ... Fruit apple = FruitFactory.getFruit(\"apple\"); Fruit banana = FruitFactory.getFruit(\"banana\"); apple.get(); banana.get(); &#125;&#125; 运行结果12采摘苹果采摘香蕉 除了这种方式，我们还可以用另一种方式来获取实例。 修改FruitFactory类12345678910111213141516171819202122public class FruitFactory &#123; ... /* * 获得所有产品对象 */ public static Fruit getFruit(String type) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; // if (type.equalsIgnoreCase(\"apple\")) &#123; // return Apple.class.newInstance(); // &#125; else if (type.equalsIgnoreCase(\"banana\")) &#123; // return Banana.class.newInstance(); // &#125; else &#123; // System.out.println(\"找不到相应的实例化类\"); // return null; // &#125; Class fruit = Class.forName(type); return (Fruit) fruit.newInstance(); &#125;&#125; 修改main方法123456789101112131415161718public class MainClass &#123; public static void main(String[] args) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; ... // // 实例化一个Apple // Fruit apple = FruitFactory.getApple(); // // 实例化一个Banana // Fruit banana = FruitFactory.getBanana(); // apple.get(); // banana.get(); Fruit apple = FruitFactory.getFruit(\"Apple\"); Fruit banana = FruitFactory.getFruit(\"Banana\"); apple.get(); banana.get(); &#125;&#125; 这里我们将getFruit()方法更改为由传入的type类型查找相应的Class并实例化，这样虽然将步骤简单化了，我们不再需要去判断对应的类型，但是也有局限性，我们传入的type必须和类名大小写一致，否则会出现NoClassDefFoundError这个异常，减少了灵活性。 简单工厂模式的优缺点 在这个模式中，工厂类是整个模式的关键所在。它包含必要的判断逻辑，能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。用户在使用时可以直接根据工厂类去创建所需的实例，而无需了解这些对象是如何创建以及如何组织的，有利于整个软件体系结构的优化。不难发现，简单工厂模式的缺点也正体现在其工厂类上，由于工厂类集中了所有实例的创建逻辑，所以”高内聚”方面做的并不好，另外，当系统中的具体产品类不断增多时，可能会出现要求工厂类也要做相应的修改，扩展性并不是很好。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://izdo.github.io/tags/Java/"},{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"https://izdo.github.io/tags/设计模式/"}]},{"title":"RxJava2(下)","slug":"RxJava2(下)","date":"2017-06-04T01:54:38.652Z","updated":"2017-06-03T15:16:40.193Z","comments":true,"path":"2017/06/04/RxJava2(下)/","link":"","permalink":"https://izdo.github.io/2017/06/04/RxJava2(下)/","excerpt":"","text":"RxJava2(下)自定义图片缓存框架模型 在RxJava2的最后一部分我们利用RxJava2来做一个类似于Picasso的自定义图片缓存框架的模型(具体功能并不实现)，下面是我们要实现的自定义图片缓存框架的流程图。 解析：当我们发起一个加载图片的请求时，首先是去检查内存中是否有缓存，如果有的话直接显示图片，没有的话就检查文件中是否有缓存，有的话同样直接显示图片，没有的话再从网络上加载，然后再缓存到内存和文件中，通过这样的方式，可以减少从网络上请求数据的操作，这样不仅加快的图片的显示，而且还能降低流量的消耗，而不是说每次都到网络上下载数据。 新建ImgActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.izdo.rxjavaop;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.widget.Button;import com.jakewharton.rxbinding2.view.RxView;import io.reactivex.Observable;import io.reactivex.ObservableEmitter;import io.reactivex.ObservableOnSubscribe;import io.reactivex.functions.Consumer;public class ImgActivity extends AppCompatActivity &#123; private Button mButton; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_img); mButton = (Button) findViewById(R.id.btn_get); // 内存 final Observable&lt;String&gt; memoryObservable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123; e.onNext(\"memory\"); e.onComplete(); &#125; &#125;); // 文件 final Observable&lt;String&gt; diskObservable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123; e.onNext(\"disk\"); e.onComplete(); &#125; &#125;); // 网络 final Observable&lt;String&gt; netWorkObservable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123; e.onNext(\"network\"); e.onComplete(); &#125; &#125;); RxView.clicks(mButton).subscribe(new Consumer&lt;Object&gt;() &#123; @Override public void accept(Object o) throws Exception &#123; Observable.concat(memoryObservable, diskObservable, netWorkObservable) .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; Log.d(\"ImgActivity\", \"get data from\" + s); &#125; &#125;); &#125; &#125;); &#125;&#125; 布局文件同样只有一个按钮。这里通过三个Observable模拟出内存、文件和网络，然后通过concat合并三个Observable(Concat操作符与上一篇文章中的Merge是一样的，只不过Merge可能会使数据发生交错)，最后再打印出合并后的结果即可。 效果图 从图中可以看出，获取数据的来源是内存、文件和网络，那么我们刚才所说的内存-&gt;文件-&gt;网络逐一检查该怎么实现呢？这个时候就要用到Filter操作符了。PS：RxJava2与RxJava1有所不同，RxJava1可以使用First操作符限制其只发送第一个非null数据，而在RxJava2中则需要使用Filter进行过滤。 修改ImgActicity中的代码123456789101112131415161718192021222324252627282930public class ImgActivity extends AppCompatActivity &#123; private Button mButton; @Override protected void onCreate(Bundle savedInstanceState) &#123; ... RxView.clicks(mButton).subscribe(new Consumer&lt;Object&gt;() &#123; @Override public void accept(Object o) throws Exception &#123; Observable.concat(memoryObservable, diskObservable, netWorkObservable) .filter(new Predicate&lt;String&gt;() &#123; @Override public boolean test(String s) throws Exception &#123; return !TextUtils.isEmpty(s); &#125; &#125;) .firstElement() .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; Log.d(\"ImgActivity\", \"get data from \" + s); &#125; &#125;); &#125; &#125;); &#125;&#125; 这里使用Filter过滤掉null对象。需要注意的是，RxJava1是可以发送null对象的，也就是onNext(null)，而RxJava2中不能发送null对象，如果使用RxJava2时发送null对象，则会报错：java.lang.NullPointerException: onNext called with null. Null values are generally not allowed in 2.x operators and sources.，也就是说RxJava2中不需要发送null对象。那么我们这里的处理就是直接发送空值：//e.onNext(“”);而通过Filter操作符，这个空值是会被过滤掉的，然后通过FirstElement()获取第一个数据。 当三个Observable都不为空值时 这个情况代表内存中缓存，则直接读取内存显示图片。 memoryObservable发送空值 这个情况代表内存无缓存，而文件中右缓存，则直接读取文件显示图片。 diskObservable发送空值 这个情况代表内存和文件中均无缓存，这个时候则从网络上获取图片然后再显示。这样模拟图片显示的效果就实现了，接下来会正式地编写自定义的图片缓存框架。 模仿Picasso自定义图片缓存框架 在我的OKHttp3框架(上)文章中，曾经使用过Picasso加载图片： 12345678/** * Picasso 第三方开源框架 * load() 加载图片地址 * resize() 设置图片大小 * centerCrop() 设置图片圆角 * into() 显示到控件*/Picasso.with(UserInfoActivity.this).load(img).resize(100, 100).centerCrop().into(mImgview); 当我们在使用Picasso框架加载图片的时候，短短的一句话就能让我们成功地获取图片并显示，这样的框架用起来是非常爽的，而我们现在就要模仿Picasso框架的写法，使用RxJava2来自定义一个图片缓存框架。 新建RxImageLoader类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package Imgloader;import android.content.Context;import android.widget.ImageView;import io.reactivex.Observable;import io.reactivex.Observer;import io.reactivex.disposables.Disposable;import io.reactivex.functions.Predicate;/** * Created by iZdo on 2017/5/31. */public class RxImageLoader &#123; // 创建单例 static RxImageLoader singleton; private String mUrl; private RequestCreator mRequestCreator; // 单例模式私有化构造器 private RxImageLoader() &#123; mRequestCreator = new RequestCreator(); &#125; public static RxImageLoader with(Context context) &#123; if (singleton == null) &#123; synchronized (RxImageLoader.class) &#123; // 当单例为空时则新建一个单例 if (singleton == null) &#123; singleton = new Builder(context).build(); &#125; &#125; &#125; return singleton; &#125; /** * url 加载图片的地址 */ public RxImageLoader load(String url) &#123; this.mUrl = url; return singleton; &#125; /** * imgView 显示图片的控件 */ public void into(final ImageView imgview) &#123; Observable.concat(mRequestCreator.getImageFromMemory(mUrl), mRequestCreator.getImageFromDisk(mUrl), mRequestCreator.getImageFromNetwork(mUrl)) .filter(new Predicate&lt;Image&gt;() &#123; @Override public boolean test(Image image) throws Exception &#123; return false; &#125; &#125;) .subscribe(new Observer&lt;Image&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Image value) &#123; imgview.setImageBitmap(value.getBitmap()); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125; &#125;); &#125; // 单例模式创建RxImageLoader public static class Builder &#123; private Context mContext; public Builder(Context context) &#123; this.mContext = context; &#125; public RxImageLoader build() &#123; return new RxImageLoader(); &#125; &#125;&#125; 这种单例模式的创建方法是很常见的，将构造器私有化并在Builder()方法中只创建一个实例，调用者只能用这个实例去调用其他方法。 新建Image类作为图片封装类1234567891011121314151617181920212223242526272829303132333435package Imgloader;import android.graphics.Bitmap;/** * Created by iZdo on 2017/6/1. */public class Image &#123; private String url; private Bitmap bitmap; public Image(String url, Bitmap bitmap) &#123; this.url = url; this.bitmap = bitmap; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public Bitmap getBitmap() &#123; return bitmap; &#125; public void setBitmap(Bitmap bitmap) &#123; this.bitmap = bitmap; &#125;&#125; 这个类比较简单，只有一个url地址和bitmap以及其get()、set()方法。 新建CacheObservable类作为缓存类123456789101112131415161718192021222324252627282930313233package Imgloader;import io.reactivex.Observable;import io.reactivex.ObservableEmitter;import io.reactivex.ObservableOnSubscribe;/** * Created by iZdo on 2017/6/1. */public abstract class CacheObservable &#123; public Observable&lt;Image&gt; getImage(final String url) &#123; return Observable.create(new ObservableOnSubscribe&lt;Image&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Image&gt; e) throws Exception &#123; if (!e.isDisposed()) &#123; Image image = getDataFromCache(url); e.onNext(image); e.onComplete(); &#125; &#125; &#125;); &#125; // 获取缓存 public abstract Image getDataFromCache(String url); // 设置缓存 public abstract void putDataToCache(Image image);&#125; 由于我们获取缓存的方式有内存、文件和网络，所以需要将这个缓存类作为一个父类，然后每种缓存方式都继承自这个缓存类，而具体的缓存方式处理数据的方式又有所不同，所以缓存类中需要有抽象方法，当子类继承这个缓存类的时候，才去具体实现相应的处理，所以缓存类需要定义为抽象类，而对于getImage()方法来说，每种方式显示图片的方法都是一致的，所以此方法在缓存类中实现即可。 内存缓存类1234567891011121314151617package Imgloader;/** * Created by iZdo on 2017/6/1. */public class MemoryCacheObservable extends CacheObservable &#123; @Override public Image getDataFromCache(String url) &#123; return null; &#125; @Override public void putDataToCache(Image image) &#123; &#125;&#125; 文件缓存类1234567891011121314151617package Imgloader;/** * Created by iZdo on 2017/6/1. */public class DiskCacheObservable extends CacheObservable&#123; @Override public Image getDataFromCache(String url) &#123; return null; &#125; @Override public void putDataToCache(Image image) &#123; &#125;&#125; 网络缓存类1234567891011121314151617package Imgloader;/** * Created by iZdo on 2017/6/1. */public class NetworkCacheObservable extends CacheObservable &#123; @Override public Image getDataFromCache(String url) &#123; return null; &#125; @Override public void putDataToCache(Image image) &#123; &#125;&#125; 新建RequestCreator类用于实例化三个缓存类12345678910111213141516171819202122232425262728293031323334353637383940package Imgloader;import io.reactivex.Observable;/** * Created by iZdo on 2017/6/1. */public class RequestCreator &#123; private MemoryCacheObservable mMemoryCacheObservable; private DiskCacheObservable mDiskCacheObservable; private NetworkCacheObservable mNetworkCacheObservable; // 构造器 初始化三个缓存类 public RequestCreator() &#123; mMemoryCacheObservable = new MemoryCacheObservable(); mDiskCacheObservable = new DiskCacheObservable(); mNetworkCacheObservable = new NetworkCacheObservable(); &#125; // 从内存中获取图片 public Observable&lt;Image&gt; getImageFromMemory(String url) &#123; return mMemoryCacheObservable.getImage(url); &#125; // 从文件中获取图片 public Observable&lt;Image&gt; getImageFromDisk(String url) &#123; return mDiskCacheObservable.getImage(url); &#125; // 从网络获取图片 public Observable&lt;Image&gt; getImageFromNetwork(String url) &#123; return mNetworkCacheObservable.getImage(url); &#125;&#125; 这个类主要用于创建三种缓存类，而调用者只需要实例化RequestCreator类就能同时操作这三种缓存方式了。这样，自定义图片缓存框架大体上的模板已经完成了。 新建ImgLoaderActivity类123456789101112131415161718192021222324252627282930313233343536package com.izdo.rxjavaop;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.widget.Button;import android.widget.ImageView;import com.jakewharton.rxbinding2.view.RxView;import Imgloader.RxImageLoader;import io.reactivex.functions.Consumer;public class ImgLoaderActivity extends AppCompatActivity &#123; private Button mButton; private ImageView mImageView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_imgloader); mButton = (Button) findViewById(R.id.btn_getImg); mImageView = (ImageView) findViewById(R.id.imageview); RxView.clicks(mButton).subscribe(new Consumer&lt;Object&gt;() &#123; @Override public void accept(Object o) throws Exception &#123; RxImageLoader.with(ImgLoaderActivity.this) .load(\"https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1035293498,3690663067&amp;fm=23&amp;gp=0.jpg\") .into(mImageView); &#125; &#125;); &#125;&#125; 自定义的图片缓存框架调用方式和Picasso基本上是一样的，但是由于这只是一个模型，具体的功能并没有实现，所以就不进行测试了。 最后再提供几篇可以参考的文章，本篇文章遇到的bug大多数参考自以下文章以及RxJava2(上)文章开头所提供的几篇文章：[转]RxJava1 升级到 RxJava2 所踩过的坑[转]深入浅出RxJava2.0_02[新特性]","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"}]},{"title":"RxJava2(中)","slug":"RxJava2(中)","date":"2017-05-30T15:04:17.026Z","updated":"2017-05-30T15:06:12.621Z","comments":true,"path":"2017/05/30/RxJava2(中)/","link":"","permalink":"https://izdo.github.io/2017/05/30/RxJava2(中)/","excerpt":"","text":"RxJava2(中)操作符 RxJava中的操作符有很多种，而前面用到的From、just也是操作符。想要更深入地了解操作符可以参考以下博客：[转]深入浅出RxJava(一：基础篇)[转]深入浅出RxJava(二：操作符)[转]RxJava操作符学习笔记 接下来简单介绍一下变换操作符。 Map操作符Map操作符对原始Observable发射的每一项数据应用一个你选择的函数，然后返回一个发射这些结果的Observable。RxJava将这个操作符实现为Map函数，这个操作符默认不在任何特定的调度器上执行。Map操作符就是用于变换Observable对象的。 新建MapActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.izdo.rxjava2demo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.TextView;import io.reactivex.Observable;import io.reactivex.functions.Consumer;import io.reactivex.functions.Function;public class MapActivity extends AppCompatActivity &#123; private Api api; private TextView mTextView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_map); mTextView = (TextView) findViewById(R.id.text); &#125; public void click_map(View view) &#123; Observable observable = Observable.just(1); // 使用map进行转换 // Integer -&gt; String Observable observableMap = observable.map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(Integer integer) throws Exception &#123; return 1 + \"lalala\"; &#125; &#125;); // 订阅 observableMap.subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; &#125; &#125;); &#125;&#125; PS:布局文件文件只有一个按钮，点击事件为”click_map”。代码中使用map将原始的Observable的Integer类型的数据转换为String类型，并且得到的结果成为一个新的Observable，而订阅这个Observable需要用新的Observable调用subscribe方法，也就是说通过map转换的Observable和原始的Observable成为两个独立的Observable了。 那么也许有人就会问了，如果单纯地只是想把Integer数据类型转化为String类型，那何必这么麻烦呢？当然没有必要，但是，转换的强大之处在于泛型中可以是任意数据类型，可以是基本数据类型，当然也可以是引用类型，只要在转换中处理得当。 修改click_map()中的代码1234567891011121314151617181920212223242526272829303132public void click_map(View view) &#123; Observable.just(1).map(new Function&lt;Integer,Info&gt;() &#123; @Override public Info apply(Integer integer) throws Exception &#123; // do something return null; &#125; &#125;); /*Observable observable = Observable.just(1); // 使用map进行转换 // Integer -&gt; String Observable observableMap = observable.map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(Integer integer) throws Exception &#123; return 1 + \"lalala\"; &#125; &#125;); // 订阅 observableMap.subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; &#125; &#125;);*/&#125; 这里使用链式编程让代码简洁一些，同时将原先的Intege-&gt;String修改为Integer-&gt;Info，而具体的逻辑就暂时不实现了。(我们甚至可以转换为一个Obsevable，这里就不多做解释了,后面会有例子详细地介绍。) FlatMap操作符 FlatMap将一个发射数据的Observable变换为多个Observables，然后将它们发射的数据合并后放进一个单独的Observable。接下来做一个实际的案例。 新建BaseResult类用于保存登录返回的结果12345678910111213141516171819202122232425262728293031323334353637package com.izdo.rxjava2demo;/** * Created by iZdo on 2017/5/18. */public class BaseResult &#123; private int succerss; private String message; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; private int id; public int getSuccerss() &#123; return succerss; &#125; public void setSuccerss(int succerss) &#123; this.succerss = succerss; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 修改Api中的代码123456789public interface Api &#123; @GET(\"myserver\") Call&lt;Info&gt; getUserInfo(@Query(\"id\") int id); @POST(\"myserver/Json\") Call&lt;BaseResult&gt; login(@Body UserParam param);&#125; 新建UserParam保存用户名和密码1234567891011121314151617181920212223242526272829303132package com.izdo.rxjava2demo;/** * Created by iZdo on 2017/5/28. */public class UserParam &#123; private String username; private String password; public UserParam(String username, String password) &#123;\\ this.username = username; this.password = password; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 修改MapActivity中的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class MapActivity extends AppCompatActivity &#123; private Api api; private TextView mTextView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_map); Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"http://192.168.1.53:8080/\") .addConverterFactory(GsonConverterFactory.create()) .build(); api = retrofit.create(Api.class); mTextView = (TextView) findViewById(R.id.text); &#125; private UserParam getUserParam() &#123; UserParam param = new UserParam(\"admin\", \"123456\"); return param; &#125; public void click_map(View view) &#123; Observable.just(getUserParam()).flatMap(new Function&lt;UserParam, ObservableSource&lt;BaseResult&gt;&gt;() &#123; @Override public ObservableSource&lt;BaseResult&gt; apply(UserParam userParam) throws Exception &#123; BaseResult result = api.login(userParam).execute().body(); return Observable.just(result); &#125; &#125;).flatMap(new Function&lt;BaseResult, ObservableSource&lt;Info&gt;&gt;() &#123; @Override public ObservableSource&lt;Info&gt; apply(BaseResult baseResult) throws Exception &#123; Info info = api.getUserInfo(baseResult.getId()).execute().body(); return Observable.just(info); &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Info&gt;() &#123; @Override public void accept(Info info) throws Exception &#123; mTextView.setText(info.getName()); &#125; &#125;); /* Observable.just(1).map(new Function&lt;Integer,Info&gt;() &#123; @Override public Info apply(Integer integer) throws Exception &#123; // do something return null; &#125; &#125;);*/ /*Observable observable = Observable.just(1); // 使用map进行转换 // Integer -&gt; String Observable observableMap = observable.map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(Integer integer) throws Exception &#123; return 1 + \"lalala\"; &#125; &#125;); // 订阅 observableMap.subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; &#125; &#125;);*/ &#125;&#125; 这里主要是通过Retrofit发起网络请求，首先将username为”admin”,password为”123456”的UserParam对象传入Api的login方法中，通过Retrofit发起网络请求，接收到的Json数据已通过BaseResult封装好，通过flatMap()将其转换为BaseResult后再次转换为Info对象，而这也证实了Map操作符的强大之处，可以随心所欲地转换对象。PS：网络请求等耗时操作记得放到子线程中执行：subscribeOn(Schedulers.io()) ，UI操作需要切换回主线程：observeOn(AndroidSchedulers.mainThread()) 部署项目 Debounce操作符 当我们在搜索(例如百度)的时候，每当输入一个关键字，下方选择框就会出现相应的搜索选项。 就如图中红框所示的部分，而如何实现这个功能呢？一般的情况下是通过监听EditText控件，当控件中的值发生改变时去请求搜索接口，但是这样的做法有两个缺点，一个是因为控件的值没改变一次立即就会去请求网络，可能会导致很多没有意义的请求，耗费用户流量；另一个是可能会导致最终搜索的结果不是用户想要的，例如当你想搜索”手机”这个关键词的时候，假如你输入”手’的时候发起的网络请求因为网络问题而导致请求缓慢，在输入”机”之后，成功获取到了”手机”关键词的搜索内容，但是这个时候刚才搜集”手”的请求结果返回了，这时候就会出现”手”的请求结果把”手机”的请求结果覆盖了的情况，从而导致搜索结果不正确。这个时候就可以使用RxJava的Debounce操作符来解决这一问题。 新建工程RxJavaOp布局文件12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"com.izdo.rxjavaop.MainActivity\"&gt; &lt;EditText android:id=\"@+id/edit_search\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"请输入查询\"/&gt;&lt;/RelativeLayout&gt; MainActivity1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.izdo.rxjavaop;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.widget.EditText;import com.jakewharton.rxbinding2.widget.RxTextView;import java.util.ArrayList;import java.util.List;import java.util.concurrent.TimeUnit;import io.reactivex.Observable;import io.reactivex.ObservableSource;import io.reactivex.android.schedulers.AndroidSchedulers;import io.reactivex.functions.Consumer;import io.reactivex.functions.Function;import io.reactivex.schedulers.Schedulers;public class MainActivity extends AppCompatActivity &#123; private EditText mEditText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mEditText = (EditText) findViewById(R.id.edit_search); RxTextView.textChanges(this.mEditText) .debounce(200, TimeUnit.MILLISECONDS) // UI更新在主线程执行 .subscribeOn(AndroidSchedulers.mainThread()) .flatMap(new Function&lt;CharSequence, ObservableSource&lt;List&lt;String&gt;&gt;&gt;() &#123; @Override public ObservableSource&lt;List&lt;String&gt;&gt; apply(CharSequence charSequence) throws Exception &#123; Log.d(\"MainActivity\", \"flatMap== \" + charSequence); // search List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"abc\"); list.add(\"acb\"); return Observable.just(list); &#125; &#125;) // 网络请求在子线程执行 .subscribeOn(Schedulers.io()) // 切换回主线程 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;List&lt;String&gt;&gt;() &#123; @Override public void accept(List&lt;String&gt; strings) throws Exception &#123; // 输出结果 Log.d(\"MainActivity\", \"subscribe: \" + strings); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; // 输出错误信息 throwable.printStackTrace(); &#125; &#125;); &#125;&#125; 这里主要通过RxTextView的textChanges方法进行监听，并调用debounce()方法设置每隔200毫秒后才发出请求，这样就解决了多次请求的问题，接着通过filter()过滤空数据，其他的操作都是RxJava的操作，这里不多解释，主要还是要强调一下，相应的操作应该放在对应的线程中执行。 效果图 接下来需要解决上文所说的第二个问题，这时候就需要用到switchMap操作符了。 switchMap操作符 switchMAP()将Observable发射的数据集合变换为Observables集合，然后只发射这些Observables最近发射的数据。 修改MAinActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class MainActivity extends AppCompatActivity &#123; private EditText mEditText; @Override protected void onCreate(Bundle savedInstanceState) &#123; ... RxTextView.textChanges(this.mEditText) .debounce(200, TimeUnit.MILLISECONDS) // UI更新在主线程执行 .subscribeOn(AndroidSchedulers.mainThread()) // 过滤数据 .filter(new Predicate&lt;CharSequence&gt;() &#123; @Override public boolean test(CharSequence charSequence) throws Exception &#123; if (charSequence.toString().trim().length() &gt; 0) return true; return false; &#125; &#125;) .switchMap(new Function&lt;CharSequence, ObservableSource&lt;List&lt;String&gt;&gt;&gt;() &#123; @Override public ObservableSource&lt;List&lt;String&gt;&gt; apply(CharSequence charSequence) throws Exception &#123; Log.d(\"MainActivity\", \"flatMap== \" + charSequence); // search List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"abc\"); list.add(\"acb\"); return Observable.just(list); &#125; &#125;) /*.flatMap(new Function&lt;CharSequence, ObservableSource&lt;List&lt;String&gt;&gt;&gt;() &#123; @Override public ObservableSource&lt;List&lt;String&gt;&gt; apply(CharSequence charSequence) throws Exception &#123; Log.d(\"MainActivity\", \"flatMap== \" + charSequence); // search List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"abc\"); list.add(\"acb\"); return Observable.just(list); &#125; &#125;)*/ ... &#125;&#125; 也就是说switchMap操作符会以最后一次输入的值为基准，将上一次的值给清空掉，这样就解决了因为网络缓慢导致的结果覆盖问题。 ThrottleFirst操作符 当我们到一个网站注册用户时，在相关资料输入完毕后，我们需要点击注册按钮注册，当我们点击按钮之后，它就会向服务器端发送数据，而有时候有的人可能会(恶意)重复点击按钮，这时候就会不断向服务器发送重复数据，而这些重复的垃圾数据会浪费服务器的资源，那我们该如何解决重复点击按钮呢？一般的做法是计算两次点击的时间差，如果时间差太小则判定为重复点击，用这样的方式来防止重复点击按钮，而在RxJava中，可以通过throttleFirst操作符来实现这个功能。throttleFirst操作符允许设置一个时间长度，之后它会发送固定时间长度内的第一个事件，而屏蔽其它时间，在间隔达到设置的时间后，可以再发送下一个事件。 新建ExampleActivity类(修改ExampleActivity类为默认启动的Activity)123456789101112131415161718192021package com.izdo.rxjavaop;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.View;public class ExampleActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_example); &#125; public void click(View view) &#123; Log.d(\"ExampleActivity\", \"我被点击了\"); &#125;&#125; 现在来看一下当我们正常点击时所打印的log。PS:布局文件只有一个按钮。 下来使用throttleFirst操作符进行重复限制。 123456789101112131415161718192021222324252627282930313233public class ExampleActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_example); Button button = (Button) findViewById(R.id.btn); RxView.clicks(button).throttleFirst(1, TimeUnit.SECONDS).subscribe(new Observer&lt;Object&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Object value) &#123; Log.d(\"ExampleActivity\", \"我被点击了\"); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125; &#125;); &#125;&#125; 用法非常简单，首先调用RxView的clicks()方法将想要监听的按钮绑定好，然后调用throttleFirst()将间隔设置为1秒，最后调用subscribe()订阅即可。 可以看到，不管多么快速的点击，都只会在隔一秒打印出新的log，而这个log响应的是第一次点击按钮时的操作。这样我们就通过了throttleFirst操作符防止重复点击操作(也叫防抖操作)。PS：微信有些地方也没有做防抖操作处理，快速点击朋友圈按钮也会出现重复的页面。 Merge操作符 当我们在使用淘宝购物时，需要将想要购买的物品放入购物车，然后进行付款操作才算购买完成。假设小明现在用手机淘宝购买一件衣服和一件裤子，然后将它们加入购物车，但是小明忘了自己的手机没有联网，所以手机的本地数据并没有上传的云端，接着小明使用电脑淘宝将一件帽子和一双鞋子放入购物车，那么这时候本地的数据和云端的数据需要同步，才能将这四件物品同时展示在购物车中，否则电脑端的购物车只会显示帽子和鞋子，而手机端的购物车只会显示衣服和裤子。这歌时候就需要用到Merge操作符来实现合并的功能了。Merge操作符能够合并多个Observables的发射物。使用Merge操作符可以将多个Observables的输出合并，就好像它们是一个单个的Observable一样。Merge操作符可能会让合并的Observables发射的数据交错(另一个类似的操作符Concat不会让数据交错，它会按顺序一个接着一个发射多个Observables的发射物)。 新建Api接口12345678910111213141516package com.izdo.rxjavaop;import java.util.List;import io.reactivex.Observable;import retrofit2.http.GET;/** * Created by iZdo on 2017/5/30. */public interface Api &#123; @GET(\"myserver\") Observable&lt;List&lt;Commodity&gt;&gt; getCommodity();&#125; Api接口前面已经用过很多次了，这里不多解释。 新建Commodity类用于保存商品的名称和id12345678910111213141516171819202122232425262728293031323334package com.izdo.rxjavaop;/** * Created by iZdo on 2017/5/30. */public class Commodity &#123; private int id; private String name; public Commodity() &#123; &#125; public Commodity(String name) &#123; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 新建MergeActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.izdo.rxjavaop;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.View;import java.util.ArrayList;import java.util.List;import io.reactivex.Observable;import io.reactivex.Observer;import io.reactivex.disposables.Disposable;import io.reactivex.schedulers.Schedulers;import retrofit2.Retrofit;import retrofit2.converter.gson.GsonConverterFactory;public class MergeActivity extends AppCompatActivity &#123; private Api api; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_merge); Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"http://192.168.1.53:8080/\") .addConverterFactory(GsonConverterFactory.create()) .build(); api = retrofit.create(Api.class); &#125; public void click(View view) &#123; Observable.merge(getDataFromLocal(), getDataFromNetwork()).subscribe(new Observer&lt;List&lt;Commodity&gt;&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(List&lt;Commodity&gt; commodity) &#123; for (Commodity c : commodity) &#123; Log.d(\"MergeActivity\", \"name: \" + c.getName()); &#125; &#125; @Override public void onError(Throwable e) &#123; e.printStackTrace(); &#125; @Override public void onComplete() &#123; Log.d(\"MergeActivity\", \"onComplete \"); &#125; &#125;); &#125; // 本地数据 private Observable&lt;List&lt;Commodity&gt;&gt; getDataFromLocal() &#123; List&lt;Commodity&gt; list = new ArrayList&lt;&gt;(); list.add(new Commodity(\"衣服\")); list.add(new Commodity(\"裤子\")); return Observable.just(list); &#125; // 云端数据 private Observable&lt;List&lt;Commodity&gt;&gt; getDataFromNetwork() &#123; return api.getCommodity().subscribeOn(Schedulers.io()); &#125;&#125; PS：布局文件同样只有一个按钮。服务器端的数据已经预先准备好。 效果图 这样服务器端和本地的数据已经合并在一起了。 Interval操作符 在日常生活中，我们经常会通过手机获取验证码，而这个时候，验证码输入框旁边的按钮就会出现倒计时，如果倒计时结束后还未输入验证码，则可以重新获取验证码，接下来就通过RxJava的interval操作符实现这个功能。Interval操作符创建一个按固定时间间隔发射整数序列的Observable。Interval返回一个Observable，它按固定的时间间隔发射一个无限递增的整数序列。 新建IntervalActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.izdo.rxjavaop;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.EditText;import java.util.concurrent.TimeUnit;import io.reactivex.Observable;import io.reactivex.Observer;import io.reactivex.disposables.Disposable;public class IntervalActivity extends AppCompatActivity &#123; private EditText mEditText; private Button mButton; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_interval); mEditText = (EditText) findViewById(R.id.edit_mobi); mButton = (Button) findViewById(R.id.btn_send); &#125; public void click(View view) &#123; Observable.interval(0, 1, TimeUnit.SECONDS).subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Long value) &#123; Log.d(\"IntervalActivity\", \"onNext\" + value); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; Log.d(\"IntervalActivity\", \"onComplete\"); &#125; &#125;); &#125;&#125; 布局文件123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_interval\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"com.izdo.rxjavaop.IntervalActivity\"&gt; &lt;EditText android:id=\"@+id/edit_mobi\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"请输入验证码\"/&gt; &lt;Button android:id=\"@+id/btn_send\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"#fc3778\" android:onClick=\"click\" android:text=\"发送验证码\" android:textColor=\"#ffffff\"/&gt;&lt;/LinearLayout&gt; 效果图 这是一个无限递增的”计时器”，但是目前存在一些问题： 计时器一般是倒计时 倒计时时按钮应该设为不可点击 倒计时时按钮上的文字应该设为对应的数字 计时是从0开始的，这点需要注意 接下来就一个一个地解决这些问题，首先计时器不能为无限递增，需要设置一个限制，这时候就要用到Take操作符了，而想要在倒计时时按钮设置为不可点击则可以在订阅时进行设置，可以使用doONSubscribe() 方法。 修改IntervalActivity中的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.izdo.rxjavaop;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.EditText;import java.util.concurrent.TimeUnit;import io.reactivex.Observable;import io.reactivex.Observer;import io.reactivex.android.schedulers.AndroidSchedulers;import io.reactivex.disposables.Disposable;import io.reactivex.functions.Consumer;import io.reactivex.functions.Function;public class IntervalActivity extends AppCompatActivity &#123; private EditText mEditText; private Button mButton; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_interval); mEditText = (EditText) findViewById(R.id.edit_mobi); mButton = (Button) findViewById(R.id.btn_send); &#125; public void click(View view) &#123; // 时限 final int count = 10; Observable.interval(0, 1, TimeUnit.SECONDS) // 设置时限 .take(count + 1) // 转换当前倒计时的值 .map(new Function&lt;Long, Long&gt;() &#123; @Override public Long apply(Long aLong) throws Exception &#123; return count - aLong; &#125; &#125;) // UI更新需要在主线程执行 .observeOn(AndroidSchedulers.mainThread()) // 在订阅时设置按钮不可点击 .doOnSubscribe(new Consumer&lt;Disposable&gt;() &#123; @Override public void accept(Disposable disposable) throws Exception &#123; mButton.setEnabled(false); &#125; &#125;) .subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Long value) &#123; Log.d(\"IntervalActivity\", \"onNext\" + value); // 设置当前剩余时间 mButton.setText(\"剩余\" + value + \"秒\"); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; Log.d(\"IntervalActivity\", \"onComplete\"); // 还原按钮初始化状态 mButton.setEnabled(true); mButton.setText(\"发送验证码\"); &#125; &#125;); &#125;&#125; 一般倒计时都是60秒，但是这里因为时间问题就只设置10秒。 效果图 现在倒计时就成功实现了，而且上述问题也都解决了，从图中可以看到，在倒计时时，无论怎么点击倒计时也不会重新开始，所以一个获取验证码倒计时的功能就完成了。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"}]},{"title":"RxJava2(上)","slug":"RxJava2(上)","date":"2017-05-30T15:04:17.023Z","updated":"2017-05-30T15:06:05.248Z","comments":true,"path":"2017/05/30/RxJava2(上)/","link":"","permalink":"https://izdo.github.io/2017/05/30/RxJava2(上)/","excerpt":"","text":"RxJava2(上)RxJava2是什么 RxJava2是一个在Java虚拟机上使用可观测的序列来组成异步的、基于事件的程序的库。总结起来就是异步、简单、强大。 RxJava github官网 [转]给 Android 开发者的 RxJava 详解 [转]RxJava2 vs RxJava1 RxJava中的概念 Observable:被观察者(主题Subject) Observer、Subscriber:观察者 Subscribe:订阅Observable和Observer通过subscribe()方法实现订阅关系。 RxJava2的基本使用 使用RxJava2首先理所当然的是要添加依赖了： compile ‘io.reactivex.rxjava2:rxjava:2.1.0’ compile ‘io.reactivex.rxjava2:rxandroid:2.0.1’ 1.创建Observable1234567891011Observable&lt;String&gt; observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123; // 发送通知 e.onNext(\"hello\"); e.onNext(\"world\"); // 完成通知 e.onComplete(); &#125;&#125;); 2.创建Observer123456789101112131415161718192021Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(\"MainActivity\", \"onSubscribe: \" + d.isDisposed()); &#125; @Override public void onNext(String s) &#123; Log.d(\"MainActivity\", \"onNext: \" + s); &#125; @Override public void onError(Throwable e) &#123; Log.d(\"MainActivity\", \"onError: \" + e.getLocalizedMessage()); &#125; @Override public void onComplete() &#123; Log.d(\"MainActivity\", \"onComplete \"); &#125;&#125;; ps:onComplete()和onError()是互斥的，一次只能调用其中一个。 3.订阅1observable.subscribe(oberver); 这是RxJava2的基本使用方法，接下来就用一个实际案例来认识一下RxJava2。 创建新工程RxJava2Demoactivity_main布局文件1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"com.izdo.rxjava2demo.MainActivity\"&gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"click\" android:text=\"test\"/&gt;&lt;/LinearLayout&gt; MainActivity1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.izdo.rxjava2demo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.View;import io.reactivex.Observable;import io.reactivex.ObservableEmitter;import io.reactivex.ObservableOnSubscribe;import io.reactivex.Observer;import io.reactivex.disposables.Disposable;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void click(View view) &#123; Observable&lt;String&gt; observable = getObservable(); Observer&lt;String&gt; observer = getObserver(); observable.subscribe(observer); &#125; public Observable&lt;String&gt; getObservable() &#123; return Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123; e.onNext(\"状态改变了\"); e.onNext(\"状态又改变了\"); e.onComplete(); &#125; &#125;); &#125; public Observer&lt;String&gt; getObserver() &#123; return new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(\"MainActivity\", \"onSubscribe\"); &#125; @Override public void onNext(String s) &#123; Log.d(\"MainActivity\", \"onNext\"); &#125; @Override public void onError(Throwable e) &#123; Log.d(\"MainActivity\", \"onError\"); &#125; @Override public void onComplete() &#123; Log.d(\"MainActivity\", \"onComplete\"); &#125; &#125;; &#125;&#125; 部署项目 可以看到，log的打印顺序为onSubscribe-&gt;onNext-&gt;onNext-&gt;onComplete,除了onSubscribe，后面的打印顺序与subscribe()方法中的调用顺序是一致的，由此可以推测出onSubscribe()方法是在每次接收数据之前就会调用的方法。那么onSubscribe()方法有什么用呢？在代码中我们可以看到onSubscribe()方法接收一个Disposable参数，而Disposable这个对象有一些常用的方法： dispose() : 用于取消订阅关系。 isDisposed() : 用于查看是否有订阅关系。 修改getObserver()中的代码12345678910111213141516171819202122232425public Observer&lt;String&gt; getObserver() &#123; return new Observer&lt;String&gt;() &#123; Disposable disposable = null; @Override public void onSubscribe(Disposable d) &#123; disposable = d; Log.d(\"MainActivity\", \"onSubscribe\"); &#125; @Override public void onNext(String s) &#123; Log.d(\"MainActivity\", \"onNext\"); if (s.equals(\"取消订阅\")) &#123; disposable.dispose(); &#125; &#125; ... &#125;; &#125; 所以Disposable参数常用于上述代码所体现的取消订阅。 简洁写法修改click()方法中的代码1234567891011121314151617181920212223public void click(View view) &#123; Observable&lt;String&gt; observable = getObservable(); //Observer&lt;String&gt; observer = getObserver(); //observable.subscribe(observer); observable.subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(@NonNull Throwable throwable) throws Exception &#123; &#125; &#125;, new Action() &#123; @Override public void run() throws Exception &#123; &#125; &#125;);&#125; 这里可以看到将Observer和订阅的代码注释掉而改用匿名内部类的方式new出两个Consumer和一个Action，分别对应的是onNext()、onError()、onComplete()，这样写的话创建Observable的代码就简洁了很多。那么还有其他简洁的写法吗？答案是有的。 修改getObservable()方法中的代码123456789101112131415public Observable&lt;String&gt; getObservable() &#123; Observable observable = Observable.just(\"状态改变了\", \"状态又改变了\", \"状态再次改变了\"); return observable; // return Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; // @Override // public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123; // // e.onNext(\"状态改变了\"); // e.onNext(\"状态又改变了\"); // e.onComplete(); // &#125; // &#125;); &#125; Observable.just(“状态改变了”, “状态又改变了”, “状态再次改变了”)这里的just里的三个参数相当于observable调用了三次onNext()方法。 修改click()方法中的代码12345678910111213public void click(View view) &#123; Observable&lt;String&gt; observable = getObservable(); //Observer&lt;String&gt; observer = getObserver(); //observable.subscribe(observer); observable.subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; Log.d(\"MainActivity\", \"accept:=\" + s); &#125; &#125;); &#125; 这里只保留一个accept()方法，并在accept()方法里打出log。 部署项目 可以看到，log日志成功打印出来了，这也是一种简化代码的方式。 修改getObservable()方法12345678910public Observable&lt;String&gt; getObservable() &#123; // Observable observable = Observable.just(\"状态改变了\", \"状态又改变了\", \"状态再次改变了\"); Observable observable = Observable.fromArray(\"状态改变了\", \"状态又改变了\", \"状态再次改变了\"); return observable;&#125; 这种方式也能够实现同样的效果,而fromArray()中实际是一个数组,just()方法中其实也是通过调用而fromArray()方法来实现的。 再次修改getObservable()方法12345678910111213public Observable&lt;String&gt; getObservable() &#123; // Observable observable = Observable.just(\"状态改变了\", \"状态又改变了\", \"状态再次改变了\"); // Observable observable = Observable.fromArray(\"状态改变了\", \"状态又改变了\", \"状态再次改变了\"); return Observable.fromCallable(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return \"状态改变了\"; &#125; &#125;);&#125; 这种方式同样也能够实现，只不过相对于其他两种方式，fromCallable()方式有参数的限制。 线程控制 我们都知道在Android中需要操作网络等耗时的操作时都需要开启一个子线程来执行，而子线程中是不能更新UI的，所以我们一般都会使用Handler或者AsyncTask异步任务来完成，而我们一开始就说了，RxJava2是一个异步框架，所以我们接下来就使用RxJava2来实现线程控制。 新建SchedulerTestActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.izdo.rxjava2demo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.View;import android.widget.TextView;import io.reactivex.Observable;import io.reactivex.ObservableEmitter;import io.reactivex.ObservableOnSubscribe;import io.reactivex.Observer;import io.reactivex.disposables.Disposable;public class SchedulerTestActivity extends AppCompatActivity &#123; private TextView mTextView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_scheduler_test); mTextView = (TextView) findViewById(R.id.text); &#125; public void click(View view) &#123; Observable.create(new ObservableOnSubscribe&lt;Info&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Info&gt; e) throws Exception &#123; // 请求network Info info = new Info(\"3\",\"admin\"); e.onNext(info); &#125; &#125;).subscribe(new Observer&lt;Info&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Info info) &#123; Log.d(\"SchedulerTestActivity\", \"\"+info); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125; &#125;); &#125;&#125; 这里主要逻辑在click()方法中，主要还是使用了RxJava2的基本用法，创建一个Observable，并发出请求再打印出log日志。 activity_scheduler_test布局文件1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_scheduler_test\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"com.izdo.rxjava2demo.SchedulerTestActivity\"&gt; &lt;Button android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:onClick=\"click\" android:text=\"Test\"/&gt; &lt;TextView android:id=\"@+id/text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt;&lt;/LinearLayout&gt; 布局文件比较简单，只有一个Button和一个TextView 新建Api接口类和Info类12345678910111213141516171819package com.izdo.rxjava2demo;import retrofit2.Call;import retrofit2.http.GET;import retrofit2.http.Path;/** * Created by iZdo on 2017/5/15. */public interface Api &#123; @GET(\"myserver\") Call&lt;Info&gt; getUserInfo(@Query(\"id\") int id); @GET(\"myserver/&#123;id&#125;\") Call&lt;Info&gt; getUserInfoWithPath(@Path(\"id\") int id);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.izdo.rxjava2demo;import com.google.gson.Gson;/** * Created by iZdo on 2017/5/15. */public class Info &#123; /** * id : 1 * name : 香菜 * img : https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1035293498,3690663067&amp;fm=23&amp;gp=0.jpg */ private String id; private String name; private String img; public Info(String id, String name, String img) &#123; this.id = id; this.name = name; this.img = img; &#125; public Info(String id, String name) &#123; this.id = id; this.name = name; &#125; public Info() &#123; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getImg() &#123; return img; &#125; public void setImg(String img) &#123; this.img = img; &#125; @Override public String toString() &#123; return new Gson().toJson(this); &#125;&#125; 这两个类是从Retrofit那篇博客中拷贝过来的，Api(因为后边会用到所以一并复制过来了)只保留亮个方法，Info类添加一个toString()方法。PS：因为后边需要用到Retrofit所以记得加上Retrofit的依赖。 效果图 接下来就使用Retrofit来发出网络请求了(服务器方面已事先准备好)。 修改SchedulerTestActivity中的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.izdo.rxjava2demo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.View;import android.widget.TextView;import io.reactivex.Observable;import io.reactivex.ObservableEmitter;import io.reactivex.ObservableOnSubscribe;import io.reactivex.Observer;import io.reactivex.disposables.Disposable;import io.reactivex.schedulers.Schedulers;import retrofit2.Retrofit;import retrofit2.converter.gson.GsonConverterFactory;public class SchedulerTestActivity extends AppCompatActivity &#123; private TextView mTextView; private Api api; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_scheduler_test); Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"http://192.168.1.53:8080/\") .addConverterFactory(GsonConverterFactory.create()) .build(); api = retrofit.create(Api.class); mTextView = (TextView) findViewById(R.id.text); &#125; public void click(View view) &#123; Observable.create(new ObservableOnSubscribe&lt;Info&gt;() &#123; // 在主线程中执行 @Override public void subscribe(ObservableEmitter&lt;Info&gt; e) throws Exception &#123; Info info = api.getUserInfo(1).execute().body(); // 请求network // Info info = new Info(\"3\", \"admin\"); e.onNext(info); &#125; &#125;).subscribeOn(Schedulers.io()) // 切换到子线程 .subscribe(new Observer&lt;Info&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Info info) &#123; Log.d(\"SchedulerTestActivity\", \"\" + info); &#125; @Override public void onError(Throwable e) &#123; e.printStackTrace(); &#125; @Override public void onComplete() &#123; &#125; &#125;); &#125;&#125; 由于subscribe()方法是在主线程中执行的，而我们要发起网络请求的话需要在子线程中进行，如果就这样运行的话会抛出NetworkOnMainThreadException,这时就需要用到subscribeOn()来切换到子线程，而此方法可以传入的参数有多个，这里暂且传入 Schedulers.io()，参数的类型后边会有所介绍。 部署到模拟器 可以看到，传入的id成功地返回给我们，并且服务器还返回了一个name。接下来我们就将这个name显示到TextView上。 修改click()方法中的代码12345678910111213141516171819202122public void click(View view) &#123; Observable.create(new ObservableOnSubscribe&lt;Info&gt;() &#123; ... &#125; &#125;).subscribeOn(Schedulers.io()) // 切换到子线程 .subscribe(new Observer&lt;Info&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Info info) &#123; Log.d(\"SchedulerTestActivity\", \"\" + info); mTextView.setText(info.getName()); &#125; ... &#125;); &#125; 这里仅仅是在onNext()方法中将获取的name设置到TextView上。 部署到模拟器 通过Log日志得知，虽然成功获取到数据，但是却不能设置到TextView上，而是出现了Only the original thread that created a view hierarchy can touch its view，这个错误是非常常见的，是我们在UI线程(主线程)之外的地方更新UI而导致的，所以在切换到子线程中发起网络请求之后，还需要将线程切换回主线程，而observeOn()方法就可以做到将线程切换回主线程。 修改click()方法中的代码123456789101112Observable.create(new ObservableOnSubscribe&lt;Info&gt;() &#123; ... &#125;&#125;).subscribeOn(Schedulers.io()) // 切换到子线程 .observeOn(AndroidSchedulers.mainThread()) // 切换回主线程 .subscribe(new Observer&lt;Info&gt;() &#123; ... &#125;); 部署到模拟器 线程切换的参数类型Schedulers.immediate() 直接在当前线程运行，相当于不指定线程。是默认的Scheduler。 Schedulers.newThread() 总是启用新线程，并在新线程执行操作。 Schedulers.io() I/O操作(读写文件、读写数据库、网络信息交互等)所使用的Scheduler。行为模式和newThread()差不多，区别在于io()的内部实现是用一个无数量上线的线程池，可以重用空闲的线程，因此多数情况下io()比newThread()更有效率。不要把计算工作放在io()中，可以避免创建不必要的线程。 Schedulers.computation() 计算所使用的Scheduler。这个计算指的是CPU密集型计算，即不会被I/O等操作限制性能的操作，例如图形的计算。这个Scheduler使用固定的线程池，大小为CPU核数。不要把I/O操作放在computation()中，否则I/O操作的等待时间会浪费CPU。 AndroidSchedulers.mainThread() 由它指定的操作将在Android主线程运行。 observeOn()指定Observer线程。observeOn作用于该操作符之后操作符直到出现新的observeOn操作符。subscribeOn()指定Observable线程。subscribeOn作用于该操作符之前的Observable的创建操符作以及doOnSubscribe操作符，换句话说就是doOnSubscribe以及Observable的创建操作符总是被其之后最近的subscribeOn控制。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"}]},{"title":"观察者模式","slug":"观察者模式","date":"2017-05-21T05:36:51.561Z","updated":"2017-05-29T14:09:55.307Z","comments":true,"path":"2017/05/21/观察者模式/","link":"","permalink":"https://izdo.github.io/2017/05/21/观察者模式/","excerpt":"","text":"观察者模式什么是观察者模式 观察者模式是对象的行为模式（有时又被称为发布（publish ）-订阅（Subscribe）模式、模型-视图（View）模式、源-收听者(Listener)模式或从属者模式）,是软件设计模式的一种。在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。观察者模式（Observer）完美的将观察者和被观察的对象分离开。举个例子，用户界面可以作为一个观察者，业务数据是被观察者，用户界面观察业务数据的变化，发现数据变化后，就显示在界面上。面向对象设计的一个原则是：系统中的每个类将重点放在某一个功能上，而不是其他方面。一个对象只做一件事情，并且将他做好。观察者模式在模块之间划定了清晰的界限，提高了应用程序的可维护性和重用性。观察者设计模式定义了对象间的一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。 观察者模式中的角色 抽象主题（Subject）：它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。具体主题（ConcreteSubject）：将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。抽象观察者（Observer）：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。具体观察者（ConcreteObserver）：实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调。 观察者模式图例 模拟观察者模式 观察者模式的介绍会比较抽象，接下来还是用实例来演示一下什么是观察者模式。PS：这里用的编译工具是Eclipse。 比如说：Subject是一个罪犯，而Observer是警察，而警察需要观察罪犯的一举一动，并且罪犯可能是一个穷凶极恶的罪犯，所以需要一个警察团队来监视的这个罪犯，所以警察可以放在一个整体中(例如集合)，当罪犯的状态发生改变时，警察会收到通知。 新建Java工程ObserverDemo新建Observer类 作为观察者123456789package iZdo;public interface Observer &#123; public String getName(); void update(String state);&#125; 新建Subject类 作为被观察者(被观察的主题)12345678910111213141516171819202122232425262728293031323334353637383940package iZdo;import java.util.ArrayList;import java.util.List;public abstract class Subject &#123; /** * 保存警察的集合 */ private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;(); /** * 添加一个监视罪犯的警察 * @param observer */ public void attach(Observer observer) &#123; observers.add(observer); System.out.println(\"您的好友\"+observer.getName()+\"已上线\"); &#125; /** * 移除一个监视的警察 * @param observer */ public void dettch(Observer observer) &#123; observers.remove(observer); System.out.println(\"警察\"+observer.getName()+\"已GG\"); &#125; /** * 通知所有警察更新罪犯的状态 * @param state */ public void notifyObservers(String state) &#123; for (Observer observer : observers) &#123; observer.update(state); &#125; &#125;&#125; 新建PoliceObserver类 作为警察观察者12345678910111213141516171819202122package iZdo;public class PoliceObserver implements Observer &#123; private String name; public PoliceObserver(String name) &#123; this.name = name; &#125; // 罪犯状态更新时通知警察 @Override public void update(String state) &#123; System.out.println(this.name+\"接收到消息，基德最新状态：\" + state); &#125; @Override public String getName() &#123; return name; &#125;&#125; 新建ThiefSubject 作为罪犯类123456789package iZdo;public class ThiefSubject extends Subject &#123; // 罪犯状态改变 public void onClick(String state) &#123; notifyObservers(state); &#125;&#125; 新建Test类 作为测试类123456789101112131415161718192021222324252627package iZdo;public class Test &#123; public static void main(String[] args) &#123; // 创建警察 Observer observer1 = new PoliceObserver(\"黑猫警长\"); Observer observer2 = new PoliceObserver(\"威威猫\"); Observer observer3 = new PoliceObserver(\"柯南\"); // 创建罪犯 ThiefSubject subject = new ThiefSubject(); // 添加警察 subject.attach(observer1); subject.attach(observer2); subject.attach(observer3); // 罪犯状态改变 subject.onClick(\"正在抢劫珠宝\"); // 移除警察 subject.dettch(observer3); // 罪犯状态改变 subject.onClick(\"飞走了\"); &#125;&#125; 运行Java工程 总结 这个例子相信不会很难懂，主要想描述的是，一个罪犯(被观察者)可以被多个警察(观察者)监视，而每当一个警察(观察者)监视罪犯(被观察者)的时候，需要去将这个警察(观察者)添加到团队(集合)中，当某个警察(观察者)牺牲了，就需要将他(从集合中)移除，而当罪犯(被观察者)状态发生改变时，团队(集合)中所有警察(观察者)都能得到通知。所以总结起来就是：观察者将自己注册到被观察者的容器中时，被观察者不应该过问观察者的具体类型，而是应该使用观察者的接口。这样的优点是：假定程序中还有别的观察者，那么只要这个观察者也是相同的接口实现即可。一个被观察者可以对应多个观察者，当被观察者发生变化的时候，他可以将消息一一通知给所有的观察者。基于接口，而不是具体的实现——这一点为程序提供了更大的灵活性。当然这只是一个模拟观察者模式的例子，而Java同样提供了观察者Observer类供我们使用，这里就不多做介绍了。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"https://izdo.github.io/tags/设计模式/"}]},{"title":"Retrofit框架","slug":"Retrofit框架","date":"2017-05-20T07:44:35.923Z","updated":"2017-05-20T07:44:18.379Z","comments":true,"path":"2017/05/20/Retrofit框架/","link":"","permalink":"https://izdo.github.io/2017/05/20/Retrofit框架/","excerpt":"","text":"Retrofit框架Retrofit框架介绍 Retrofit框架是一个针对Android和Java类型安全的http客户端，它可以将HTTP API转化成Java接口。 以下摘自[简书]部分内容(http://www.jianshu.com/p/1ef0ba0bccc6)： 通俗理解Retrofit 我们来通俗的理解Retrofit，它是一个可以用于Android和java的网络库，使用它可以简化我们网络操作的工作，提高效率和正确率。 我们需要牢牢的记住：所有的第三方库能实现的功能，我们使用原生的API只要花时间和精力也能实现，但是可能会出现很多的bug而且会花费较多的时间和精力，而且性能也不一定很好，第三方的库会帮我们封装底层的一些代码，避免我们做重复多余易出错的事情，让我们专注于业务逻辑，所以学习任何一个第三方库都将是简单的，我们不应心生畏惧。 那么，同样的道理，Retrofit是Square公司开源的一个高质量高效率的http库，它将我们自己开发的底层的代码和细节都封装了起来。在没有Retrofit，okHttp等库的时候，我们可能要自己去写put，get,post,delete请求。但有了这些库之后对于这些请求我们就只需要一行代码或者是一个注解。 所有的网络通信，其核心任务只有一个就是：Client端与Server端进行数据的交互和操作。所以Retrofit就将底层的代码都封装起来只是暴露出了我们业务中的数据模型和操作方法。这样理解之后，我们学习Retrofit就简单明了很多了。应该从以下这几点开始学习： 如何传入我们业务需求的URL以及变量参数 如何将我们业务中从服务器获取的Jason数据封装为与Retrofit向对应的类或者接口 如何使用Retrofit进行get,post,delete,put等操作。 还有就是如何在我们项目中配置Retrofit Retrofit官网 Retrofit github官网 Retrofit简单例子新建工程RetrofitDemoactivity_main布局文件1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"com.izdo.retrofitdemo.MainActivity\"&gt; &lt;Button android:id=\"@+id/get\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" android:layout_alignParentTop=\"true\" android:onClick=\"requestAPI\" android:text=\"点我\"/&gt;&lt;/RelativeLayout&gt; 布局比较简单，只有一个按钮。要使用Retrofit需要在build.gradle中配置：&gt; * compile ‘com.squareup.retrofit2:retrofit:2.3.0’接下来我们根据官网说明的用法来做一个例子使用Retrofit。 定义接口Api123456789101112131415package com.izdo.retrofitdemo;import okhttp3.ResponseBody;import retrofit2.Call;import retrofit2.http.GET;/** * Created by iZdo on 2017/5/15. */public interface Api &#123; @GET(\"myserver\") Call&lt;ResponseBody&gt; getUserInfo();&#125; 我们仿照官方文档说明，定义接口Api，接下来同样仿照官方文档，调用这个接口。 MainActivity1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.izdo.retrofitdemo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Toast;import java.io.IOException;import okhttp3.ResponseBody;import retrofit2.Call;import retrofit2.Callback;import retrofit2.Response;import retrofit2.Retrofit;public class MainActivity extends AppCompatActivity &#123; private Api api; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"http://192.168.1.53:8080/\") .build(); api = retrofit.create(Api.class); &#125; public void requestAPI(View view) &#123; Call&lt;ResponseBody&gt; call = api.getUserInfo(); call.enqueue(new Callback&lt;ResponseBody&gt;() &#123; @Override public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) &#123; try &#123; String result = response.body().string(); Toast.makeText(MainActivity.this, result, Toast.LENGTH_SHORT).show(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) &#123; &#125; &#125;); &#125;&#125; 首先需要在onCreate()方法中实例化Retrofit，然后调用retrofit的create()方法将其赋给Api接口实例(注：这里并非把Api实例化，而是通过一种动态代理的方式赋给api)，接着在按钮点击事件中处理请求，这部分与okhttp的用法类似。 效果图： 可以看到，服务器返回的JSON格式的数据已经通过Toast显示出来。 将返回的数据转化为JavaBean扩展：GsonFormat插件 这是AndroidStudio中的一个能够快速将JSON格式的数据转化为JavaBean的插件，具体使用方法可以点击后方链接：GsonFormat插件 通过使用GsonFormat实现JavaBean Info123456789101112131415161718192021222324252627282930313233343536373839404142package com.izdo.retrofitdemo;/** * Created by iZdo on 2017/5/15. */public class Info &#123; /** * id : 1 * name : 香菜 * img : https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1035293498,3690663067&amp;fm=23&amp;gp=0.jpg */ private String id; private String name; private String img; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getImg() &#123; return img; &#125; public void setImg(String img) &#123; this.img = img; &#125;&#125; 修改Api接口Call泛型类为Info12@GET(\"myserver\")Call&lt;Info&gt; getUserInfo(); 修改MAinActivity的RequestAPI()方法123456789101112131415public void requestAPI(View view) &#123; api.getUserInfo().enqueue(new Callback&lt;Info&gt;() &#123; @Override public void onResponse(Call&lt;Info&gt; call, Response&lt;Info&gt; response) &#123; Toast.makeText(MainActivity.this, \"username=\" + response.body().getName(), Toast.LENGTH_SHORT).show(); Toast.makeText(MainActivity.this, \"id=\" + response.body().getId(), Toast.LENGTH_SHORT).show(); &#125; @Override public void onFailure(Call&lt;Info&gt; call, Throwable t) &#123; &#125; &#125;); &#125; 修改之后部署，这时候点击按钮会发现程序崩溃了。 通过查看官方说明我们发现： 这段文字的意思大概是：默认情况下，Retrofit只能反序列化Http体到OkHttp的ResponseBody类型，它也只能接收ResponseBody类型，而转换器可以使它支持其他类型。官方文档中也提供了六种类型的转换器供我们使用。所以我们还需要配置一个转换器，这里我们就使用Gson转换器。 配置转换器 在build.gradle中加入compile ‘com.squareup.retrofit2:converter-gson:2.3.0’。然后将MainActivity的onCreate()方法中初始化Retrofit的代码Retrofit retrofit = new Retrofit.Builder().baseUrl(“http://192.168.1.53:8080/&quot;).build(); 修改为Retrofit retrofit = new Retrofit.Builder().baseUrl(“http://192.168.1.53:8080/&quot;).addConverterFactory(GsonConverterFactory.create()).build();再次部署项目。 效果图： 可以看到，这次成功地取到了name和id。 GET请求 在官方文档中，我们可以看到，官方提供的GET请求的方式不止一种，接下来就来介绍官方文档中提供的各种GET请求。 普通方式1@GET(\"users/list\") 这种方式是最简单的GET请求的方式，而上文用到的就是这种，这里不详细讲解。 @Query1@GET(\"users/list?sort=desc\") 这种方式是直接在URL中拼接参数，但是这样的话只能在拼接的时候将参数写死了，那么要如何动态地拼接参数呢？官方提供了@Query用于动态拼接参数，接下来看实际的例子： 修改Api中的代码12345public interface Api &#123; @GET(\"myserver\") Call&lt;Info&gt; getUserInfo(@Query(\"id\") int id);&#125; 这里通过@Query对id参数进行赋值，只要在调用时传入相应类型的数据即可，接下来修改调用时的代码： 修改MAinActivity中的代码12345678910111213141516public void requestAPI(View view) &#123; api.getUserInfo(2).enqueue(new Callback&lt;Info&gt;() &#123; @Override public void onResponse(Call&lt;Info&gt; call, Response&lt;Info&gt; response) &#123; // Toast.makeText(MainActivity.this, \"username=\" + response.body().getName(), Toast.LENGTH_SHORT).show(); Toast.makeText(MainActivity.this, \"id=\" + response.body().getId(), Toast.LENGTH_SHORT).show(); &#125; @Override public void onFailure(Call&lt;Info&gt; call, Throwable t) &#123; Toast.makeText(MainActivity.this, t.getMessage(), Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; 这里传入数字2作为参数，同时在Response()中通过Toast显示出id值。 效果图 @Path修改Api中的代码1234567public interface Api &#123; ... @GET(\"myserver/&#123;id&#125;\") Call&lt;Info&gt; getUserInfoWithPath(@Path(\"id\") int id);&#125; 这里主要新增了一个getUserInfoWithPath()方法，在@GET中增加了一个{id}，表明想要传入的参数为id，而方法参数中的@Query也改为了@Path，注意{}中的参数和@Path()中的参数需要一致，否则会出现错误。 修改MAinActivity中的代码123api.getUserInfoWithPath(3).enqueue(new Callback&lt;Info&gt;() &#123; ...&#125; 在调用时只需将getUserInfo()改为getUserInfoWithPath()即可。效果图与使用@Query时是一致的，这里就不贴效果图了。 @QueryMap 这种方式的参数形式是一个Map集合，这里同样简单地介绍一下。 修改Api中的代码1234567public interface Api &#123; ... @GET(\"myserver/&#123;id&#125;\") Call&lt;Info&gt; getUserInfoWithMap(@QueryMap Map&lt;String,String&gt; params);&#125; 修改MAinActivity中的代码12345678Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(\"id\",\"3\"); map.put(\"name\",\"aaa\"); api.getUserInfoWithMap(map).enqueue(new Callback&lt;Info&gt;() &#123; ... &#125; 通过上面的介绍，相信这里已经很好理解了，所以不多做解释，效果同样与之前没什么差异。以上就是Retrofit的多种方式的GET请求。 POST请求 POST请求也不难理解，下面直接上代码。 @Body在Api中新增saveInfo()方法1234567public interface Api &#123; ... @POST(\"myserver\") Call&lt;BaseResult&gt; saveInfo(@Body Info info);&#125; 这里需要一个BaseResult类 新建BaseResult类 123456789101112131415161718192021222324252627package com.izdo.retrofitdemo;/** * Created by iZdo on 2017/5/18. */public class BaseResult &#123; private int succerss; private String message; public int getSuccerss() &#123; return succerss; &#125; public void setSuccerss(int succerss) &#123; this.succerss = succerss; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 在Info中新增构造器12345678910111213141516171819202122232425262728public class Info &#123; /** * id : 1 * name : 香菜 * img : https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1035293498,3690663067&amp;fm=23&amp;gp=0.jpg */ private String id; private String name; private String img; public Info(String id, String name, String img) &#123; this.id = id; this.name = name; this.img = img; &#125; public Info(String id, String name) &#123; this.id = id; this.name = name; &#125; public Info() &#123; &#125; ...&#125; 修改MainActivity的requertAPI()方法123456789101112131415161718public void requestAPI(View view) &#123; api.saveInfo(new Info(\"1\", \"admin\")).enqueue(new Callback&lt;BaseResult&gt;() &#123; @Override public void onResponse(Call&lt;BaseResult&gt; call, Response&lt;BaseResult&gt; response) &#123; Toast.makeText(MainActivity.this, response.body().getMessage(), Toast.LENGTH_SHORT).show(); //Toast.makeText(MainActivity.this, response.body()+\"\", Toast.LENGTH_SHORT).show(); // Toast.makeText(MainActivity.this, \"username=\" + response.body().getName(), Toast.LENGTH_SHORT).show(); // Toast.makeText(MainActivity.this, \"id=\" + response.body().getId(), Toast.LENGTH_SHORT).show(); &#125; @Override public void onFailure(Call&lt;BaseResult&gt; call, Throwable t) &#123; Toast.makeText(MainActivity.this, t.getMessage(), Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; 服务器端也进行相应的改动。注意:这里需要解释一下，当请求发送成功时，服务器端会返回一串JSON格式的数据给客户端，JSON格式的内容为一个success(1)和一个message(“保存用户成功”),这里Toast打印出的是message所携带的内容。 效果图 @Field 这种方式区别与上种方式在于这种事通过Form表单形式提交的。 修改MainActivity的requertAPI()方法12345678public interface Api &#123; ... @FormUrlEncoded @POST(\"myserver\") Call&lt;BaseResult&gt; editInfo(@Field(\"id\") int id, @Field(\"username\")String username);&#125; 修改MainActivity的requertAPI()方法123456789101112131415public void requestAPI(View view) &#123; api.editInfo(1,\"new_Info\").enqueue(new Callback&lt;BaseResult&gt;() &#123; @Override public void onResponse(Call&lt;BaseResult&gt; call, Response&lt;BaseResult&gt; response) &#123; Toast.makeText(MainActivity.this, response.body().getMessage(), Toast.LENGTH_SHORT).show(); &#125; @Override public void onFailure(Call&lt;BaseResult&gt; call, Throwable t) &#123; Toast.makeText(MainActivity.this, t.getMessage(), Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; 同样对服务器端做出相应的改动。 效果图 当然官方提供的方式还不止这几种，这里就不一一介绍了。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"}]},{"title":"OKHttp3框架(下)","slug":"OKHttp3框架(下)","date":"2017-05-14T13:36:09.436Z","updated":"2017-05-13T14:35:35.551Z","comments":true,"path":"2017/05/14/OKHttp3框架(下)/","link":"","permalink":"https://izdo.github.io/2017/05/14/OKHttp3框架(下)/","excerpt":"","text":"OKHttp3框架(下)OKHttp简单封装 为什么要封装OKHttp呢？封装的好处是当我们需要网络请求时，只需要去调用一个方法，就能实现一大串代码才能实现的功能，另外对维护也非常简单和方便。接下来进行简单的封装一个工具类。这里进行封装的主要目的是让我们能使用自己封装好的工具类进行网络请求时，能够更快更便捷地对某个地址进行请求，减少代码量。 封装目标： GET POST-FORM POST-JSON 自动转换JSON为JavaBean GET新建SimpleHttpClient类12345678910111213141516171819202122package com.izdo.okhttpdemo.okhttp;/** * Created by iZdo on 2017/5/12. */public class SimpleHttpClient &#123; private SimpleHttpClient() &#123; &#125; public Builder newBuilder() &#123; return new Builder(); &#125; public static class Builder &#123; public SimpleHttpClient build() &#123; return new SimpleHttpClient(); &#125; &#125;&#125; 首先将构造器私有化，然后创建一个静态内部类Builder，在Builder中顶一个build()方法用于return一个SimpleHttpClient(),然后再创建一个newBuilder()方法用于return一个Builder。这样我们就能简单地初始化SimpleHttpClient了，接下来在LoginActivity中测试： 修改LoginActivity中的代码12345678910@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); ButterKnife.bind(this); httpClient = new OkHttpClient(); SimpleHttpClient client = new SimpleHttpClient.Builder().build(); &#125; 这里我们主要加入了SimpleHttpClient client = new SimpleHttpClient.Builder().build();这样一句话，怎么样，是不是和我们new一个Request的时候有些相似？接下来再做出一些修改： 修改SimpleHttpClient中的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.izdo.okhttpdemo.okhttp;/** * Created by iZdo on 2017/5/12. */public class SimpleHttpClient &#123; private SimpleHttpClient() &#123; &#125; public static Builder newBuilder() &#123; return new Builder(); &#125; public static class Builder &#123; private String url; private String method; private Builder() &#123; method = \"GET\"; &#125; public SimpleHttpClient build() &#123; return new SimpleHttpClient(); &#125; public Builder url(String url) &#123; this.url = url; return this; &#125; public Builder get() &#123; method = \"GET\"; return this; &#125; /** * Form 表单 * * @return */ public Builder post() &#123; method = \"POST\"; return this; &#125; /** * JSON 参数 * * @return */ public Builder josn() &#123; return this; &#125; &#125;&#125; 这里我们在Builder类中新增了几个参数和方法，并将newBuilder()方法修改为static，相信很容易看懂。接着我们再在LoginActivity中调用： 12345678910@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); ButterKnife.bind(this); httpClient = new OkHttpClient(); SimpleHttpClient.newBuilder().url(\"http://www.baidu.com\").get().build(); &#125; 可以看到，现在发起GET方式的网络请求就只需要这样一句话SimpleHttpClient.newBuilder().url(“http://www.baidu.com&quot;).get().build();，当然这只是模拟，具体功能还没有实现。在使用OKHttp的时候，我们需要调用enqueue()方法，并传入一个Callback参数，这里我们也模仿它写出这样一个方法。 在SimpleHttpClient加入enqueue()方法123public void enqueue(BaseCallback callback)&#123;&#125; 这里我们需要一个callback参数，所以我们自己定义一个参数。 新建BaseCallback接口类1234567891011121314151617package com.izdo.okhttpdemo.okhttp;import android.telecom.Call;import java.io.IOException;/** * Created by iZdo on 2017/5/13. */public interface BaseCallback&lt;T&gt; &#123; public void onSuccess(T T); public void onError(int code); public void onFailure(Call call, IOException e);&#125; 新建User类作为BaseCallback的泛型类12345678910111213141516171819202122232425262728293031323334353637package com.izdo.okhttpdemo.model;import java.io.Serializable;/** * Created by iZdo on 2017/5/13. */public class User implements Serializable&#123; private String username; private String id; private String head_url; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getHead_url() &#123; return head_url; &#125; public void setHead_url(String head_url) &#123; this.head_url = head_url; &#125;&#125; 修改LoginActivity onCreate()方法中调用的代码12345678910111213141516SimpleHttpClient.newBuilder().url(\"http://www.baidu.com\").get().build().enqueue(new BaseCallback&lt;User&gt;() &#123; @Override public void onSuccess(User T) &#123; &#125; @Override public void onError(int code) &#123; &#125; @Override public void onFailure(android.telecom.Call call, IOException e) &#123; &#125; &#125;); 这样发起GET网络请求的封装逻辑基本上已经完成了。 POST FORM POST请求和GET请求最大的区别在与POST请求需要传参： 新建RequestParam类1234567891011121314151617181920212223242526272829303132package com.izdo.okhttpdemo.okhttp;/** * Created by iZdo on 2017/5/13. */public class RequestParam &#123; private String key; private Object obj; public RequestParam(String key, Object obj) &#123; this.key = key; this.obj = obj; &#125; public String getKey() &#123; return key; &#125; public void setKey(String key) &#123; this.key = key; &#125; public Object getObj() &#123; return obj; &#125; public void setObj(Object obj) &#123; this.obj = obj; &#125;&#125; 修改SimpleHttpClient中的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.izdo.okhttpdemo.okhttp;import java.util.ArrayList;import java.util.List;/** * Created by iZdo on 2017/5/12. */public class SimpleHttpClient &#123; private SimpleHttpClient() &#123; &#125; public void enqueue(BaseCallback callback) &#123; &#125; public static Builder newBuilder() &#123; return new Builder(); &#125; public static class Builder &#123; private String url; private String method; // 参数集合 private List&lt;RequestParam&gt; mParams; private Builder() &#123; method = \"GET\"; &#125; public SimpleHttpClient build() &#123; return new SimpleHttpClient(); &#125; public Builder url(String url) &#123; this.url = url; return this; &#125; public Builder get() &#123; method = \"GET\"; return this; &#125; /** * Form 表单 * * @return */ public Builder post() &#123; method = \"POST\"; return this; &#125; /** * JSON 参数 * * @return */ public Builder josn() &#123; return this; &#125; // 添加参数 public Builder addParam(String key, Object value) &#123; if (mParams == null) &#123; mParams = new ArrayList&lt;&gt;(); &#125; mParams.add(new RequestParam(key, value)); return this; &#125; &#125;&#125; 新建BaseResult类接收返回数据123456789101112131415161718192021222324252627package com.izdo.okhttpdemo.model;/** * Created by iZdo on 2017/5/13. */public class BaseResult &#123; private int success; private String message; public int getSuccess() &#123; return success; &#125; public void setSuccess(int success) &#123; this.success = success; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 修改LoginActivity onCreate()方法中调用的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); ButterKnife.bind(this); httpClient = new OkHttpClient(); // SimpleHttpClient.newBuilder().url(\"http://www.baidu.com\").get().build().enqueue(new BaseCallback&lt;User&gt;() &#123; // @Override // public void onSuccess(User T) &#123; // // &#125; // // @Override // public void onError(int code) &#123; // // &#125; // // @Override // public void onFailure(android.telecom.Call call, IOException e) &#123; // // &#125; // &#125;); String url = Config.API.BASE_URL; SimpleHttpClient.newBuilder().url(url).post() .addParam(\"username\", \"admin\") .addParam(\"password\", \"123456\").build() .enqueue(new BaseCallback&lt;BaseResult&gt;() &#123; @Override public void onSuccess(BaseResult baseResult) &#123; if (baseResult.getSuccess() == 1) &#123; &#125; &#125; @Override public void onError(int code) &#123; &#125; @Override public void onFailure(android.telecom.Call call, IOException e) &#123; &#125; &#125;); &#125; 调用也和官方定义的工具类相似，这样POST的FORM表单形式网络请求就定义好了。 POST JSON 在前面我们已经写过了POST的FORM表单形式的网络请求，那么JSON形式的请求也就不难了。只需要在SimpleHttpClient的Builder类中加入一个标识即可：private boolean isJsonParam;，并在json()方法中加入isJsonParam = true;，最后在LoginActivity中将post()改为json()即可。 这样一来，我们封装的大体框架就已经写好了，接下来我们就要开始实现具体的请求逻辑了。 新建OKHttpManager类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package com.izdo.okhttpdemo.okhttp;import android.os.Handler;import com.google.gson.Gson;import java.io.IOException;import java.util.concurrent.TimeUnit;import okhttp3.Call;import okhttp3.Callback;import okhttp3.OkHttpClient;import okhttp3.Response;/** * Created by iZdo on 2017/5/13. */public class OKHttpManager &#123; private static OKHttpManager mInstance; private OkHttpClient mOkHttpClient; private Handler mHandler; private Gson mGson; private OKHttpManager() &#123; initOKHttp(); mHandler = new Handler(); mGson = new Gson(); &#125; public static synchronized OKHttpManager getmInstance() &#123; if (mInstance == null) mInstance = new OKHttpManager(); return mInstance; &#125; // 初始化OKHttp private void initOKHttp() &#123; mOkHttpClient = new OkHttpClient().newBuilder() .readTimeout(30000, TimeUnit.SECONDS) .connectTimeout(30000, TimeUnit.SECONDS).build(); &#125; public void request(SimpleHttpClient client, final BaseCallback callback) &#123; if (callback == null) &#123; throw new NullPointerException(\"callback is null\"); &#125; mOkHttpClient.newCall(client.buildRequest()).enqueue((new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; sendOnFailureMessage(callback, call, e); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; if (response.isSuccessful()) &#123; String result = response.body().string(); if (callback.mType == null || callback.mType == String.class) &#123; sendonSuccessMessage(callback, result); &#125; else &#123; sendonSuccessMessage(callback, mGson.fromJson(result, callback.mType)); &#125; if (response.body() != null) &#123; response.body().close(); &#125; &#125; else &#123; sendOnErrorMessage(callback, response.code()); &#125; &#125; &#125;)); &#125; private void sendOnFailureMessage(final BaseCallback callback, final Call call, final IOException e) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; callback.onFailure(call, e); &#125; &#125;); &#125; private void sendOnErrorMessage(final BaseCallback callback, final int code) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; callback.onError(code); &#125; &#125;); &#125; private void sendonSuccessMessage(final BaseCallback callback, final Object object) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; callback.onSuccess(object); &#125; &#125;); &#125;&#125; 修改BaseCallback接口为抽象类1234567891011121314151617181920212223242526272829303132333435363738394041package com.izdo.okhttpdemo.okhttp;import com.google.gson.internal.$Gson$Types;import java.io.IOException;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import okhttp3.Call;/** * Created by iZdo on 2017/5/13. */public abstract class BaseCallback&lt;T&gt; &#123; public Type mType; static Type getSuperclassTypeParamter(Class&lt;?&gt; subclass) &#123; Type superclass = subclass.getGenericSuperclass(); if (superclass instanceof Class) &#123; return null; &#125; ParameterizedType parameterized = (ParameterizedType) superclass; return $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]); &#125; public BaseCallback() &#123; mType = getSuperclassTypeParamter(this.getClass()); &#125; public void onSuccess(T T) &#123; &#125; public void onError(int code) &#123; &#125; public void onFailure(Call call, IOException e) &#123; &#125;&#125; 修改SimpleHttpClient中的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159package com.izdo.okhttpdemo.okhttp;import android.net.Uri;import android.util.Log;import org.json.JSONException;import org.json.JSONObject;import java.util.ArrayList;import java.util.List;import okhttp3.FormBody;import okhttp3.MediaType;import okhttp3.Request;import okhttp3.RequestBody;/** * Created by iZdo on 2017/5/12. */public class SimpleHttpClient &#123; private Builder mBuilder; private SimpleHttpClient(Builder builder) &#123; mBuilder = builder; &#125; public Request buildRequest() &#123; Request request = null; Request.Builder builder = new Request.Builder(); if (mBuilder.method == \"GET\") &#123; builder.url(buildGetRequestParam()); builder.get(); &#125; else if (mBuilder.method == \"POST\") &#123; try &#123; builder.post(buildRequestBody()); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; builder.url(mBuilder.url); &#125; return builder.build(); &#125; private String buildGetRequestParam() &#123; if (mBuilder.mParams.size() &lt;= 0) return this.mBuilder.url; Uri.Builder builder = Uri.parse(mBuilder.url).buildUpon(); for (RequestParam p : mBuilder.mParams) &#123; builder.appendQueryParameter(p.getKey(), p.getObj() == null ? \"\" : p.getObj().toString()); &#125; String url = builder.build().toString(); return url; &#125; private RequestBody buildRequestBody() throws JSONException &#123; if (mBuilder.isJsonParam) &#123; JSONObject jsonObj = new JSONObject(); for (RequestParam p : mBuilder.mParams) &#123; jsonObj.put(p.getKey(), p.getObj()); &#125; String json = jsonObj.toString(); Log.d(\"SimpleHttpClient\", \"request json =\" + json); return RequestBody.create(MediaType.parse(\"application/json; charset=utf-8\"), json); &#125; FormBody.Builder builder = new FormBody.Builder(); for (RequestParam p : mBuilder.mParams) &#123; builder.add(p.getKey(), p.getObj() == null ? \"\" : p.getObj().toString()); &#125; return builder.build(); &#125; public void enqueue(BaseCallback callback) &#123; OKHttpManager.getmInstance().request(this, callback); &#125; public static Builder newBuilder() &#123; return new Builder(); &#125; public static class Builder &#123; private String url; private String method; private boolean isJsonParam; // 参数集合 private List&lt;RequestParam&gt; mParams; private Builder() &#123; method = \"GET\"; &#125; public SimpleHttpClient build() &#123; return new SimpleHttpClient(this); &#125; public Builder url(String url) &#123; this.url = url; return this; &#125; public Builder get() &#123; method = \"GET\"; return this; &#125; /** * Form 表单 * * @return */ public Builder post() &#123; method = \"POST\"; return this; &#125; /** * JSON 参数 * * @return */ public Builder json() &#123; isJsonParam = true; return this; &#125; // 添加参数 public Builder addParam(String key, Object value) &#123; if (mParams == null) &#123; mParams = new ArrayList&lt;&gt;(); &#125; mParams.add(new RequestParam(key, value)); return this; &#125; &#125;&#125; 这样OKHttp的封装就完成了。接下来在LoginActivity中调用这个封装完的工具类 修改LoginActivity的loginWithJSON()方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private void loginWithJSON(String username, String password) &#123; String url = Config.API.BASE_URL; SimpleHttpClient.newBuilder().addParam(\"username\", username) .addParam(\"password\", password) .json().url(url) .build().enqueue(new BaseCallback&lt;BaseResult&gt;() &#123; @Override public void onSuccess(BaseResult baseResult) &#123; Toast.makeText(LoginActivity.this, baseResult.getMessage(), Toast.LENGTH_SHORT).show(); &#125; &#125;); /*JSONObject jsonObject = new JSONObject(); try &#123; jsonObject.put(\"username\", username); jsonObject.put(\"password\", password); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; String jsonParams = jsonObject.toString(); RequestBody body = RequestBody.create(MediaType.parse(\"application/json;charset=utf-8\"), jsonParams); Request request = new Request.Builder() .url(url) .post(body) .build(); httpClient.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d(\"LoginActivity\", \"请求服务器出错\"); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; if (response.isSuccessful()) &#123; String json = response.body().string(); try &#123; JSONObject jsonObject = new JSONObject(json); final String message = jsonObject.optString(\"message\"); final int success = jsonObject.optInt(\"success\"); runOnUiThread(new Runnable() &#123; @Override public void run() &#123; if (success == 1) Toast.makeText(LoginActivity.this, \"登录成功\", Toast.LENGTH_SHORT).show(); else Toast.makeText(LoginActivity.this, message, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;);*/ &#125; 修改loginWithForm方法只需将json()改为post()即可。 效果图： 可以明显地看出，原先我们需要一大串代码才能实现的功能现在只需要短短的几行就能够完成了，以后每当我们需要发起网络请求时只需要短短一句链式编程，构建出一个SimpleHttpClient就能实现我们需要的网络请求了。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"}]},{"title":"OKHttp3框架(中)","slug":"OKHttp3框架(中)","date":"2017-05-13T14:47:02.811Z","updated":"2017-05-13T14:35:26.755Z","comments":true,"path":"2017/05/13/OKHttp3框架(中)/","link":"","permalink":"https://izdo.github.io/2017/05/13/OKHttp3框架(中)/","excerpt":"","text":"OKHttp3框架(中)文件 简单方式新建FileDownloadActivity类(同时将默认启动的Activity改为FileDownloadActivity)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151package com.izdo.okhttpdemo;import android.Manifest;import android.content.pm.PackageManager;import android.os.Bundle;import android.os.Environment;import android.os.Handler;import android.os.Message;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.widget.Button;import android.widget.ProgressBar;import android.widget.Toast;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import butterknife.BindView;import butterknife.ButterKnife;import butterknife.OnClick;import okhttp3.Call;import okhttp3.Callback;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;public class FileDownloadActivity extends AppCompatActivity &#123; // 文件地址 public String url = \"http://download.moji001.com/download/MojiWeather-V6.0304.02-release-c8888.apk\"; // 文件名 public String fileName = \"mojiweather.apk\"; @BindView(R.id.btn_download) Button mBtnDownload; @BindView(R.id.progressBar) ProgressBar mProgressBar; private OkHttpClient httpClient; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_file_download); ButterKnife.bind(this); initOKhttp(); &#125; private void initOKhttp() &#123; httpClient = new OkHttpClient(); &#125; @OnClick(R.id.btn_download) public void onViewClicked() &#123; downloadAPK(); &#125; // 文件下载 private void downloadAPK() &#123; Request request = new Request.Builder() .url(url) .build(); httpClient.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d(\"FileDownloadActivity\", \"请求文件出错\"); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; writeFile(response); &#125; &#125;); &#125; Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; if (msg.what == 1) &#123; int progress = msg.arg1; mProgressBar.setProgress(progress); &#125; &#125; &#125;; // 文件读取 private void writeFile(Response response) &#123; InputStream is = null; FileOutputStream fos = null; // 读取返回的数据流 is = response.body().byteStream(); // 获取SD卡路径 String path = Environment.getExternalStorageDirectory().getAbsolutePath(); // 创建新文件 File file = new File(path, fileName); try &#123; fos = new FileOutputStream(file); byte[] bytes = new byte[1024]; int len = 0; // 请求文件的总大小 long totalSize = response.body().contentLength(); // 当前已下载的大小 long sum = 0; // 每次以1kb的大小写入文件 while ((len = is.read(bytes)) != -1) &#123; fos.write(bytes); sum += len; int progress = (int) ((sum * 1.0f / totalSize) * 100); Message msg = mHandler.obtainMessage(1); msg.arg1 = progress; mHandler.sendMessage(msg); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭流 try &#123; if (is != null) is.close(); if (fos != null) fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; activity_file_download.xml123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_file_download\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"com.izdo.okhttpdemo.FileDownloadActivity\"&gt; &lt;Button android:id=\"@+id/btn_download\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"下载文件\"/&gt; &lt;ProgressBar android:id=\"@+id/progressBar\" style=\"@style/Widget.AppCompat.ProgressBar.Horizontal\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"/&gt;&lt;/LinearLayout&gt; 布局文件为一个按钮和一个进度条，不多做解释。使用ButterKnife初始化控件和初始化httpClient等操作也不多做解释。接下来主要讲一下请求逻辑，首先需要准备一个文件提供下载，这里我使用的是墨迹天气apk的下载地址，在按钮的点击事件中调用downloadAPK()方法。而downloadAPK()操作与OKHttp GET请求的基本操作一致，在请求成功时调用writeFile()方法。 writeFile() 这个方法主要用于在请求成功后向本地储存写入文件(这里存入SD卡)。首先需要通过请求返回的response读取数据流，然后在获取SD卡路径后将流以每次1kb的大小写入文件filebi并存储在SD卡中，读写操作为Java的IO流操作，不多做解释。接下来是进度条的更新操作:由于进度条的更新涉及到UI操作，所以需要一个Handler来完成。首先在writeFile()方法外定义一个Handler用于接收Message，在handleMessage()方法中，判断当传递过来的Message的what值为1时就将当前进度设置为传递过来的Message中的参数arg1。在writeFile()方法中定义一个请求文件的总大小totalSize和一个当前已下载的大小sum，在每次写入文件时，计算当前已下载的文件大小，并计算当前进度值，然后通过Handler传递Message，将what参数和arg1参数的值都传递给Handler。关于int progress = (int) ((sum 1.0f / totalSize) 100)：由于sum和totalSize是long类型的数据，需要转化为int类型的进度值，所以这里将sum1.0f，然后再将sum和totalSize相除的结果100，就能得到当前的进度值了。 获取权限 想要访问SD卡和联网等操作，当然少不了权限的获取了，在清单文件中加入以下代码: 12345&lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt;&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/&gt;&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt;&lt;uses-permission android:name=\"android.permission.MOUNT_UNMOUNT_FILESYSTEMS\"/&gt; 虽然我们已经加上了权限，但是这里需要讲一下，在Android6.0或6.0以上的手机对文件读写不仅要在清单文件配置，还需要动态地请求权限。在类中加入以下两个方法： 123456789101112131415161718192021222324252627282930313233343536public static final int EXTERNAL_STORAGE_REQ_CODE = 10; public void requestPermission() &#123; // 判断当前Activity是否已经获得了该权限 if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; // 如果App的权限申请曾经被用户拒绝过，就需要在这里跟用户做出解释 if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)) &#123; Toast.makeText(this, \"please give me the permission\", Toast.LENGTH_SHORT).show(); &#125; else &#123; // 进行权限请求 ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, EXTERNAL_STORAGE_REQ_CODE); &#125; &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode) &#123; case EXTERNAL_STORAGE_REQ_CODE: // 如果请求被拒绝，那么通常grantResults数组为空 if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; // 申请成功，进行相应操作 Toast.makeText(FileDownloadActivity.this, \"已获取权限\", Toast.LENGTH_SHORT).show(); &#125; else &#123; //申请失败，可以继续向用户解释。 &#125; break; default: break; &#125; &#125; 由于这个demo主要是对OKHtpp的使用的介绍，所以对权限请求部分也不多做解释，相关注释已在代码中体现。(在initOKhttp()方法前调用requestPermission()方法) 效果图： 可以看到，进度条的更新实现了，下载也很快就完成了，而在文件管理器中也可以看到已下载的文件。 文件 拦截器方式 简单方式的文件请求严格来说不属于OKHttp的方式，实际上任何一个网络请求都能实现文件下载的操作，接下来就介绍一下OKHttp的拦截器方式请求文件。拦截器(Interceptors)是一种强大的机制，可以监视、重写和重试调用。拦截器分为应用(APPLICATION)拦截器和网络(NETWORK)拦截器，每个拦截器链都有自己的优点。 新建ProgressResponseBody类继承ResponseBody123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.izdo.okhttpdemo.okhttp;import java.io.IOException;import okhttp3.MediaType;import okhttp3.ResponseBody;import okio.Buffer;import okio.BufferedSource;import okio.ForwardingSource;import okio.Okio;import okio.Source;/** * Created by iZdo on 2017/5/12. */public class ProgressResponseBody extends ResponseBody &#123; private ResponseBody mResponseBody; private BufferedSource mBufferedSource; public ProgressResponseBody(ResponseBody responseBody) &#123; mResponseBody = responseBody; &#125; @Override public MediaType contentType() &#123; return mResponseBody.contentType(); &#125; @Override public long contentLength() &#123; return mResponseBody.contentLength(); &#125; @Override public BufferedSource source() &#123; return Okio.buffer(getSource(mResponseBody.source())); &#125; private Source getSource(Source source) &#123; return new ForwardingSource(source()) &#123; @Override public long read(Buffer sink, long byteCount) throws IOException &#123; return super.read(sink, byteCount); &#125; &#125;; &#125;&#125; 由于我们需要实现进度的更新，所以接下来需要作出一些修改： 新建ProgressListener接口类作为监听器123456789101112package com.izdo.okhttpdemo.okhttp;/** * Created by iZdo on 2017/5/12. */public interface ProgressListener &#123; public void onProgress(int progress); public void onDone(long totalSize);&#125; 修改ProgressResponseBody类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.izdo.okhttpdemo.okhttp;import java.io.IOException;import okhttp3.MediaType;import okhttp3.ResponseBody;import okio.Buffer;import okio.BufferedSource;import okio.ForwardingSource;import okio.Okio;import okio.Source;/** * Created by iZdo on 2017/5/12. */public class ProgressResponseBody extends ResponseBody &#123; private ResponseBody mResponseBody; private BufferedSource mBufferedSource; private ProgressListener mProgressListener; public ProgressResponseBody(ResponseBody responseBody, ProgressListener listener) &#123; mResponseBody = responseBody; mProgressListener = listener; &#125; @Override public MediaType contentType() &#123; return mResponseBody.contentType(); &#125; @Override public long contentLength() &#123; return mResponseBody.contentLength(); &#125; @Override public BufferedSource source() &#123; // 当BufferedSource为空时才将Source赋给mBufferedSource if (mBufferedSource == null) mBufferedSource = Okio.buffer(getSource((mResponseBody.source()))); return mBufferedSource; &#125; private Source getSource(Source source) &#123; return new ForwardingSource(source()) &#123; // 文件总大小 long totalSize = 0l; // 当前已下载大小 long sum = 0l; @Override public long read(Buffer sink, long byteCount) throws IOException &#123; if (totalSize == 0) &#123; // 当totalSize为空时，将总大小设置为文件总大小 totalSize = contentLength(); &#125; long len = super.read(sink, byteCount); // 判断是否已读到结尾，如果不是，累加到sum中 sum += (len == -1 ? 0 : len); // 计算当前进度 int progress = (int) ((sum * 1.0f / totalSize) * 100); // 如果读取到结尾，则完成下载，否则继续更新进度 if (len == -1) mProgressListener.onDone(totalSize); else mProgressListener.onProgress(progress); return len; &#125; &#125;; &#125;&#125; 这里只是添加了自定义的监听器和进行更新等简单操作，不多阐述。接下来在FileDownloadActivity类中调用拦截器。 修改FileDownloadActivity中的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226package com.izdo.okhttpdemo;import android.Manifest;import android.content.pm.PackageManager;import android.os.Bundle;import android.os.Environment;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.widget.Button;import android.widget.ProgressBar;import android.widget.Toast;import com.izdo.okhttpdemo.okhttp.ProgressListener;import com.izdo.okhttpdemo.okhttp.ProgressResponseBody;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import butterknife.BindView;import butterknife.ButterKnife;import butterknife.OnClick;import okhttp3.Call;import okhttp3.Callback;import okhttp3.Interceptor;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;public class FileDownloadActivity extends AppCompatActivity &#123; // 文件地址 public String url = \"http://download.moji001.com/download/MojiWeather-V6.0304.02-release-c8888.apk\"; // 文件名 public String fileName = \"mojiweather.apk\"; @BindView(R.id.btn_download) Button mBtnDownload; @BindView(R.id.progressBar) ProgressBar mProgressBar; private OkHttpClient httpClient; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_file_download); ButterKnife.bind(this); requestPermission(); initOKhttp(); &#125; private void initOKhttp() &#123; // httpClient = new OkHttpClient(); // 创建拦截器 httpClient = new OkHttpClient.Builder().addNetworkInterceptor(new Interceptor() &#123; @Override public Response intercept(Chain chain) throws IOException &#123; // 通过chain.proceed()方法获取Response Response response = chain.proceed(chain.request()); return response.newBuilder().body(new ProgressResponseBody(response.body(), new Prg())).build(); &#125; &#125;).build(); &#125; class Prg implements ProgressListener &#123; @Override public void onProgress(final int progress) &#123; //在UI线程更新UI runOnUiThread(new Runnable() &#123; @Override public void run() &#123; mProgressBar.setProgress(progress); &#125; &#125;); &#125; @Override public void onDone(long totalSize) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; Toast.makeText(FileDownloadActivity.this, \"下载完成\", Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; &#125; public static final int EXTERNAL_STORAGE_REQ_CODE = 10; public void requestPermission() &#123; // 判断当前Activity是否已经获得了该权限 if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; // 如果App的权限申请曾经被用户拒绝过，就需要在这里跟用户做出解释 if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)) &#123; Toast.makeText(this, \"please give me the permission\", Toast.LENGTH_SHORT).show(); &#125; else &#123; // 进行权限请求 ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, EXTERNAL_STORAGE_REQ_CODE); &#125; &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode) &#123; case EXTERNAL_STORAGE_REQ_CODE: // 如果请求被拒绝，那么通常grantResults数组为空 if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; // 申请成功，进行相应操作 Toast.makeText(FileDownloadActivity.this, \"已获取权限\", Toast.LENGTH_SHORT).show(); &#125; else &#123; //申请失败，可以继续向用户解释。 &#125; break; default: break; &#125; &#125; @OnClick(R.id.btn_download) public void onViewClicked() &#123; downloadAPK(); &#125; // 文件下载 private void downloadAPK() &#123; Request request = new Request.Builder() .url(url) .build(); httpClient.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d(\"FileDownloadActivity\", \"请求文件出错\"); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; writeFile(response); &#125; &#125;); &#125; // Handler mHandler = new Handler() &#123; // @Override // public void handleMessage(Message msg) &#123; // if (msg.what == 1) &#123; // int progress = msg.arg1; // mProgressBar.setProgress(progress); // &#125; // &#125; // &#125;; // 文件读取 private void writeFile(Response response) &#123; InputStream is = null; FileOutputStream fos = null; // 读取返回的数据流 is = response.body().byteStream(); // 获取SD卡路径 String path = Environment.getExternalStorageDirectory().getAbsolutePath(); // 创建新文件 File file = new File(path, fileName); try &#123; fos = new FileOutputStream(file); byte[] bytes = new byte[1024]; int len = 0; // // 请求文件的总大小 // long totalSize = response.body().contentLength(); // // // 当前已下载的大小 // long sum = 0; // 每次以1kb的大小写入文件 while ((len = is.read(bytes)) != -1) &#123; fos.write(bytes); // sum += len; // // int progress = (int) ((sum * 1.0f / totalSize) * 100); // // Message msg = mHandler.obtainMessage(1); // msg.arg1 = progress; // // mHandler.sendMessage(msg); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭流 try &#123; if (is != null) is.close(); if (fos != null) fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 这里的主要修改部分集中在initOKhttp()的拦截器创建中，逻辑比较简单，接下来还是部署到模拟器上查看是否能够下载文件。 效果图： 完善逻辑 严格上来讲，我们是不建议每次需要网络请求时都去初始化一个OKHttp的，而是只初始化一次。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"}]},{"title":"OKHttp3框架(上)","slug":"OKHttp3框架(上)","date":"2017-05-10T07:48:15.270Z","updated":"2017-05-10T13:23:38.298Z","comments":true,"path":"2017/05/10/OKHttp3框架(上)/","link":"","permalink":"https://izdo.github.io/2017/05/10/OKHttp3框架(上)/","excerpt":"","text":"OKHttp3框架(上)OKHttp3的基本用法导入OKHttp3依赖包 成功添加依赖包后在External Libraries中会出现okhttp、okio两个包 okhttp需要依赖okio包，所有的http请求都是基于流，okio是对流再次封装的工具类。 OKHttp3使用实例创建新工程OKHttpDemoMainActivity12345678910111213141516171819202122232425262728293031public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void getRequest(View v) &#123; OkHttpClient client = new OkHttpClient(); String url = \"http://guolin.tech/api/china/10\"; Request request = new Request.Builder().url(url).build(); client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d(\"MainActivity\", \"失败-----\" + e.getLocalizedMessage()); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; String result = response.body().string(); Log.d(\"MainActivity\", result); &#125; &#125;); &#125;&#125; main_activity.xml12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.izdo.okhttpdemo.MainActivity\"&gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"getRequest\" android:text=\"Get Request\"/&gt;&lt;/RelativeLayout&gt; 首先创建一个OKHttpCliend实例和获取数据的链接url。 接着client调用newCall()需要创建一个request实例，然后调用enqueue()方法并传入一个回调Callback即可。 onFailure()和onResponse()分别对应请求失败和成功时的操作，这里我们失败时打印出错误信息，成功时打印出请求结果。 由于网络请求涉及到网络操作，所以最后记得加上网络权限 1&lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt; 结果如下: 说明我们请求成功。 HTTP协议 HTTP(超文本传输协议)是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。 HTPP协议中通信的两方称作Client和Server(或Host)，Client向Server端经过http协议发送一个Request，Server端收到Request后经过一系列的处理返回Client一个Response，图示如下： URL 无状态的协议 http协议是无状态的： 同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说,它并不知道这两个请求来自同一个客户端。 解决方法：Cookie机制来维护状态 Http消息结构Request(消息结构：三部分) 第一部分:Request line(请求行)，第二部分:http header，第三部分:body 请求行：包括http请求的种类，请求资源的路径，http协议版本 http header：http头部信息 body：发送给服务器的query信息 当使用的是”GET”方法的时候，body是为空的(GET只能读取服务器上的信息，post能写入) Response (消息结构：三部分) 第一部分:Request line，第二部分:Request header，第三部分:body Request line：包括协议版本、状态码、message http header：request头部信息 body：返回的请求资源主题 HTTP协议请求方法 GET 请求获取Request-URL所标识的资源 POST 在Request-URL所标识的资源后附加新的数据 HEAD 请求获取由Request-URL所标识的资源的响应消息报头 PUT 请求服务器存储一个资源，并用Request-URL作为其标识 DELETE 请求服务器删除Request-URL所标识的资源 TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT 保留将来使用 OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求 常用请求方法:GET和POST GET和POST的区别 GET一般用于获取/查询资源信息，而POST一般用于更新资源信息1 GET提交的数据会放在URL之后，以？分割URL和传输数据，参数之间以&amp;相连，如：EditPosts.aspx?name=test1&amp;id=123456。POST方法是把提交的数据放在HTTP包的Body中。2 GET提交的数据大小有限制，因为浏览器对URL的长度有限制，而POST方法提交的数据没有限制。3 GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。4 GET方式提交数据，会带来安全问题，比如一个登陆页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。 状态码 Response消息中的第一行叫做状态行，由HTTP协议版本号，状态码，状态消息三部分组成。 状态码用来告诉HTTP客户端，HTTP服务器是否产生了预期的Response。 HTTP/1.1中定义了5类状态码。 状态码由三位数字组成，第一个数字定义了相应的类别。1xx：指示信息–表示请求已接受，继续处理2xx：成功–表示请求已被成功接收、理解、接收3xx：重定向–要完成请求必须进行更进一步的操作4xx：客户端错误–请求有语法错误或请求无法实现5xx：服务器端错误–服务器未能实现合法的请求 常用状态码200–OK： 客户端请求成功400–Bad Request： 客户端请求有语法错误，不能被服务器所理解401–Unauthorized： 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403–Forbidden： 服务器收到请求，但是拒绝提供服务404–Not Found： 请求资源不存在，eg：输入了错误的URL500–Internal Server Error ：服务器发生不可预期的错误503–Server Unavailable： 服务器当前不能处理客户端的请求，一段时间后可能恢复正常 GET请求 获取信息新建Java类UserInfoActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.izdo.okhttpdemo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.widget.Button;import android.widget.ImageView;import android.widget.TextView;import com.squareup.picasso.Picasso;import org.json.JSONException;import org.json.JSONObject;import java.io.IOException;import butterknife.BindView;import butterknife.ButterKnife;import butterknife.OnClick;import okhttp3.Call;import okhttp3.Callback;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;public class UserInfoActivity extends AppCompatActivity &#123; @BindView(R.id.btn_get) Button mBtnGet; @BindView(R.id.imgview) ImageView mImgview; @BindView(R.id.txt_name) TextView mTxtUsername; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_user_info); ButterKnife.bind(this); &#125; @OnClick(R.id.btn_get) public void onViewClicked() &#123; getUserInfo(); &#125; private void getUserInfo() &#123; // 创建OkHttpClient实例 OkHttpClient client = new OkHttpClient(); // 请求地址 String url = \"http://192.168.1.53:8080/myserver/\"; Request request = new Request.Builder() .get() .url(url) .build(); client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d(\"UserInfoActivity\", \"请求失败\" + e.getLocalizedMessage()); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; //if (response.code() == 200) &#123; // isSuccessful()代替code() if (response.isSuccessful()) &#123; String json = response.body().string(); showInfo(json); &#125; &#125; &#125;); &#125; private void showInfo(final String json) &#123; // 操作UI需在UI线程进行 runOnUiThread(new Runnable() &#123; @Override public void run() &#123; try &#123; JSONObject jsonObject = new JSONObject(json); String id = jsonObject.optString(\"id\"); String name = jsonObject.optString(\"name\"); String img = jsonObject.optString(\"img\"); mTxtUsername.setText(name); /** * Picasso 第三方开源框架 * load() 加载图片地址 * resize() 设置图片大小 * centerCrop() 设置图片圆角 * into() 显示到控件 */ Picasso.with(UserInfoActivity.this).load(img).resize(100, 100).centerCrop().into(mImgview); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; activity_user_info12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_user_info\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:orientation=\"vertical\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"com.izdo.okhttpdemo.UserInfoActivity\"&gt; &lt;Button android:id=\"@+id/btn_get\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"获取信息\"/&gt; &lt;ImageView android:id=\"@+id/imgview\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@mipmap/ic_launcher\"/&gt; &lt;TextView android:id=\"@+id/txt_name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"OKHttpDemo\"/&gt;&lt;/LinearLayout&gt; 首先将所有控件初始化，这里需要用到一个第三方框架ButterKnife以及Zelezny插件，绑定并初始化由ButterKnife完成。在按钮的点击事件中调用getUserInfo()方法。请求地址为一个用JSP模拟的本地服务器地址，主要代码如下: 12response.getWriter() .write(\"&#123;'id':'1','name':'香菜','img':'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1035293498,3690663067&amp;fm=23&amp;gp=0.jpg'&#125;\"); 请求由本地服务器模拟出来的JSON数据，用法基本与上文相同。当请求数据成功时调用showInfo()方法。需要注意的是onResponse()方法是在异步线程中进行的而不是在主线程，所以要操作UI必须在UI线程中进行，所以在showInfo()中需要调用runOnUiThread()方法，在UI线程中解析JSON数据。解析img时，由于获取到的是网络图片地址，所以这里需要用Picasso第三方开源框架加载图片，具体细节在代码中已体现。PS：String id = jsonObject.optString(“id”);中使用optString()而不使用getString()的原因是getString()在当key中的值不存在的时候会出现空指针异常，而optString()则会返回一个空字符串或者返回你指定的默认值。 修改默认启动的Activity1234567&lt;activity android:name=\".UserInfoActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\"/&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 效果图: POST请求 Form表单形式新建Java类LoginActivity(同时将默认启动的Activity改为LoginActivity)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.izdo.okhttpdemo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import org.json.JSONException;import org.json.JSONObject;import java.io.IOException;import butterknife.BindView;import butterknife.ButterKnife;import butterknife.OnClick;import okhttp3.Call;import okhttp3.Callback;import okhttp3.FormBody;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.RequestBody;import okhttp3.Response;public class LoginActivity extends AppCompatActivity &#123; @BindView(R.id.etxt_username) EditText mEtxtUsername; @BindView(R.id.etxt_password) EditText mEtxtPassword; @BindView(R.id.btn_login) Button mBtnLogin; private OkHttpClient httpClient; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); ButterKnife.bind(this); httpClient = new OkHttpClient(); &#125; @OnClick(R.id.btn_login) public void onViewClicked() &#123; String username = mEtxtUsername.getText().toString().trim(); String password = mEtxtPassword.getText().toString().trim(); loginWithForm(username, password); &#125; private void loginWithForm(String username, String password) &#123; String url = Config.API.BASE_URL ; // POST方式提交需要一个RequestBody封装参数 RequestBody body = new FormBody.Builder() .add(\"username\", username) .add(\"password\", password) .build(); final Request request = new Request.Builder() .url(url) .post(body) .build(); httpClient.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d(\"LoginActivity\", \"请求服务器出错\"); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; if (response.isSuccessful()) &#123; String json = response.body().string(); try &#123; JSONObject jsonObject = new JSONObject(json); final String message = jsonObject.optString(\"message\"); final int success = jsonObject.optInt(\"success\"); runOnUiThread(new Runnable() &#123; @Override public void run() &#123; if (success == 1) Toast.makeText(LoginActivity.this, \"登录成功\", Toast.LENGTH_SHORT).show(); else Toast.makeText(LoginActivity.this, message, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); &#125;&#125; activity_login123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_login\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"com.izdo.okhttpdemo.LoginActivity\"&gt; &lt;EditText android:id=\"@+id/etxt_username\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"请输入用户名\"/&gt; &lt;EditText android:id=\"@+id/etxt_password\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"请输入密码\"/&gt; &lt;Button android:id=\"@+id/btn_login\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"立即登录\"/&gt;&lt;/LinearLayout&gt; 本地服务器JSP12345678910111213141516171819&lt;%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"UTF-8\"%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort() + path + \"/\"; /* response.getWriter() .write(\"&#123;'id':'1','name':'香菜','img':'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1035293498,3690663067&amp;fm=23&amp;gp=0.jpg'&#125;\"); */ String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); if (username.equals(\"admin\") &amp;&amp; password.equals(\"123456\")) response.getWriter().write(\"&#123;'success':'1','message':'登录成功'&#125;\"); else response.getWriter().write( \"&#123;'success':'0','message':'用户名或密码错误'&#125;\");%&gt; 首先xml布局为一个基本的登录页面，无需解释。然后用ButterKnife绑定控件，详细操作见上文。在按钮的点击事件中，将用户名和密码框的text传递给loginWithForm()方法，然后在loginWithForm()方法中进行请求。由于本地服务器地址URL是固定的，所以将其封装为一个类Config，方便使用。 新建Config类123456789101112package com.izdo.okhttpdemo;/** * Created by iZdo on 2017/5/9. */public class Config &#123; public static class API&#123; public static final String BASE_URL = \"http://192.168.1.53:8080/myserver/\"; &#125;&#125; loginWithForm()方法 方法中大部分逻辑与OKHttp的基本用法大致相同，唯一不同的是，POST方式提交需要一个RequestBody实例来封装参数(实际上GET方式和POST方式需要一个body，只不过当使用的是GET方式时，body是为空的，这个上文有提及)，而由于RequestBody是一个抽象类，无法实例化，所以只能实例化继承了RequestBody的子类。 而通过了解发现，继承了RequestBody的子类有FormBody和MultitarBody，所以这里使用FormBody来实例化RequestBody。实例化RequestBody后在request创建时加上post(body)，表明请求方式为POST。接下来通过输入username和password发送请求，并解析接收到的message和success数据进行解析。 效果图： POST请求 JSON参数形式修改LoginActivity中的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@OnClick(R.id.btn_login) public void onViewClicked() &#123; String username = mEtxtUsername.getText().toString().trim(); String password = mEtxtPassword.getText().toString().trim(); //loginWithForm(username, password); loginWithJSON(username, password); &#125; private void loginWithJSON(String username, String password) &#123; String url = Config.API.BASE_URL; JSONObject jsonObject = new JSONObject(); try &#123; jsonObject.put(\"username\", username); jsonObject.put(\"password\", password); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; String jsonParams = jsonObject.toString(); RequestBody body = RequestBody.create(MediaType.parse(\"application/json;charset=utf-8\"), jsonParams); Request request = new Request.Builder() .url(url) .post(body) .build(); httpClient.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d(\"LoginActivity\", \"请求服务器出错\"); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; if (response.isSuccessful()) &#123; String json = response.body().string(); try &#123; JSONObject jsonObject = new JSONObject(json); final String message = jsonObject.optString(\"message\"); final int success = jsonObject.optInt(\"success\"); runOnUiThread(new Runnable() &#123; @Override public void run() &#123; if (success == 1) Toast.makeText(LoginActivity.this, \"登录成功\", Toast.LENGTH_SHORT).show(); else Toast.makeText(LoginActivity.this, message, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); &#125; 新增了loginWithJSON()方法，逻辑与loginWithForm()大致相同，并在点击事件改为调用loginWithJSON()方法。loginWithJSON()方法不同的是，发送请求时RequestBody需要调用RequestBody.create()封装JSON数据，并将封装好的jsonParams作为参数传入封装在body中。由于效果与Form方式差不多，这里就不放效果图了。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"}]},{"title":"围住神经猫游戏(二)","slug":"围住神经猫游戏(二)","date":"2017-04-16T06:22:23.456Z","updated":"2017-04-06T12:43:58.165Z","comments":true,"path":"2017/04/16/围住神经猫游戏(二)/","link":"","permalink":"https://izdo.github.io/2017/04/16/围住神经猫游戏(二)/","excerpt":"","text":"使用Android制作围住神经猫游戏(二)获取点击圆点的坐标 要响应屏幕的点击事件，需要实现OnTouchListener接口并重写其onTouch()方法。 1234567public PlayGround(Context context) &#123; ... setOnTouchListener(this); initGame(); &#125; 在PlayGround()中加入setOnTouchListener(this)，然后重写onTouch()方法。 1234567@Overridepublic boolean onTouch(View view, MotionEvent motionEvent) &#123; if(motionEvent.getAction()==MotionEvent.ACTION_UP) //获取当前点击的x,y的坐标值 Toast.makeText(getContext(), motionEvent.getX()+\":\"+motionEvent.getY(), Toast.LENGTH_SHORT).show(); return true;&#125; 通过if语句判断当前动作是否为ACTOIN_UP，然后通过Toast显示当前点击位置的坐标。 部署到模拟器查看效果: 实现点击之后圆点颜色改变效果修改onTouch()中的代码:12345678910111213141516171819202122 @Overridepublic boolean onTouch(View view, MotionEvent motionEvent) &#123; if (motionEvent.getAction() == MotionEvent.ACTION_UP) &#123; //获取当前点击的x,y的坐标值 //Toast.makeText(getContext(), motionEvent.getX()+\":\"+motionEvent.getY(), Toast.LENGTH_SHORT).show(); int x, y; // 获取当前点击的行数 y = (int) (motionEvent.getY() / WIDTH); if (y % 2 == 0) &#123; // 奇数行 x = (int) (motionEvent.getX() / WIDTH); &#125; else &#123; // 偶数行 x = (int) ((motionEvent.getX() - WIDTH / 2) / WIDTH); &#125; // 判断点击位置是否越界 if (x + 1 &gt; COL || y + 1 &gt; ROW) initGame(); else getDot(x, y).setStatus(Dot.STATUS_ON); redraw(); &#125; return true;&#125; 首先获取当前点击的行数，用当前点击的y坐标除以WIDTH即可获得。然后判断当前所点击位置是处于奇数行还是偶数行，因为由于偶数行有偏移所以这两种情况下的列数计算方式是不同的。计算没有偏移的行的列值与获取行数相同，而计算偏移的列值则需要当前点击位置的x坐标减去半个WIDTH后再除以WIDTH获得。 其次，为了避免我们点击到非圆点所在的位置，也就是游戏界面以外的空白区域造成越界，需要进行判断，如果所点位置越界，可以让其reutrn false，但是为了后边测试方便，这里设置成重新初始化游戏，如果所点位置不越界，就将其状态设置为已点击。 最后调用redraw()方法重绘界面。 部署并观看效果： 可以看到，效果跟我们所说的那样。 游戏逻辑——功能函数的实现修改PlayGround中的代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class PlayGround extends SurfaceView implements View.OnTouchListener &#123; ... // 判断当前点是否处于边界 private boolean isAtEdge(Dot d) &#123; if (d.getX() * d.getY() == 0 || d.getX() + 1 == COL || d.getY() + 1 == ROW) return true; return false; &#125; // 获取当前点周围六个点 private Dot getNeighbour(Dot one, int dir) &#123; switch (dir) &#123; // 左 case 1: return getDot(one.getX() - 1, one.getY()); // 左上 case 2: if (one.getY() % 2 == 0) &#123; // 偶数行 return getDot(one.getX() - 1, one.getY() - 1); &#125; else &#123; // 奇数行 return getDot(one.getX(), one.getY() - 1); &#125; // 右上 case 3: if (one.getY() % 2 == 0) &#123; // 偶数行 return getDot(one.getX(), one.getY() - 1); &#125; else &#123; // 奇数行 return getDot(one.getX() + 1, one.getY() - 1); &#125; // 右 case 4: return getDot(one.getX() + 1, one.getY()); // 右下 case 5: if (one.getY() % 2 == 0) &#123; // 偶数行 return getDot(one.getX(), one.getY() + 1); &#125; else &#123; // 奇数行 return getDot(one.getX() + 1, one.getY() + 1); &#125; // 左下 case 6: if (one.getY() % 2 == 0) &#123; // 偶数行 return getDot(one.getX() - 1, one.getY() + 1); &#125; else &#123; // 奇数行 return getDot(one.getX(), one.getY() + 1); &#125; default: break; &#125; return null; &#125; // 获得距离 private int getDistance(Dot one, int dir) &#123; int distance = 0; Dot ori = one, next; while (true) &#123; // 获取周围的点 next = getNeighbour(ori, dir); // 遇到障碍 if (next.getStatus() == Dot.STATUS_ON) return distance * -1; // 无障碍 if (isAtEdge(next)) &#123; distance++; return distance; &#125; distance++; ori = next; &#125; &#125; // 移动猫 private void MoveTo(Dot one) &#123; one.setStatus(Dot.STATUS_IN); getDot(cat.getX(), cat.getY()).setStatus(Dot.STATUS_OFF); cat.setXY(one.getX(), one.getY()); &#125; ... &#125; 这里我们主要加入了四个方法: isAtEdge(),getNeighbour(),getDistance(),MoveTo(),接下来我会一一解释这几个方法的作用。isAtEdge() 这个方法用来判断当前点是否处于边界，d.getX() * d.getY() == 0表示的是x和y中只要其中一个为0，相乘的结果也肯定为0，所以包含了上和左边界的判断，而d.getX() + 1 == COL || d.getY() + 1 == ROW分别是右边界和下边界的判断。getNeighbour() 这个方法用来获取当前点周围的六个点，首先我们需要对周围的点进行分析: 当前点的左右两边的坐标分别是(x-1,y)和(x+1,y)，这是毋庸置疑的，但是在左上，右上，右下，左下这四个点的位置是会因为当前点所在的行是奇数行还是偶数行而不同的。 在此我们规定当前点的左，左上，右上，右，右下，左下方向分别由数字1-6表示(后面都用数字来代表方向)，因此getNeighbour()方法需要两个参数，一个是当前点，另一个是方向值。 接着用一个switch语句进行判断当前需要获取的方向的点，1,4方向是固定的，而2,3,5,6方向需要分奇偶行。 在此之前，我已经将具体的情况通过图片绘制出来，先观察一下下面两幅图: 相信上面两幅图已经很好地诠释了周围的点的坐标值，接下来用one.getY() % 2 == 0判断当前点位于奇数行还是偶数行，然后将相应的点获取并return即可，这里不再多做解释。getDistance() 这个方法用于获取当前点指定方向到边界的距离，首先定义一个距离值distance和两个Dot类型的变量ori、next，ori用来存储当前点(由于当前点在此方法中会不断变化，所以需要用一个新的Dot类型来存储，否则在后面的while循环中会进入死循环)，next用来存储当前点的下一个点。 然后通过一个while循环不断的获取到下一个点，并将distance自增。 而在获取下一个点之前需要进行判断，当下一个点为障碍点时，将返回一个负数的distance，而如果直到边界都一路畅通，没有障碍的话就返回一个正数的distance，通过正负数，当前点在此方向上是否有障碍一目了然，这里可以进行一个测试。修改onTouch()中的方法: 12345678910111213141516171819@Override public boolean onTouch(View view, MotionEvent motionEvent) &#123; if (motionEvent.getAction() == MotionEvent.ACTION_UP) &#123; ... // 判断点击位置是否越界 if (x + 1 &gt; COL || y + 1 &gt; ROW) //return true; //initGame(); for (int i = 1; i &lt; 7; i++) &#123; Log.d(\"-----------\", \"第\" + i + \"个方向的距离为：\" + getDistance(cat, i)); &#125; ... &#125; return true; &#125; 将initGame()方法注释掉，然后用一个for循环打印出当前猫所在点六个方向上的距离值。部署项目并观看效果: 可以看到，当前猫所在点的六个方向上的距离值与打印出来的结果一一对应。 这里只是做一个测试，测试之后记得将越界时的逻辑还原成initGame()。 MoveTo() 这个方法用于将猫移动至指定点。 首选将当前传入的点的status设置为STATUS_IN,即猫在这个点上，然后将当前猫所在点的status设置为STATUS_OFF，最后再将猫设置到新的点上。 这样，游戏逻辑的实现就完成了一半了。 游戏逻辑——基本移动策略修改PlayGround中的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class PlayGround extends SurfaceView implements View.OnTouchListener &#123; ... // 让猫走动 private void move() &#123; // 判断猫是否在场景边界 if (isAtEdge(cat)) &#123; lose(); return; &#125; // 判断猫是否被路障包围 Vector&lt;Dot&gt; avaliable = new Vector&lt;&gt;(); for (int i = 1; i &lt; 7; i++) &#123; Dot n = getNeighbour(cat, i); if (n.getStatus() == Dot.STATUS_OFF) &#123; avaliable.add(n); &#125; &#125; if (avaliable.size() == 0) win(); else MoveTo(avaliable.get(0)); &#125; // 游戏失败 private void lose() &#123; Toast.makeText(getContext(), \"Lose\", Toast.LENGTH_SHORT).show(); &#125; // 游戏成功 private void win() &#123; Toast.makeText(getContext(), \"You Win！\", Toast.LENGTH_SHORT).show(); &#125; ... @Override public boolean onTouch(View view, MotionEvent motionEvent) &#123; if (motionEvent.getAction() == MotionEvent.ACTION_UP) &#123; //获取当前点击的x,y的坐标值 //Toast.makeText(getContext(), motionEvent.getX()+\":\"+motionEvent.getY(), Toast.LENGTH_SHORT).show(); int x, y; // 获取当前点击的行数 y = (int) (motionEvent.getY() / WIDTH); if (y % 2 == 0) &#123; // 奇数行 x = (int) (motionEvent.getX() / WIDTH); &#125; else &#123; // 偶数行 x = (int) ((motionEvent.getX() - WIDTH / 2) / WIDTH); &#125; // 判断点击位置是否越界 if (x + 1 &gt; COL || y + 1 &gt; ROW) //return true; initGame(); else if (getDot(x, y).getStatus() == Dot.STATUS_OFF) &#123; getDot(x, y).setStatus(Dot.STATUS_ON); move(); &#125; redraw(); &#125; return true; &#125;&#125; 在PlayGround中添加move()方法，lose()方法以及win()方法。 lose()和win()比较简单，只是负责显示相应的Toast。 而在onTouch()方法中，将else修改成 else if (getDot(x, y).getStatus() == Dot.STATUS_OFF)是为了防止猫所在的点被点击之后变成STATUS_ON状态，这样修改之后就算点击猫所在的点状态也不会发生改变了，接着再调用move()方法。move() 这个方法用于实现让猫走动的逻辑。 首先我们要考虑两个情况:1.当前猫是否处于场景边界 2.当前猫是否已经被路障包围 因此我们需要作出判断，当猫处于边界的话，就调用lose()方法并return结束游戏;而判断猫是否被包围则复杂一点，首先我们创建一个Vector集合用于存储猫周围的点，表示猫被多少个路障围住，然后用一个for循环判断猫周围六个点的状态，若点的状态为STATUS_OFF，则表示还未被设置成路障，将其放入Vector集合中，判断完所有的点后，若集合中没有任何元素，则表明猫周围没有可走的点，游戏胜利，否则调用MoveTo()让猫移动。 运行程序: 可以看到，猫已经可以走动了，但是我们在MoveTo()的时候，传入的是avaliable.get(0)，这样固定猫的走法的话，玩家在多次游戏之后很容易就能找到猫移动的规律，所以接下来还要对猫移动的算法逻辑进行优化。 优化游戏逻辑修改move()中的代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 让猫走动private void move() &#123; // 判断猫是否在场景边界 if (isAtEdge(cat)) &#123; lose(); return; &#125; // 判断猫是否被路障包围 Vector&lt;Dot&gt; avaliable = new Vector&lt;&gt;(); Vector&lt;Dot&gt; positive = new Vector&lt;&gt;(); HashMap&lt;Dot, Integer&gt; al = new HashMap&lt;&gt;(); for (int i = 1; i &lt; 7; i++) &#123; Dot n = getNeighbour(cat, i); if (n.getStatus() == Dot.STATUS_OFF) &#123; avaliable.add(n); al.put(n, i); if (getDistance(n, i) &gt; 0) &#123; positive.add(n); &#125; &#125; &#125; if (avaliable.size() == 0) win(); else if (avaliable.size() == 1) MoveTo(avaliable.get(0)); else &#123; Dot best = null; if (positive.size() != 0) &#123; // 存在可以直接到达边界的走向 int min = 9999; for (int i = 0; i &lt; positive.size(); i++) &#123; int a = getDistance(positive.get(i), al.get(positive.get(i))); if (a &lt; min) &#123; min = a; best = positive.get(i); &#125; &#125; &#125; else &#123; // 所有方向都存在路障 int max = 0; for (int i = 0; i &lt; avaliable.size(); i++) &#123; int k = getDistance(avaliable.get(i), al.get(avaliable.get(i))); if (k &lt;= max) &#123; max = k; best = avaliable.get(i); &#125; &#125; &#125; MoveTo(best); &#125;&#125; 首先将条件语句进行了修改，当可走点只有一个的时候，就只能选择那个方向，而当可选的点有两个以上的时候，就从没有路障的所有方向中选出离边界最近的路，具体实现逻辑是这样的: 定义一个Vector集合来存储当前点的六个方向中没有路障(即可以直接到达边界)的方向。然后在进行判断周围的点是否为STATUS_OFF之后再进行一次判断，用getDistance()获得的是正数或者负数来判断是否有直接到达边界的方向，若有，则添加进positive集合。 现在实现当可选的点有两个以上时的具体逻辑，首先定义一个Dot类型的best，用来存储最符合当前情况的下一个位置的点，然后进行判断，判断的情况有两种：1.positive里有元素，即当前点存在可以直接到达边界的方向;2.positive里没有元素，即所有方向都存在路障。针对这两种情况进行逻辑的修改。当前点存在可以直接到达边界的方向 在这种情况下，我们就需要找出这些可以直达边界的方向中最短的那个，以达到可以最快到达边界的目的。 首先创建一个int类型的min，用于存放最短路径，初始值尽可能地大，所以设置为9999。 接着通过一个for循环从可以直达边界的所有点的集合(即positive)中找出最短的路径，但是现在却出现了一个问题，我们需要从positive中取出点，一个一个进行判断，但我们并不知道这些点具体是哪个方向的，而且存入positive时我们也没有做相应的记录，所以这时候就需要用到一个HashMap来存储这个点对于源点来说是哪个方向的。 创建HashMap集合al，并在判断点的状态是否为STATUS_OFF之后将这个点以及方向放入al中，即al.put(n, i)。这样我们就可以不管加入positive的点的顺序，轻而易举地知道这些点的方向了。 继续之前的逻辑，定义一个int类型的a用来存储positive中的点的distance长度，而方向直接到al集合中取即可:al.get(avaliable.get(i))。最后进行判断，如果这个点的distance值a比min小，则将min的值修改为a，并且best也修改为这个点。 所有方向都存在路障 通过上面的分析，这种情况下的逻辑就比较容易理解了，基本差不多。 区别就是，当所有方向都存在路障的话，需要找出所有点距离路障的长度中，最大的那个长度值，因为只有往离路障越远的距离的方向走，猫逃出路障的几率才会更大。 这里定义一个int类型的max，用于存放最长路径，而且初始值要尽可能地小，这里就设置为0，而后面的操作基本都差不多。* 需要注意的是，判断条件为k&lt;=max，这是由于我们前文中将存在路障的路径的长度值设置为负数，而负数越大，其绝对值越小，所以判断条件才会是k&lt;=max。 最后无论是哪种情况，都需要将猫移动到best。 部署游戏： 可以明显看出，猫的移动没有之前那样容易找出规律了。 这样游戏基本就完成了，虽然UI并没有真正的围住神经猫游戏美观，但是游戏的具体逻辑算是比较完整了，这仅仅是一个demo，就不追求完美了。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"},{"name":"demo","slug":"demo","permalink":"https://izdo.github.io/tags/demo/"}]},{"title":"围住神经猫游戏(一)","slug":"围住神经猫游戏(一)","date":"2017-04-16T06:18:08.833Z","updated":"2017-04-16T06:18:00.027Z","comments":true,"path":"2017/04/16/围住神经猫游戏(一)/","link":"","permalink":"https://izdo.github.io/2017/04/16/围住神经猫游戏(一)/","excerpt":"","text":"使用Android制作围住神经猫游戏(一)新建工程CatchCrazyCat新建Java类PlayGround作为游戏背景1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.catchcrazycat;import android.content.Context;import android.graphics.Canvas;import android.graphics.Color;import android.view.SurfaceHolder;import android.view.SurfaceView;/** * Created by iZdo on 2017/3/28. */public class PlayGround extends SurfaceView &#123; public PlayGround(Context context) &#123; super(context); &#125; private void redraw() &#123; // 获得Canvas画布实例 Canvas c = getHolder().lockCanvas(); // 使用Canvas绘制背景 c.drawColor(Color.LTGRAY); // 设置背景 getHolder().unlockCanvasAndPost(c); &#125; // 为SurfaceHolder添加回调 SurfaceHolder.Callback callback = new SurfaceHolder.Callback() &#123; @Override public void surfaceCreated(SurfaceHolder surfaceHolder) &#123; // 在surface初始化时调用redraw()方法 redraw(); &#125; @Override public void surfaceChanged(SurfaceHolder surfaceHolder, int i, int i1, int i2) &#123; &#125; @Override public void surfaceDestroyed(SurfaceHolder surfaceHolder) &#123; &#125; &#125;;&#125; PlayGround类需要继承自SurfaceViewSurfaceView介绍 SurfaceView是继承自View用于显示图像的组件的。SurfaceView最大的特点就是它的双缓冲技术，所谓的双缓冲技术就是在它内部有两个线程，比如线程AB，当线程A更新界面时，B进行后台计算操作，当两个线程都完成各自的任务时，它们就会互相交换，A进行后台运算，B进行界面更新，两个线程无限循环交替更新和计算。由于SurfaceView的这种特性可以避免画图任务繁重而造成主线程阻塞，从而提高了程序的反应速度，因此在游戏开发中多用到SurfaceView，例如游戏中的背景、人物、动画等。 上面代码中我们首先在redraw()方法中通过getHolder获取SurfaceHolder，接着调用其lockCanvas()方法获取Canvas实例，然后调用drawColor()绘制背景，再调用unlockCanvasAndPost()方法将绘制的背景设置到SurfaceView界面上。 如果在onCreate()方法执行时，SurfaceHolder还没有完全创建好，这时候就会出现异常，这就需要给SurfaceHolder添加回调了。创建一个新的回调Callback，Callback是一个接口，所以需要重写其三个方法:surfaceCreated()、surfaceChanged()、surfaceDestroyed()，这三个方法分别是在surfaceView的holder被创建、被销毁以及surfaceView的大小发生变化时调用。 这里我们只需要在holder创建时调用redraw()方法即可。 最后再构造函数中添加Callback。 Canvas介绍 通常情况下，要在Android中绘图，需要创建一个集成自View的视图，并且在该类中重写其onDraw(Canvas canvas)方法，然后在Activity中添加该视图，这里需要传入一个Canvas协助绘图。Canvas类代表画布，通过该类提供的方法，可以绘制各种图形。 修改MainActivity1234567891011121314package com.catchcrazycat;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //setContentView(R.layout.activity_main); setContentView(new PlayGround(this)); &#125;&#125; 这里我们将原先加载的布局换成我们定义的PlayGround并传入上下文。 部署到Genymotion观看效果: 创建Java类Dot 这个类用于记录所有点的xy坐标以及它的状态。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.catchcrazycat;/** * Created by iZdo on 2017/3/28. */public class Dot &#123; int x, y; int status; public static final int STATUS_ON = 1; public static final int STATUS_OFF = 2; public static final int STATUS_IN = 3; public Dot(int x, int y) &#123; this.x = x; this.y = y; status = STATUS_OFF; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125; public int getStatus() &#123; return status; &#125; public void setStatus(int status) &#123; this.status = status; &#125; public void setXY(int x, int y) &#123; this.x = x; this.y = y; &#125;&#125; 首先创建int类型的x，y用于存储点的横纵坐标，然后创建一个status用于记录当前点的状态。 然后定义三个常量分别用于表示点的三种状态:点未被点(OFF)，点已被点(ON),猫在点中。 定义一个带参构造器，并将status的状态设置为STATUS_OFF。 除了给x，y，status提供对应的get、set方法之外，还需要提供一个setxy()方法用于设置xy。 修改PlayGround中的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.catchcrazycat;import android.content.Context;import android.graphics.Canvas;import android.graphics.Color;import android.view.SurfaceHolder;import android.view.SurfaceView;/** * Created by iZdo on 2017/3/28. */public class PlayGround extends SurfaceView &#123; private static final int ROW = 10; private static final int COL = 10; // 随机添加的路障数量 private static final int BLOCKS = 15; private Dot matrix[][]; private Dot cat; public PlayGround(Context context) &#123; super(context); getHolder().addCallback(callback); matrix = new Dot[ROW][COL]; // 将二维数组所有数据初始化为Dot类型 for (int i = 0; i &lt; ROW; i++) &#123; for (int j = 0; j &lt; COL; j++) &#123; matrix[i][j] = new Dot(j, i); &#125; &#125; initGame(); &#125; // 获取指定坐标的对应点 private Dot getDot(int x, int y) &#123; return matrix[y][x]; &#125; ... // 初始化所有点 private void initGame() &#123; for (int i = 0; i &lt; ROW; i++) &#123; for (int j = 0; j &lt; COL; j++) &#123; matrix[i][j].setStatus(Dot.STATUS_OFF); &#125; &#125; cat = new Dot(4, 5); getDot(4, 5).setStatus(Dot.STATUS_IN); for (int i = 0; i &lt; BLOCKS; ) &#123; int x = (int) ((Math.random() * 1000) % COL); int y = (int) ((Math.random() * 1000) % ROW); if (getDot(x, y).getStatus() == Dot.STATUS_OFF) &#123; getDot(x, y).setStatus(Dot.STATUS_ON); i++; &#125; &#125; &#125;&#125; 我们先来看看围住神经猫游戏的主界面: 可以看到，游戏主界面的背景是一个多行多列的方阵(行之间有偏移，但后面可以解决),所以我们可以用二维数组来储存。 创建数据类型为Dot的二维数组matrix[][]，在构造方法PlayGround()中用两层for循环将二维数组所有数据初始化。 在初始化点时，可以看到: matrix[i][j] = new Dot(j, i); matrix的第i行第j列的点对应的是Dot(j,i)，这是由于Dot的两个参数x，y分别代表的是横坐标和纵坐标，而横坐标所对应的是列数COL，纵坐标所对应的是行数ROW，是反过来的，不理解的话可以看一下下面的图: 而由于这样i，j和j，i转换会混乱我们的思维，因此我们可以将这种转换封装成getDot()方法，方便我们转换的同时又不会混乱我们。 而最后的initGame()用于初始化所有点的状态，同样是用两层for循环，将所有点初始化为OFF状态，并且将一开始创建的Dot类型的cat猫初始化在(4,5)的位置，并且将其状态设置为IN。 最后我们需要定义一个常量BLOCKS表示随机添加的路障数量，并且在initGame()方法中用for循环随机设置路障位置。 绘制场景 直接上代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class PlayGround extends SurfaceView &#123; private static int WIDTH = 40; ... private void redraw() &#123; // 获得Canvas画布实例 Canvas c = getHolder().lockCanvas(); // 使用Canvas绘制背景 c.drawColor(Color.LTGRAY); // 创建画笔 Paint paint = new Paint(); for (int i = 0; i &lt; ROW; i++) &#123; for (int j = 0; j &lt; COL; j++) &#123; Dot one = getDot(j, i); // 根据点的状态设置画笔的颜色 switch (one.getStatus()) &#123; case Dot.STATUS_OFF: paint.setColor(0xFFEEEEEE); break; case Dot.STATUS_ON: paint.setColor(0xFFFFAA00); break; case Dot.STATUS_IN: paint.setColor(0xFFFF0000); break; default: break; &#125; // 绘制圆点 c.drawOval(new RectF(one.getX() * WIDTH , one.getY() * WIDTH, (one.getX() + 1) * WIDTH , (one.getY() + 1) * WIDTH), paint); &#125; &#125; // 设置背景 getHolder().unlockCanvasAndPost(c); &#125; ...&#125; 首先定义一个Paint，Paint类代表画笔，用来描述图形的颜色和风格，如线宽、颜色、透明度和填充效果等信息。 同样用两层for循环进行绘制，用一个switch语句判断当前点的状态并根据其状态将画笔设置成不同的颜色，然后调用drawOval方法绘制圆点。 部署到Genymotion观看效果: 这样一个10*10的矩阵就绘制出来了，但这明显不是我们想要的效果，缺少了偏移，但比较好实现，修改redraw()中的代码: 12345678910111213141516171819private void redraw() &#123; ... for (int i = 0; i &lt; ROW; i++) &#123; int offset = 0; // 偶数行偏移 if (i % 2 != 0) &#123; offset = WIDTH / 2; &#125; for (int j = 0; j &lt; COL; j++) &#123; ... // 绘制圆点 c.drawOval(new RectF(one.getX() * WIDTH + offset, one.getY() * WIDTH, (one.getX() + 1) * WIDTH + offset, (one.getY() + 1) * WIDTH), paint); &#125; &#125; 添加一个偏移量offset，用if语句判断当偶数行时就将offset设置为WIDTH的一般，并且在绘制圆点时做出相应的修改，这样就完成了偏移。 部署到Genymotion观看效果: 这样错位偏移的效果也完成了，但是我们发现，绘制的圆点似乎不是很圆，边上会有类似锯齿一样的东西，这是由于我们用画笔画出来的图形是位图，是由一格一格像素组成的，所以会有锯齿，这是只要给画笔Paint设置抗锯齿就行了。 1paint.setFlags(Paint.ANTI_ALIAS_FLAG); 观看效果: 现在锯齿已经消失了，但是还有一个问题，我们可以看到，在模拟器上绘制的是一个10*10的矩阵，而由于模拟器分辨率比较高，所以在放满10个圆点之后还有一部分空白。 这也许不会影响什么，但如果在分辨率较小的手机上运行，就会出现超出边界之类的问题了，所以我们需要适配一下屏幕。 要适配屏幕，就需要在Callback中的surfaceChanged()方法中定义了，这个方法我们可能还不知道是用来做什么的，但是我们通过查看AndroidAPI文档可以知道，surfaceChanged()的最后两个参数分别代表的是surfaceView的宽和高。 修改surfaceChanged()方法12345@Overridepublic void surfaceChanged(SurfaceHolder surfaceHolder, int i, int i1, int i2) &#123; WIDTH = i1 / (COL + 1); redraw();&#125; 将WIDTH动态地设置成与surfaceView的宽相关的值，这样就可以适配其他分比率的屏幕了。 ps:为什么要除以(COL+1)而不是COL呢?这是因为我们绘制的场景要有偏移的效果，如果我们只除以COL的话，就只能恰好满足十列的宽度，也就是第一行的宽度，但由于第二行是向右偏倚了一个半径的宽度，所以如果只除以COL的话第二行最后一个圆点的一半会在屏幕之外，这样的用户体验是非常不好的，所以需要多加一个宽度来将偶数行也适配进去。 观看效果: 可以看到，屏幕适配也成功了。 这样一来，场景绘制的工作也完成了。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"},{"name":"demo","slug":"demo","permalink":"https://izdo.github.io/tags/demo/"}]},{"title":"Lambda表达式","slug":"Lambda表达式","date":"2017-04-08T06:07:17.011Z","updated":"2017-04-08T06:10:25.954Z","comments":true,"path":"2017/04/08/Lambda表达式/","link":"","permalink":"https://izdo.github.io/2017/04/08/Lambda表达式/","excerpt":"","text":"最近小编偶然接触到了一个叫做Lambda表达式的函数，于是就去了解了一下，觉得还挺有趣的，今天我们就一起来学习一下这个表达式。那么Lambda表达式是什么呢？首先让我们先看看百度对Lambda表达式的定义：“Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包（注意和数学传统意义上的不同）。（以上摘自百度百科） 是不是有点看不懂？没关系，定义的东西是这样的，接下来我们来看一下一个Java的例子： 首先我们定义一个接口，接口中只有一个待实现的方法sayHello()。 接下来我们定义一个类实现这个接口，这里我们不使用implements Example来实现接口，而是采用匿名内部类的方式来实现Example接口。 这是很常见的类实现接口的一段代码，但是久而久之我们就会发现这段代码存在一个问题：这段代码有好几行，而实际上却只有System.out.println(“Hello”); 这一行在工作，也就是说最终我们是通过这一行代码输出”Hello”，而其他不必要的代码却比在工作的代码多得多。匿名类型最大的问题就在于其冗余的语法，而很多时候我们为了方便又不得不使用匿名类型，那有什么办法可以解决这个问题吗？这就要用到我们前面提到的Lambda表达式了，Lambda表达式是Java8加入的新特性，而实际上Lambda表达式也是一种匿名方法，但是它既没有方法名，也没有访问修饰符和返回值类型，使得代码会更加简洁、易读。 使用Lambda表达式后可以这样写： 怎么样？是不是简洁了许多？不管是代码行数上还是缩进结构上来看，Lambda表达式的写法明显比传统的写法更加精简。 再来看一个例子，我们在Java多线程编程中，按以往的传统我们要开启一个子线程需要这样写： 而使用Lambda表达式后可以这样写： 那么为什么我们可以这样写呢？这是因为Thread类的构造函数接收的参数是一个Runnable接口，并且这个接口中只有一个待实现的方法： 通过查看源码我们发现Runnable接口中确实只有一个待实现的run()方法，也就是说，凡是这种只有一个待实现方法的接口，我们都可以使用Lambda表达式进行简写。 看到这里，也许很多人会说，使用Lambda表达式之后代码也没有减少多少啊。然而这仅仅是我们的一个例子，在实际开发中，代码量往往都是上千行的，而在这上千行代码中，我们是用Lambda表达式使其更简洁，减少代码量，增加可读性，确实是一件好事。你以为这就完了吗？接下来再来看看Java的“类型推断“，果断再看一个例子： 这里我们仍然使用之前的例子，只不过将sayHello()方法改成带两个参数的append(String a,int b)方法，这和之前的例子是基本一致的。 在我们使用Lambda表达式将其简化之后的代码是这样的： 这个我们没什么好说的，我要说的是Java8可以根据上下文自动推断出Lambda表达式中的参数类型，根据这个特性，我们又可以将代码这样写： 去掉参数后我们又能进一步偷懒了呢！这样使得代码简洁之后再简洁。 假设现在有一个方法是接收Example参数的： 那么我们在调用test()方法的时候就可以这样写： 最终打印的结果是：Lambda表达式666 接下来我们说说Android。由于Java8加入了许多新特性，但是由于很多新特性都只支持Android7.0以上的系统，我们显然不可能为了使用这些新特性而放弃兼容众多低版本的Android手机，毕竟现在使用Android7.0的手机还不是很多，大多数人都是使用着7.0以下的系统，7.0的普及还需要一段时间，这就使得其他新特性没有用武之地了，然而Lambda表达式却最低兼容到Android2.3系统，基本上可以覆盖所有的Android手机了。 而Android中除了前文说到的开启子线程可以运用Lambda表达式之外，像设置点击事件这类的功能也是非常适合使用Lambda表达式的。 比如，按照以往的写法，我们要给一个按钮设置点击事件需要这样写： 使用Lambda表达式之后，就可以简化成这样了： 看到这里，是不是觉得已经结束了？然而并没有，Lambda表达式不仅仅在Java中适用，其他一些语言同样支持Lambda表达式。作为一个良心的小编，我特地找了学过Python的不愿意透露性别的男同学简单地了解了一下：Lambda的主体是一个表达式，而不是一个代码块。仅仅能在Lambda表达式中封装有限的逻辑进去。Lambda表达式是起到一个函数速写的作用，允许在代码内嵌入一个函数的定义。不过Lamdba表达式一般不单独使用，而是结合其他的函数一起使用的。比如说这个例子： 使用Lambda表达式后省去了函数的定义，很明显减少了很多代码量。 而在其他语言中，Lambda表达式是ISO C++11标准引入的，C#同样也能使用Lambda表达式，这里就不再阐述，有兴趣的同学可以去了解一下。 至此，Lambda表达式的用法我们都已经知道了，可能有些人会不习惯Lambda表达式的写法，但Java8中新加入这个表达式，并不是说强制你用这种写法，你如果不喜欢这种写法的话，完全可以依照以前的写法，不管怎么说，Java8引入Lambda表达式只是提供了一种简化代码的方式，使用与否在于你个人。","categories":[{"name":"Java","slug":"Java","permalink":"https://izdo.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://izdo.github.io/tags/Java/"}]},{"title":"如何做一个简单的通讯录","slug":"制作通讯录","date":"2017-03-26T14:05:59.635Z","updated":"2017-04-06T12:42:17.986Z","comments":true,"path":"2017/03/26/制作通讯录/","link":"","permalink":"https://izdo.github.io/2017/03/26/制作通讯录/","excerpt":"","text":"如何做一个简单的通讯录获取手机通讯录信息创建新工程GetMyPhoneContacts为了模拟通讯录的效果，现在genymotion模拟器中添加几个联系人 效果图: 创建Java类 GetNumber12345678910111213141516171819202122232425262728293031package com.getmyphonecontacts;import android.content.Context;import android.database.Cursor;import android.provider.ContactsContract.CommonDataKinds.Phone;import android.util.Log;/** * Created by iZdo on 2017/3/26. */public class GetNumber &#123; public static String getNumber(Context context) &#123; // 查询系统通讯录 Cursor cursor = context.getContentResolver().query(Phone.CONTENT_URI, null, null, null, null); // 定义两个字符串用于获取姓名和电话号码 String phoneName; String phoneNumber; // 循环遍历 while (cursor.moveToNext()) &#123; phoneName = cursor.getString(cursor.getColumnIndex(Phone.DISPLAY_NAME)); phoneNumber = cursor.getString(cursor.getColumnIndex(Phone.NUMBER)); Log.d(\"MainActivity\", \"phoneName= \" + phoneName + \",phoneNumber= \" + phoneNumber); &#125; return null; &#125;&#125; 类中只有一个getNumber方法，这个方法用于获取手机通讯录的联系人 这个方法需要一个上下文Context对象作为参数，首先调用上下文的getContentResolver()方法获取一个内容解析者ContentResolver对象并且调用其query()方法查询系统联系人 query()方法第一个参数为一个Uri，这里传入Phone.CONTENT_URI即可，后面的四个参数为查询条件，目前我们不需要筛选联系人，因此全部传入null即可。 query()返回的是一个游标Cursor，用while循环不断遍历Cursor，从Cursor中取出联系人的姓名和号码。 1234567891011121314package com.getmyphonecontacts;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); GetNumber.getNumber(this); &#125;&#125; 在MAinActivity中调用GetNumber的getNumber()方法。 打印日志如下: D/MainActivity: phoneName= zhangsan,phoneNumber= 110 D/MainActivity: phoneName= lisi,phoneNumber= 119 D/MainActivity: phoneName= lin,phoneNumber= 666 可以看到，打印的结果和通讯录中的联系人吻合。 封装数据 现在要做的是将得到的数据封装起来新建Java类ContactInfo 1234567891011121314151617181920212223242526272829303132333435package com.getmyphonecontacts;/** * Created by iZdo on 2017/3/27. */public class ContactInfo &#123; private String name; private String number; // 构造器 public ContactInfo(String name, String number) &#123; this.name = name; this.number = number; &#125; // 对应的getter、setter方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getNumber() &#123; return number; &#125; public void setNumber(String number) &#123; this.number = number; &#125;&#125; 简单的JavaBean类，不多做解释 ps:number使用String类型而不适用int类型是因为号码会有地区之分，所以会出现”+86”的情况，所以不能只用int类型来存储。 修改GetNumber中的代码:12345678910111213141516171819public class GetNumber &#123; public static List&lt;ContactInfo&gt; contactInfoList = new ArrayList&lt;ContactInfo&gt;(); public static String getNumber(Context context) &#123; ... // 循环遍历 while (cursor.moveToNext()) &#123; phoneName = cursor.getString(cursor.getColumnIndex(Phone.DISPLAY_NAME)); phoneNumber = cursor.getString(cursor.getColumnIndex(Phone.NUMBER)); ContactInfo contactInfo = new ContactInfo(phoneName, phoneNumber); contactInfoList.add(contactInfo); Log.d(\"MainActivity\", \"phoneName= \" + phoneName + \",phoneNumber= \" + phoneNumber); &#125; return null; &#125;&#125; GetNumber中新创建了一个数据类型为ContactInfo的List集合，在getNumber()方法的while循环中，每一次循环都将新创建一个ContactInfo对象，并将获取的联系人姓名和号码存入ContactInfo对象中，再将其加入到List集合里，这样就将所有的联系人都存入到了List集合，实现了数据的封装。 ps:显示中的通讯录实际上不止姓名和号码两项，还有地址，电子邮箱等信息，这里为了方便救只使用姓名和号码这两项。 UI适配修改activity_main.xml文件123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.getmyphonecontacts.MainActivity\"&gt; &lt;ListView android:id=\"@+id/lv\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt;&lt;/RelativeLayout&gt; 这里使用ListView用于联系人数据的显示。 自定义适配器新建MyAdapter继承自BaseAdapter1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.getmyphonecontacts;import android.content.Context;import android.view.View;import android.view.ViewGroup;import android.widget.BaseAdapter;import java.util.List;/** * Created by iZdo on 2017/3/27. */public class MyAdapter extends BaseAdapter &#123; private List&lt;ContactInfo&gt; mContactInfoList; private Context mContext; public MyAdapter(List&lt;ContactInfo&gt; contactInfoList, Context context) &#123; mContactInfoList = contactInfoList; mContext = context; &#125; @Override public int getCount() &#123; return mContactInfoList.size(); &#125; @Override public Object getItem(int i) &#123; return mContactInfoList.get(i); &#125; @Override public long getItemId(int i) &#123; return i; &#125; @Override public View getView(int i, View view, ViewGroup viewGroup) &#123; return null; &#125;&#125; 此处需要创建一个数据类型为ContactInfo的List集合和一个上下文对象COntext。 再创建一个构造器，其参数为一个List集合和一个上下文对象。 继承BaseAdapter需要重写四个方法:getCount()、getItem()、getItemId()、getView(): public int getCount():用于得到Item的总数，这里返回我们创建的List集合的长度即可。 public Object getItem(int i):用于根据i得到某个Item的对象，这里需要返回List集合对应位置i的对象。 public long getItemId(int i):用于根据i得到某个Item的id，由于位置i代表的就是其相应Item的id，这里返回i即可。 public View getView(int i, View view, ViewGroup viewGroup):用于得到相应的i对应的Item视图，i当前的位置以及converView复用的View对象，在写这个方法之前，我们需要再新建一个Item布局来展示具体数据。 新建布局文件contact.xml1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\"&gt; &lt;RelativeLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt; &lt;ImageView android:id=\"@+id/iv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@mipmap/ic_launcher\"/&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_alignBottom=\"@id/iv\" android:layout_alignTop=\"@id/iv\" android:layout_toRightOf=\"@id/iv\" android:gravity=\"center_vertical\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"111\" android:textSize=\"15sp\"/&gt; &lt;TextView android:id=\"@+id/number\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"222\" android:textSize=\"10sp\"/&gt; &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt;&lt;/LinearLayout&gt; 效果图如下: 简单的布局，左边是一个ImageView，右边是两个TextView，具体实现如代码所示，此处不再阐述。 修改MyAdapter的代码将getView()方法的内容补充完整12345678910@Overridepublic View getView(int i, View view, ViewGroup viewGroup) &#123; LayoutInflater inflater = LayoutInflater.from(mContext); LinearLayout layout = (LinearLayout) inflater.inflate(R.layout.contact, null); TextView nametv = (TextView) layout.findViewById(R.id.name); TextView numbertv = (TextView) layout.findViewById(R.id.number); nametv.setText(mContactInfoList.get(i).getName()); numbertv.setText(mContactInfoList.get(i).getNumber()); return layout;&#125; 首先创建一个打气筒将刚才创建的Item布局文件转化为一个View，然后初始化两个TextView控件并为其填充相应位置的联系人信息，最后将layout返回。 ps:LayoutInflater.from()方法需要传入一个上下文对象Context，这里就需要用到此前创建的成员变量mContext，而mContext是通过构造器得到的，因此在构造器里设置Context为参数的好处就是当某个活动创建我们自定义的适配器MyAdapter的时候就会同时将其上下文传入，使得活动与适配器联系了起来。 修改MainActivity中的代码123456789101112131415161718192021package com.getmyphonecontacts;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.ListView;public class MainActivity extends AppCompatActivity &#123; private ListView lv; private MyAdapter mAdapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); GetNumber.getNumber(this); lv = (ListView) findViewById(R.id.lv); mAdapter = new MyAdapter(GetNumber.contactInfoList, this); lv.setAdapter(mAdapter); &#125;&#125; 创建一个ListView 创建一个MyAdapter适配器 这里没什么好说的，需要注意的一点是MyAdapter的两个参数分别传入GetNumber中的List集合(静态成员变量，可通过类名直接调用)和this即可。 部署到Genymotion模拟器上观看效果效果如下: 可以看到，联系人的信息都显示在了每一行Item上了。 ps:ImageView上的图片事先并无准备，所以就用了系统自带的ic_launcher图片。 复用历史缓存对象进行优化 ListView其实是一个比较难用的控件，因为它有很多细节可以优化，运行效率就是其中很重要的一点，我们上面写的ListView运行效率是很低的，因为在getView()方法中，每次都将布局重新加载了一遍，当ListView快速滚动的时候，会明显出现卡顿的现象(由于我们的数据量比较少，无法体现出卡顿效果，当数据量比较大的时候能够明显看出)，这时候我们就需要优化ListView的，我们可以发现getView()方法里还有一个view(原先是convertView)是我们没用到的，这是一个缓存对象，就是用于优化ListView的。 修改MyAdapter中的代码:12345678910111213141516171819202122232425262728293031323334public class MyAdapter extends BaseAdapter &#123; ... @Override public View getView(int i, View view, ViewGroup viewGroup) &#123; // LayoutInflater inflater = LayoutInflater.from(mContext); // LinearLayout layout = (LinearLayout) inflater.inflate(R.layout.contact, null); // TextView nametv = (TextView) layout.findViewById(R.id.name); // TextView numbertv = (TextView) layout.findViewById(R.id.number); // nametv.setText(mContactInfoList.get(i).getName()); // numbertv.setText(mContactInfoList.get(i).getNumber()); ViewHolder holder; if (view == null) &#123; view = LayoutInflater.from(mContext).inflate(R.layout.contact, null); holder = new ViewHolder(); holder.nametv = (TextView) view.findViewById(R.id.name); holder.numbertv = (TextView) view.findViewById(R.id.number); holder.nametv.setText(mContactInfoList.get(i).getName()); holder.numbertv.setText(mContactInfoList.get(i).getNumber()); view.setTag(holder); &#125; else &#123; holder = (ViewHolder) view.getTag(); holder.nametv.setText(mContactInfoList.get(i).getName()); holder.numbertv.setText(mContactInfoList.get(i).getNumber()); &#125; return view; &#125; private static class ViewHolder &#123; TextView nametv; TextView numbertv; &#125;&#125; 首先创建了一个内部类ViewHolder，用于对控件的实例进行缓存。 在getView方法中，创建了一个ViewHolder对象，当缓存view为空时，就将联系人的信息封装在ViewHolder里，然后调用setTag()方法将ViewHolder储存在view中，而当缓存不为空时，就调用getTag()方法取出ViewHolder，这样就实现了缓存的复用。 继续改进 通过复用缓存对象我们对ListView进行了优化，而通过观察getView()方法，我们发现不管缓存view为空时，新建ViewHolder去缓存实例还是缓存view不为空时，取出缓存，我们都需要用这个ViewHolder对TextView进行设置文本内容，所以我们又可以进一步优化代码: 123456789101112131415161718192021222324252627public class MyAdapter extends BaseAdapter &#123; ... @Override public View getView(int i, View view, ViewGroup viewGroup) &#123; ... ViewHolder holder; if (view == null) &#123; view = LayoutInflater.from(mContext).inflate(R.layout.contact, null); holder = new ViewHolder(); holder.nametv = (TextView) view.findViewById(R.id.name); holder.numbertv = (TextView) view.findViewById(R.id.number); view.setTag(holder); &#125; else holder = (ViewHolder) view.getTag(); holder.nametv.setText(mContactInfoList.get(i).getName()); holder.numbertv.setText(mContactInfoList.get(i).getNumber()); return view; &#125; ... &#125; 这里我们将holder.nametv.setText(mContactInfoList.get(i).getName())和 holder.numbertv.setText(mContactInfoList.get(i).getNumber())放到判断语句外边，减少了代码的重复(其实就是之前忘了放)。 这样就完成了从手机系统通讯录中取出数据放到我们自己的通讯录上的效果。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"},{"name":"demo","slug":"demo","permalink":"https://izdo.github.io/tags/demo/"}]},{"title":"如何做一个简单的倒计时","slug":"制作倒计时","date":"2017-03-25T08:36:11.032Z","updated":"2017-04-06T12:43:41.272Z","comments":true,"path":"2017/03/25/制作倒计时/","link":"","permalink":"https://izdo.github.io/2017/03/25/制作倒计时/","excerpt":"","text":"如何做一个简单的倒计时1. 创建新工程CountTime2. 布局文件activity_main.xml:123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"com.counttime.MainActivity\"&gt; &lt;EditText android:id=\"@+id/inputtime\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:ems=\"10\"/&gt; &lt;Button android:id=\"@+id/gettime\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"获取倒计时时间\"/&gt; &lt;TextView android:id=\"@+id/time\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; &lt;Button android:id=\"@+id/starttime\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"开始计时\"/&gt; &lt;Button android:id=\"@+id/stoptime\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"停止计时\"/&gt;&lt;/LinearLayout&gt; inputtime用于输入倒计时时间gettime用于显示inputtime输入的时间time用于显示倒计时时间starttime、stoptime分别用于开始和停止倒计时 效果图: 3. MainActivity逻辑:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.counttime;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import java.util.Timer;import java.util.TimerTask;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private EditText inputet; private Button getTime, startTime, stopTime; private TextView time; private int i = 0; private Timer timer = null; private TimerTask task = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //调用初始化控件方法 initView(); &#125; // 初始化控件 private void initView() &#123; inputet = (EditText) findViewById(R.id.inputtime); getTime = (Button) findViewById(R.id.gettime); startTime = (Button) findViewById(R.id.starttime); stopTime = (Button) findViewById(R.id.stoptime); time = (TextView) findViewById(R.id.time); getTime.setOnClickListener(this); startTime.setOnClickListener(this); stopTime.setOnClickListener(this); &#125; // 设置点击事件 @Override public void onClick(View view) &#123; switch (view.getId()) &#123; // 点击gettime按钮获取inputet上的时间值 case R.id.gettime: time.setText(inputet.getText().toString()); i = Integer.parseInt(inputet.getText().toString()); break; case R.id.starttime: startTime(); break; case R.id.stoptime: stopTime(); break; default: break; &#125; &#125; // 使用Handler实现对主线程的更新UI操作 private Handler mHandler = new Handler() &#123; // 调用handleMessage处理消息 public void handleMessage(Message msg) &#123; time.setText(msg.arg1 + \"\"); startTime(); &#125; &#125;; public void startTime() &#123; // 创建计时器和计时任务 timer = new Timer(); task = new TimerTask() &#123; @Override public void run() &#123; i--; Message message = mHandler.obtainMessage(); message.arg1 = i; mHandler.sendMessage(message); &#125; &#125;; timer.schedule(task, 1000); &#125; public void stopTime() &#123; // 取消计时器 timer.cancel(); &#125;&#125; 由于主线程不允许子线程更新UI，因此这里需要用到Handler实现子线程更新UI的操作。 首先创建一个Handler并调用handleMessage方法处理sendMessage传递过来的消息，需要注意的是，TextView的setText方法只能传入String类型的参数，因此不能单单传入msg.arg1，一种简单的处理方式就是在后面加上“”将其转换成字符串:time.setText(msg.arg1 + “”);。 Timer和TimerTask一般是配合使用的(由TimerTask实现任务内容，然后将任务放入计时器Timer),在TimerTask的run()方法里创建一个Message用于向Handler发送消息，这里传入的是i(此前已经将inputet中的数字赋给i)，并调用sendMessage方法将Message发送给Handler，最后调用schedule()方法将TimerTask放入计时器。 timer.schedule(task, 1);第一个参数表示要放入的TimerTask任务，第二个参数是一个毫秒值，表示多少时间之后启动任务，这里放入1000毫秒(1秒)。 最后调用cancel()方法取消任务。 ps:在startTime()中调用sendMessage()方法向Handler发送消息，而在Handler的handleMessage中又调用startTime()方法，这样就形成了sendMessage()-&gt;handleMessage()-&gt;sendMessage()-&gt;handleMessage()-&gt;…的循环。 4. 部署到Genymotion观看效果: 5. 改进 这里存在这一个问题就是计时器读数到0后会变成负数，所以下面需要修改一些代码使计时器归0后停止计时。1234567891011public void startTime() &#123; ... @Override public void run() &#123; i--; if(i&lt;0)&#123; stopTime(); return; &#125; ... &#125; 这里在startTime()方法中的run()方法中加入一个if判断，当i小于0的时候就调用stopTime()方法并且return。(这里判断条件是小于0而不是等于0是逻辑顺序的问题) 为了更好地看到”刹车”效果，将任务间隔设置为1毫秒。 1timer.schedule(task, 1); 效果如下: 对于目前的程序，由于从inputet获取的值为int类型，但当我们输入小数或者字符和其他符号时，程序会崩溃，这里可以使用正则表达式限制输入。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"},{"name":"demo","slug":"demo","permalink":"https://izdo.github.io/tags/demo/"}]}]}