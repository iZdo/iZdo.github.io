{"meta":{"title":"iZdo's Blog","subtitle":"bonbolu","description":null,"author":"iZdo","url":"https://izdo.github.io"},"pages":[{"title":"tags","date":"2017-03-23T05:20:30.000Z","updated":"2017-03-23T05:21:03.041Z","comments":false,"path":"tags/index.html","permalink":"https://izdo.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-03-23T14:14:27.000Z","updated":"2017-03-23T14:14:51.148Z","comments":true,"path":"categories/index.html","permalink":"https://izdo.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"OKHttp3框架(下)","slug":"OKHttp3框架(下)","date":"2017-05-14T13:36:09.436Z","updated":"2017-05-13T14:35:35.551Z","comments":true,"path":"2017/05/14/OKHttp3框架(下)/","link":"","permalink":"https://izdo.github.io/2017/05/14/OKHttp3框架(下)/","excerpt":"","text":"OKHttp3框架(下)OKHttp简单封装 为什么要封装OKHttp呢？封装的好处是当我们需要网络请求时，只需要去调用一个方法，就能实现一大串代码才能实现的功能，另外对维护也非常简单和方便。接下来进行简单的封装一个工具类。这里进行封装的主要目的是让我们能使用自己封装好的工具类进行网络请求时，能够更快更便捷地对某个地址进行请求，减少代码量。 封装目标： GET POST-FORM POST-JSON 自动转换JSON为JavaBean GET新建SimpleHttpClient类12345678910111213141516171819202122package com.izdo.okhttpdemo.okhttp;/** * Created by iZdo on 2017/5/12. */public class SimpleHttpClient &#123; private SimpleHttpClient() &#123; &#125; public Builder newBuilder() &#123; return new Builder(); &#125; public static class Builder &#123; public SimpleHttpClient build() &#123; return new SimpleHttpClient(); &#125; &#125;&#125; 首先将构造器私有化，然后创建一个静态内部类Builder，在Builder中顶一个build()方法用于return一个SimpleHttpClient(),然后再创建一个newBuilder()方法用于return一个Builder。这样我们就能简单地初始化SimpleHttpClient了，接下来在LoginActivity中测试： 修改LoginActivity中的代码12345678910@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); ButterKnife.bind(this); httpClient = new OkHttpClient(); SimpleHttpClient client = new SimpleHttpClient.Builder().build(); &#125; 这里我们主要加入了SimpleHttpClient client = new SimpleHttpClient.Builder().build();这样一句话，怎么样，是不是和我们new一个Request的时候有些相似？接下来再做出一些修改： 修改SimpleHttpClient中的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.izdo.okhttpdemo.okhttp;/** * Created by iZdo on 2017/5/12. */public class SimpleHttpClient &#123; private SimpleHttpClient() &#123; &#125; public static Builder newBuilder() &#123; return new Builder(); &#125; public static class Builder &#123; private String url; private String method; private Builder() &#123; method = \"GET\"; &#125; public SimpleHttpClient build() &#123; return new SimpleHttpClient(); &#125; public Builder url(String url) &#123; this.url = url; return this; &#125; public Builder get() &#123; method = \"GET\"; return this; &#125; /** * Form 表单 * * @return */ public Builder post() &#123; method = \"POST\"; return this; &#125; /** * JSON 参数 * * @return */ public Builder josn() &#123; return this; &#125; &#125;&#125; 这里我们在Builder类中新增了几个参数和方法，并将newBuilder()方法修改为static，相信很容易看懂。接着我们再在LoginActivity中调用： 12345678910@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); ButterKnife.bind(this); httpClient = new OkHttpClient(); SimpleHttpClient.newBuilder().url(\"http://www.baidu.com\").get().build(); &#125; 可以看到，现在发起GET方式的网络请求就只需要这样一句话SimpleHttpClient.newBuilder().url(“http://www.baidu.com&quot;).get().build();，当然这只是模拟，具体功能还没有实现。在使用OKHttp的时候，我们需要调用enqueue()方法，并传入一个Callback参数，这里我们也模仿它写出这样一个方法。 在SimpleHttpClient加入enqueue()方法123public void enqueue(BaseCallback callback)&#123;&#125; 这里我们需要一个callback参数，所以我们自己定义一个参数。 新建BaseCallback接口类1234567891011121314151617package com.izdo.okhttpdemo.okhttp;import android.telecom.Call;import java.io.IOException;/** * Created by iZdo on 2017/5/13. */public interface BaseCallback&lt;T&gt; &#123; public void onSuccess(T T); public void onError(int code); public void onFailure(Call call, IOException e);&#125; 新建User类作为BaseCallback的泛型类12345678910111213141516171819202122232425262728293031323334353637package com.izdo.okhttpdemo.model;import java.io.Serializable;/** * Created by iZdo on 2017/5/13. */public class User implements Serializable&#123; private String username; private String id; private String head_url; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getHead_url() &#123; return head_url; &#125; public void setHead_url(String head_url) &#123; this.head_url = head_url; &#125;&#125; 修改LoginActivity onCreate()方法中调用的代码12345678910111213141516SimpleHttpClient.newBuilder().url(\"http://www.baidu.com\").get().build().enqueue(new BaseCallback&lt;User&gt;() &#123; @Override public void onSuccess(User T) &#123; &#125; @Override public void onError(int code) &#123; &#125; @Override public void onFailure(android.telecom.Call call, IOException e) &#123; &#125; &#125;); 这样发起GET网络请求的封装逻辑基本上已经完成了。 POST FORM POST请求和GET请求最大的区别在与POST请求需要传参： 新建RequestParam类1234567891011121314151617181920212223242526272829303132package com.izdo.okhttpdemo.okhttp;/** * Created by iZdo on 2017/5/13. */public class RequestParam &#123; private String key; private Object obj; public RequestParam(String key, Object obj) &#123; this.key = key; this.obj = obj; &#125; public String getKey() &#123; return key; &#125; public void setKey(String key) &#123; this.key = key; &#125; public Object getObj() &#123; return obj; &#125; public void setObj(Object obj) &#123; this.obj = obj; &#125;&#125; 修改SimpleHttpClient中的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.izdo.okhttpdemo.okhttp;import java.util.ArrayList;import java.util.List;/** * Created by iZdo on 2017/5/12. */public class SimpleHttpClient &#123; private SimpleHttpClient() &#123; &#125; public void enqueue(BaseCallback callback) &#123; &#125; public static Builder newBuilder() &#123; return new Builder(); &#125; public static class Builder &#123; private String url; private String method; // 参数集合 private List&lt;RequestParam&gt; mParams; private Builder() &#123; method = \"GET\"; &#125; public SimpleHttpClient build() &#123; return new SimpleHttpClient(); &#125; public Builder url(String url) &#123; this.url = url; return this; &#125; public Builder get() &#123; method = \"GET\"; return this; &#125; /** * Form 表单 * * @return */ public Builder post() &#123; method = \"POST\"; return this; &#125; /** * JSON 参数 * * @return */ public Builder josn() &#123; return this; &#125; // 添加参数 public Builder addParam(String key, Object value) &#123; if (mParams == null) &#123; mParams = new ArrayList&lt;&gt;(); &#125; mParams.add(new RequestParam(key, value)); return this; &#125; &#125;&#125; 新建BaseResult类接收返回数据123456789101112131415161718192021222324252627package com.izdo.okhttpdemo.model;/** * Created by iZdo on 2017/5/13. */public class BaseResult &#123; private int success; private String message; public int getSuccess() &#123; return success; &#125; public void setSuccess(int success) &#123; this.success = success; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 修改LoginActivity onCreate()方法中调用的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); ButterKnife.bind(this); httpClient = new OkHttpClient(); // SimpleHttpClient.newBuilder().url(\"http://www.baidu.com\").get().build().enqueue(new BaseCallback&lt;User&gt;() &#123; // @Override // public void onSuccess(User T) &#123; // // &#125; // // @Override // public void onError(int code) &#123; // // &#125; // // @Override // public void onFailure(android.telecom.Call call, IOException e) &#123; // // &#125; // &#125;); String url = Config.API.BASE_URL; SimpleHttpClient.newBuilder().url(url).post() .addParam(\"username\", \"admin\") .addParam(\"password\", \"123456\").build() .enqueue(new BaseCallback&lt;BaseResult&gt;() &#123; @Override public void onSuccess(BaseResult baseResult) &#123; if (baseResult.getSuccess() == 1) &#123; &#125; &#125; @Override public void onError(int code) &#123; &#125; @Override public void onFailure(android.telecom.Call call, IOException e) &#123; &#125; &#125;); &#125; 调用也和官方定义的工具类相似，这样POST的FORM表单形式网络请求就定义好了。 POST JSON 在前面我们已经写过了POST的FORM表单形式的网络请求，那么JSON形式的请求也就不难了。只需要在SimpleHttpClient的Builder类中加入一个标识即可：private boolean isJsonParam;，并在json()方法中加入isJsonParam = true;，最后在LoginActivity中将post()改为json()即可。 这样一来，我们封装的大体框架就已经写好了，接下来我们就要开始实现具体的请求逻辑了。 新建OKHttpManager类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package com.izdo.okhttpdemo.okhttp;import android.os.Handler;import com.google.gson.Gson;import java.io.IOException;import java.util.concurrent.TimeUnit;import okhttp3.Call;import okhttp3.Callback;import okhttp3.OkHttpClient;import okhttp3.Response;/** * Created by iZdo on 2017/5/13. */public class OKHttpManager &#123; private static OKHttpManager mInstance; private OkHttpClient mOkHttpClient; private Handler mHandler; private Gson mGson; private OKHttpManager() &#123; initOKHttp(); mHandler = new Handler(); mGson = new Gson(); &#125; public static synchronized OKHttpManager getmInstance() &#123; if (mInstance == null) mInstance = new OKHttpManager(); return mInstance; &#125; // 初始化OKHttp private void initOKHttp() &#123; mOkHttpClient = new OkHttpClient().newBuilder() .readTimeout(30000, TimeUnit.SECONDS) .connectTimeout(30000, TimeUnit.SECONDS).build(); &#125; public void request(SimpleHttpClient client, final BaseCallback callback) &#123; if (callback == null) &#123; throw new NullPointerException(\"callback is null\"); &#125; mOkHttpClient.newCall(client.buildRequest()).enqueue((new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; sendOnFailureMessage(callback, call, e); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; if (response.isSuccessful()) &#123; String result = response.body().string(); if (callback.mType == null || callback.mType == String.class) &#123; sendonSuccessMessage(callback, result); &#125; else &#123; sendonSuccessMessage(callback, mGson.fromJson(result, callback.mType)); &#125; if (response.body() != null) &#123; response.body().close(); &#125; &#125; else &#123; sendOnErrorMessage(callback, response.code()); &#125; &#125; &#125;)); &#125; private void sendOnFailureMessage(final BaseCallback callback, final Call call, final IOException e) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; callback.onFailure(call, e); &#125; &#125;); &#125; private void sendOnErrorMessage(final BaseCallback callback, final int code) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; callback.onError(code); &#125; &#125;); &#125; private void sendonSuccessMessage(final BaseCallback callback, final Object object) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; callback.onSuccess(object); &#125; &#125;); &#125;&#125; 修改BaseCallback接口为抽象类1234567891011121314151617181920212223242526272829303132333435363738394041package com.izdo.okhttpdemo.okhttp;import com.google.gson.internal.$Gson$Types;import java.io.IOException;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import okhttp3.Call;/** * Created by iZdo on 2017/5/13. */public abstract class BaseCallback&lt;T&gt; &#123; public Type mType; static Type getSuperclassTypeParamter(Class&lt;?&gt; subclass) &#123; Type superclass = subclass.getGenericSuperclass(); if (superclass instanceof Class) &#123; return null; &#125; ParameterizedType parameterized = (ParameterizedType) superclass; return $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]); &#125; public BaseCallback() &#123; mType = getSuperclassTypeParamter(this.getClass()); &#125; public void onSuccess(T T) &#123; &#125; public void onError(int code) &#123; &#125; public void onFailure(Call call, IOException e) &#123; &#125;&#125; 修改SimpleHttpClient中的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159package com.izdo.okhttpdemo.okhttp;import android.net.Uri;import android.util.Log;import org.json.JSONException;import org.json.JSONObject;import java.util.ArrayList;import java.util.List;import okhttp3.FormBody;import okhttp3.MediaType;import okhttp3.Request;import okhttp3.RequestBody;/** * Created by iZdo on 2017/5/12. */public class SimpleHttpClient &#123; private Builder mBuilder; private SimpleHttpClient(Builder builder) &#123; mBuilder = builder; &#125; public Request buildRequest() &#123; Request request = null; Request.Builder builder = new Request.Builder(); if (mBuilder.method == \"GET\") &#123; builder.url(buildGetRequestParam()); builder.get(); &#125; else if (mBuilder.method == \"POST\") &#123; try &#123; builder.post(buildRequestBody()); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; builder.url(mBuilder.url); &#125; return builder.build(); &#125; private String buildGetRequestParam() &#123; if (mBuilder.mParams.size() &lt;= 0) return this.mBuilder.url; Uri.Builder builder = Uri.parse(mBuilder.url).buildUpon(); for (RequestParam p : mBuilder.mParams) &#123; builder.appendQueryParameter(p.getKey(), p.getObj() == null ? \"\" : p.getObj().toString()); &#125; String url = builder.build().toString(); return url; &#125; private RequestBody buildRequestBody() throws JSONException &#123; if (mBuilder.isJsonParam) &#123; JSONObject jsonObj = new JSONObject(); for (RequestParam p : mBuilder.mParams) &#123; jsonObj.put(p.getKey(), p.getObj()); &#125; String json = jsonObj.toString(); Log.d(\"SimpleHttpClient\", \"request json =\" + json); return RequestBody.create(MediaType.parse(\"application/json; charset=utf-8\"), json); &#125; FormBody.Builder builder = new FormBody.Builder(); for (RequestParam p : mBuilder.mParams) &#123; builder.add(p.getKey(), p.getObj() == null ? \"\" : p.getObj().toString()); &#125; return builder.build(); &#125; public void enqueue(BaseCallback callback) &#123; OKHttpManager.getmInstance().request(this, callback); &#125; public static Builder newBuilder() &#123; return new Builder(); &#125; public static class Builder &#123; private String url; private String method; private boolean isJsonParam; // 参数集合 private List&lt;RequestParam&gt; mParams; private Builder() &#123; method = \"GET\"; &#125; public SimpleHttpClient build() &#123; return new SimpleHttpClient(this); &#125; public Builder url(String url) &#123; this.url = url; return this; &#125; public Builder get() &#123; method = \"GET\"; return this; &#125; /** * Form 表单 * * @return */ public Builder post() &#123; method = \"POST\"; return this; &#125; /** * JSON 参数 * * @return */ public Builder json() &#123; isJsonParam = true; return this; &#125; // 添加参数 public Builder addParam(String key, Object value) &#123; if (mParams == null) &#123; mParams = new ArrayList&lt;&gt;(); &#125; mParams.add(new RequestParam(key, value)); return this; &#125; &#125;&#125; 这样OKHttp的封装就完成了。接下来在LoginActivity中调用这个封装完的工具类 修改LoginActivity的loginWithJSON()方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private void loginWithJSON(String username, String password) &#123; String url = Config.API.BASE_URL; SimpleHttpClient.newBuilder().addParam(\"username\", username) .addParam(\"password\", password) .json().url(url) .build().enqueue(new BaseCallback&lt;BaseResult&gt;() &#123; @Override public void onSuccess(BaseResult baseResult) &#123; Toast.makeText(LoginActivity.this, baseResult.getMessage(), Toast.LENGTH_SHORT).show(); &#125; &#125;); /*JSONObject jsonObject = new JSONObject(); try &#123; jsonObject.put(\"username\", username); jsonObject.put(\"password\", password); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; String jsonParams = jsonObject.toString(); RequestBody body = RequestBody.create(MediaType.parse(\"application/json;charset=utf-8\"), jsonParams); Request request = new Request.Builder() .url(url) .post(body) .build(); httpClient.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d(\"LoginActivity\", \"请求服务器出错\"); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; if (response.isSuccessful()) &#123; String json = response.body().string(); try &#123; JSONObject jsonObject = new JSONObject(json); final String message = jsonObject.optString(\"message\"); final int success = jsonObject.optInt(\"success\"); runOnUiThread(new Runnable() &#123; @Override public void run() &#123; if (success == 1) Toast.makeText(LoginActivity.this, \"登录成功\", Toast.LENGTH_SHORT).show(); else Toast.makeText(LoginActivity.this, message, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;);*/ &#125; 修改loginWithForm方法只需将json()改为post()即可。 效果图： 可以明显地看出，原先我们需要一大串代码才能实现的功能现在只需要短短的几行就能够完成了，以后每当我们需要发起网络请求时只需要短短一句链式编程，构建出一个SimpleHttpClient就能实现我们需要的网络请求了。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"}]},{"title":"OKHttp3框架(中)","slug":"OKHttp3框架(中)","date":"2017-05-13T14:47:02.810Z","updated":"2017-05-13T14:35:26.754Z","comments":true,"path":"2017/05/13/OKHttp3框架(中)/","link":"","permalink":"https://izdo.github.io/2017/05/13/OKHttp3框架(中)/","excerpt":"","text":"OKHttp3框架(中)文件 简单方式新建FileDownloadActivity类(同时将默认启动的Activity改为FileDownloadActivity)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151package com.izdo.okhttpdemo;import android.Manifest;import android.content.pm.PackageManager;import android.os.Bundle;import android.os.Environment;import android.os.Handler;import android.os.Message;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.widget.Button;import android.widget.ProgressBar;import android.widget.Toast;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import butterknife.BindView;import butterknife.ButterKnife;import butterknife.OnClick;import okhttp3.Call;import okhttp3.Callback;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;public class FileDownloadActivity extends AppCompatActivity &#123; // 文件地址 public String url = \"http://download.moji001.com/download/MojiWeather-V6.0304.02-release-c8888.apk\"; // 文件名 public String fileName = \"mojiweather.apk\"; @BindView(R.id.btn_download) Button mBtnDownload; @BindView(R.id.progressBar) ProgressBar mProgressBar; private OkHttpClient httpClient; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_file_download); ButterKnife.bind(this); initOKhttp(); &#125; private void initOKhttp() &#123; httpClient = new OkHttpClient(); &#125; @OnClick(R.id.btn_download) public void onViewClicked() &#123; downloadAPK(); &#125; // 文件下载 private void downloadAPK() &#123; Request request = new Request.Builder() .url(url) .build(); httpClient.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d(\"FileDownloadActivity\", \"请求文件出错\"); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; writeFile(response); &#125; &#125;); &#125; Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; if (msg.what == 1) &#123; int progress = msg.arg1; mProgressBar.setProgress(progress); &#125; &#125; &#125;; // 文件读取 private void writeFile(Response response) &#123; InputStream is = null; FileOutputStream fos = null; // 读取返回的数据流 is = response.body().byteStream(); // 获取SD卡路径 String path = Environment.getExternalStorageDirectory().getAbsolutePath(); // 创建新文件 File file = new File(path, fileName); try &#123; fos = new FileOutputStream(file); byte[] bytes = new byte[1024]; int len = 0; // 请求文件的总大小 long totalSize = response.body().contentLength(); // 当前已下载的大小 long sum = 0; // 每次以1kb的大小写入文件 while ((len = is.read(bytes)) != -1) &#123; fos.write(bytes); sum += len; int progress = (int) ((sum * 1.0f / totalSize) * 100); Message msg = mHandler.obtainMessage(1); msg.arg1 = progress; mHandler.sendMessage(msg); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭流 try &#123; if (is != null) is.close(); if (fos != null) fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; activity_file_download.xml123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_file_download\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"com.izdo.okhttpdemo.FileDownloadActivity\"&gt; &lt;Button android:id=\"@+id/btn_download\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"下载文件\"/&gt; &lt;ProgressBar android:id=\"@+id/progressBar\" style=\"@style/Widget.AppCompat.ProgressBar.Horizontal\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"/&gt;&lt;/LinearLayout&gt; 布局文件为一个按钮和一个进度条，不多做解释。使用ButterKnife初始化控件和初始化httpClient等操作也不多做解释。接下来主要讲一下请求逻辑，首先需要准备一个文件提供下载，这里我使用的是墨迹天气apk的下载地址，在按钮的点击事件中调用downloadAPK()方法。而downloadAPK()操作与OKHttp GET请求的基本操作一致，在请求成功时调用writeFile()方法。 writeFile() 这个方法主要用于在请求成功后向本地储存写入文件(这里存入SD卡)。首先需要通过请求返回的response读取数据流，然后在获取SD卡路径后将流以每次1kb的大小写入文件filebi并存储在SD卡中，读写操作为Java的IO流操作，不多做解释。接下来是进度条的更新操作:由于进度条的更新涉及到UI操作，所以需要一个Handler来完成。首先在writeFile()方法外定义一个Handler用于接收Message，在handleMessage()方法中，判断当传递过来的Message的what值为1时就将当前进度设置为传递过来的Message中的参数arg1。在writeFile()方法中定义一个请求文件的总大小totalSize和一个当前已下载的大小sum，在每次写入文件时，计算当前已下载的文件大小，并计算当前进度值，然后通过Handler传递Message，将what参数和arg1参数的值都传递给Handler。关于int progress = (int) ((sum 1.0f / totalSize) 100)：由于sum和totalSize是long类型的数据，需要转化为int类型的进度值，所以这里将sum1.0f，然后再将sum和totalSize相除的结果100，就能得到当前的进度值了。 获取权限 想要访问SD卡和联网等操作，当然少不了权限的获取了，在清单文件中加入以下代码: 12345&lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt;&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/&gt;&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt;&lt;uses-permission android:name=\"android.permission.MOUNT_UNMOUNT_FILESYSTEMS\"/&gt; 虽然我们已经加上了权限，但是这里需要讲一下，在Android6.0或6.0以上的手机对文件读写不仅要在清单文件配置，还需要动态地请求权限。在类中加入以下两个方法： 123456789101112131415161718192021222324252627282930313233343536public static final int EXTERNAL_STORAGE_REQ_CODE = 10; public void requestPermission() &#123; // 判断当前Activity是否已经获得了该权限 if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; // 如果App的权限申请曾经被用户拒绝过，就需要在这里跟用户做出解释 if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)) &#123; Toast.makeText(this, \"please give me the permission\", Toast.LENGTH_SHORT).show(); &#125; else &#123; // 进行权限请求 ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, EXTERNAL_STORAGE_REQ_CODE); &#125; &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode) &#123; case EXTERNAL_STORAGE_REQ_CODE: // 如果请求被拒绝，那么通常grantResults数组为空 if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; // 申请成功，进行相应操作 Toast.makeText(FileDownloadActivity.this, \"已获取权限\", Toast.LENGTH_SHORT).show(); &#125; else &#123; //申请失败，可以继续向用户解释。 &#125; break; default: break; &#125; &#125; 由于这个demo主要是对OKHtpp的使用的介绍，所以对权限请求部分也不多做解释，相关注释已在代码中体现。(在initOKhttp()方法前调用requestPermission()方法) 效果图： 可以看到，进度条的更新实现了，下载也很快就完成了，而在文件管理器中也可以看到已下载的文件。 文件 拦截器方式 简单方式的文件请求严格来说不属于OKHttp的方式，实际上任何一个网络请求都能实现文件下载的操作，接下来就介绍一下OKHttp的拦截器方式请求文件。拦截器(Interceptors)是一种强大的机制，可以监视、重写和重试调用。拦截器分为应用(APPLICATION)拦截器和网络(NETWORK)拦截器，每个拦截器链都有自己的优点。 新建ProgressResponseBody类继承ResponseBody123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.izdo.okhttpdemo.okhttp;import java.io.IOException;import okhttp3.MediaType;import okhttp3.ResponseBody;import okio.Buffer;import okio.BufferedSource;import okio.ForwardingSource;import okio.Okio;import okio.Source;/** * Created by iZdo on 2017/5/12. */public class ProgressResponseBody extends ResponseBody &#123; private ResponseBody mResponseBody; private BufferedSource mBufferedSource; public ProgressResponseBody(ResponseBody responseBody) &#123; mResponseBody = responseBody; &#125; @Override public MediaType contentType() &#123; return mResponseBody.contentType(); &#125; @Override public long contentLength() &#123; return mResponseBody.contentLength(); &#125; @Override public BufferedSource source() &#123; return Okio.buffer(getSource(mResponseBody.source())); &#125; private Source getSource(Source source) &#123; return new ForwardingSource(source()) &#123; @Override public long read(Buffer sink, long byteCount) throws IOException &#123; return super.read(sink, byteCount); &#125; &#125;; &#125;&#125; 由于我们需要实现进度的更新，所以接下来需要作出一些修改： 新建ProgressListener接口类作为监听器123456789101112package com.izdo.okhttpdemo.okhttp;/** * Created by iZdo on 2017/5/12. */public interface ProgressListener &#123; public void onProgress(int progress); public void onDone(long totalSize);&#125; 修改ProgressResponseBody类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.izdo.okhttpdemo.okhttp;import java.io.IOException;import okhttp3.MediaType;import okhttp3.ResponseBody;import okio.Buffer;import okio.BufferedSource;import okio.ForwardingSource;import okio.Okio;import okio.Source;/** * Created by iZdo on 2017/5/12. */public class ProgressResponseBody extends ResponseBody &#123; private ResponseBody mResponseBody; private BufferedSource mBufferedSource; private ProgressListener mProgressListener; public ProgressResponseBody(ResponseBody responseBody, ProgressListener listener) &#123; mResponseBody = responseBody; mProgressListener = listener; &#125; @Override public MediaType contentType() &#123; return mResponseBody.contentType(); &#125; @Override public long contentLength() &#123; return mResponseBody.contentLength(); &#125; @Override public BufferedSource source() &#123; // 当BufferedSource为空时才将Source赋给mBufferedSource if (mBufferedSource == null) mBufferedSource = Okio.buffer(getSource((mResponseBody.source()))); return mBufferedSource; &#125; private Source getSource(Source source) &#123; return new ForwardingSource(source()) &#123; // 文件总大小 long totalSize = 0l; // 当前已下载大小 long sum = 0l; @Override public long read(Buffer sink, long byteCount) throws IOException &#123; if (totalSize == 0) &#123; // 当totalSize为空时，将总大小设置为文件总大小 totalSize = contentLength(); &#125; long len = super.read(sink, byteCount); // 判断是否已读到结尾，如果不是，累加到sum中 sum += (len == -1 ? 0 : len); // 计算当前进度 int progress = (int) ((sum * 1.0f / totalSize) * 100); // 如果读取到结尾，则完成下载，否则继续更新进度 if (len == -1) mProgressListener.onDone(totalSize); else mProgressListener.onProgress(progress); return len; &#125; &#125;; &#125;&#125; 这里只是添加了自定义的监听器和进行更新等简单操作，不多阐述。接下来在FileDownloadActivity类中调用拦截器。 修改FileDownloadActivity中的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226package com.izdo.okhttpdemo;import android.Manifest;import android.content.pm.PackageManager;import android.os.Bundle;import android.os.Environment;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.widget.Button;import android.widget.ProgressBar;import android.widget.Toast;import com.izdo.okhttpdemo.okhttp.ProgressListener;import com.izdo.okhttpdemo.okhttp.ProgressResponseBody;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import butterknife.BindView;import butterknife.ButterKnife;import butterknife.OnClick;import okhttp3.Call;import okhttp3.Callback;import okhttp3.Interceptor;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;public class FileDownloadActivity extends AppCompatActivity &#123; // 文件地址 public String url = \"http://download.moji001.com/download/MojiWeather-V6.0304.02-release-c8888.apk\"; // 文件名 public String fileName = \"mojiweather.apk\"; @BindView(R.id.btn_download) Button mBtnDownload; @BindView(R.id.progressBar) ProgressBar mProgressBar; private OkHttpClient httpClient; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_file_download); ButterKnife.bind(this); requestPermission(); initOKhttp(); &#125; private void initOKhttp() &#123; // httpClient = new OkHttpClient(); // 创建拦截器 httpClient = new OkHttpClient.Builder().addNetworkInterceptor(new Interceptor() &#123; @Override public Response intercept(Chain chain) throws IOException &#123; // 通过chain.proceed()方法获取Response Response response = chain.proceed(chain.request()); return response.newBuilder().body(new ProgressResponseBody(response.body(), new Prg())).build(); &#125; &#125;).build(); &#125; class Prg implements ProgressListener &#123; @Override public void onProgress(final int progress) &#123; //在UI线程更新UI runOnUiThread(new Runnable() &#123; @Override public void run() &#123; mProgressBar.setProgress(progress); &#125; &#125;); &#125; @Override public void onDone(long totalSize) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; Toast.makeText(FileDownloadActivity.this, \"下载完成\", Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; &#125; public static final int EXTERNAL_STORAGE_REQ_CODE = 10; public void requestPermission() &#123; // 判断当前Activity是否已经获得了该权限 if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; // 如果App的权限申请曾经被用户拒绝过，就需要在这里跟用户做出解释 if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)) &#123; Toast.makeText(this, \"please give me the permission\", Toast.LENGTH_SHORT).show(); &#125; else &#123; // 进行权限请求 ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, EXTERNAL_STORAGE_REQ_CODE); &#125; &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode) &#123; case EXTERNAL_STORAGE_REQ_CODE: // 如果请求被拒绝，那么通常grantResults数组为空 if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; // 申请成功，进行相应操作 Toast.makeText(FileDownloadActivity.this, \"已获取权限\", Toast.LENGTH_SHORT).show(); &#125; else &#123; //申请失败，可以继续向用户解释。 &#125; break; default: break; &#125; &#125; @OnClick(R.id.btn_download) public void onViewClicked() &#123; downloadAPK(); &#125; // 文件下载 private void downloadAPK() &#123; Request request = new Request.Builder() .url(url) .build(); httpClient.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d(\"FileDownloadActivity\", \"请求文件出错\"); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; writeFile(response); &#125; &#125;); &#125; // Handler mHandler = new Handler() &#123; // @Override // public void handleMessage(Message msg) &#123; // if (msg.what == 1) &#123; // int progress = msg.arg1; // mProgressBar.setProgress(progress); // &#125; // &#125; // &#125;; // 文件读取 private void writeFile(Response response) &#123; InputStream is = null; FileOutputStream fos = null; // 读取返回的数据流 is = response.body().byteStream(); // 获取SD卡路径 String path = Environment.getExternalStorageDirectory().getAbsolutePath(); // 创建新文件 File file = new File(path, fileName); try &#123; fos = new FileOutputStream(file); byte[] bytes = new byte[1024]; int len = 0; // // 请求文件的总大小 // long totalSize = response.body().contentLength(); // // // 当前已下载的大小 // long sum = 0; // 每次以1kb的大小写入文件 while ((len = is.read(bytes)) != -1) &#123; fos.write(bytes); // sum += len; // // int progress = (int) ((sum * 1.0f / totalSize) * 100); // // Message msg = mHandler.obtainMessage(1); // msg.arg1 = progress; // // mHandler.sendMessage(msg); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭流 try &#123; if (is != null) is.close(); if (fos != null) fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 这里的主要修改部分集中在initOKhttp()的拦截器创建中，逻辑比较简单，接下来还是部署到模拟器上查看是否能够下载文件。 效果图： 完善逻辑 严格上来讲，我们是不建议每次需要网络请求时都去初始化一个OKHttp的，而是只初始化一次。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"}]},{"title":"OKHttp3框架(上)","slug":"OKHttp3框架(上)","date":"2017-05-10T07:48:15.269Z","updated":"2017-05-10T13:23:38.297Z","comments":true,"path":"2017/05/10/OKHttp3框架(上)/","link":"","permalink":"https://izdo.github.io/2017/05/10/OKHttp3框架(上)/","excerpt":"","text":"OKHttp3框架(上)OKHttp3的基本用法导入OKHttp3依赖包 成功添加依赖包后在External Libraries中会出现okhttp、okio两个包 okhttp需要依赖okio包，所有的http请求都是基于流，okio是对流再次封装的工具类。 OKHttp3使用实例创建新工程OKHttpDemoMainActivity12345678910111213141516171819202122232425262728293031public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void getRequest(View v) &#123; OkHttpClient client = new OkHttpClient(); String url = \"http://guolin.tech/api/china/10\"; Request request = new Request.Builder().url(url).build(); client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d(\"MainActivity\", \"失败-----\" + e.getLocalizedMessage()); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; String result = response.body().string(); Log.d(\"MainActivity\", result); &#125; &#125;); &#125;&#125; main_activity.xml12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.izdo.okhttpdemo.MainActivity\"&gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"getRequest\" android:text=\"Get Request\"/&gt;&lt;/RelativeLayout&gt; 首先创建一个OKHttpCliend实例和获取数据的链接url。 接着client调用newCall()需要创建一个request实例，然后调用enqueue()方法并传入一个回调Callback即可。 onFailure()和onResponse()分别对应请求失败和成功时的操作，这里我们失败时打印出错误信息，成功时打印出请求结果。 由于网络请求涉及到网络操作，所以最后记得加上网络权限 1&lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt; 结果如下: 说明我们请求成功。 HTTP协议 HTTP(超文本传输协议)是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。 HTPP协议中通信的两方称作Client和Server(或Host)，Client向Server端经过http协议发送一个Request，Server端收到Request后经过一系列的处理返回Client一个Response，图示如下： URL 无状态的协议 http协议是无状态的： 同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说,它并不知道这两个请求来自同一个客户端。 解决方法：Cookie机制来维护状态 Http消息结构Request(消息结构：三部分) 第一部分:Request line(请求行)，第二部分:http header，第三部分:body 请求行：包括http请求的种类，请求资源的路径，http协议版本 http header：http头部信息 body：发送给服务器的query信息 当使用的是”GET”方法的时候，body是为空的(GET只能读取服务器上的信息，post能写入) Response (消息结构：三部分) 第一部分:Request line，第二部分:Request header，第三部分:body Request line：包括协议版本、状态码、message http header：request头部信息 body：返回的请求资源主题 HTTP协议请求方法 GET 请求获取Request-URL所标识的资源 POST 在Request-URL所标识的资源后附加新的数据 HEAD 请求获取由Request-URL所标识的资源的响应消息报头 PUT 请求服务器存储一个资源，并用Request-URL作为其标识 DELETE 请求服务器删除Request-URL所标识的资源 TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT 保留将来使用 OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求 常用请求方法:GET和POST GET和POST的区别 GET一般用于获取/查询资源信息，而POST一般用于更新资源信息1 GET提交的数据会放在URL之后，以？分割URL和传输数据，参数之间以&amp;相连，如：EditPosts.aspx?name=test1&amp;id=123456。POST方法是把提交的数据放在HTTP包的Body中。2 GET提交的数据大小有限制，因为浏览器对URL的长度有限制，而POST方法提交的数据没有限制。3 GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。4 GET方式提交数据，会带来安全问题，比如一个登陆页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。 状态码 Response消息中的第一行叫做状态行，由HTTP协议版本号，状态码，状态消息三部分组成。 状态码用来告诉HTTP客户端，HTTP服务器是否产生了预期的Response。 HTTP/1.1中定义了5类状态码。 状态码由三位数字组成，第一个数字定义了相应的类别。1xx：指示信息–表示请求已接受，继续处理2xx：成功–表示请求已被成功接收、理解、接收3xx：重定向–要完成请求必须进行更进一步的操作4xx：客户端错误–请求有语法错误或请求无法实现5xx：服务器端错误–服务器未能实现合法的请求 常用状态码200–OK： 客户端请求成功400–Bad Request： 客户端请求有语法错误，不能被服务器所理解401–Unauthorized： 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403–Forbidden： 服务器收到请求，但是拒绝提供服务404–Not Found： 请求资源不存在，eg：输入了错误的URL500–Internal Server Error ：服务器发生不可预期的错误503–Server Unavailable： 服务器当前不能处理客户端的请求，一段时间后可能恢复正常 GET请求 获取信息新建Java类UserInfoActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.izdo.okhttpdemo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.widget.Button;import android.widget.ImageView;import android.widget.TextView;import com.squareup.picasso.Picasso;import org.json.JSONException;import org.json.JSONObject;import java.io.IOException;import butterknife.BindView;import butterknife.ButterKnife;import butterknife.OnClick;import okhttp3.Call;import okhttp3.Callback;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;public class UserInfoActivity extends AppCompatActivity &#123; @BindView(R.id.btn_get) Button mBtnGet; @BindView(R.id.imgview) ImageView mImgview; @BindView(R.id.txt_name) TextView mTxtUsername; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_user_info); ButterKnife.bind(this); &#125; @OnClick(R.id.btn_get) public void onViewClicked() &#123; getUserInfo(); &#125; private void getUserInfo() &#123; // 创建OkHttpClient实例 OkHttpClient client = new OkHttpClient(); // 请求地址 String url = \"http://192.168.1.53:8080/myserver/\"; Request request = new Request.Builder() .get() .url(url) .build(); client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d(\"UserInfoActivity\", \"请求失败\" + e.getLocalizedMessage()); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; //if (response.code() == 200) &#123; // isSuccessful()代替code() if (response.isSuccessful()) &#123; String json = response.body().string(); showInfo(json); &#125; &#125; &#125;); &#125; private void showInfo(final String json) &#123; // 操作UI需在UI线程进行 runOnUiThread(new Runnable() &#123; @Override public void run() &#123; try &#123; JSONObject jsonObject = new JSONObject(json); String id = jsonObject.optString(\"id\"); String name = jsonObject.optString(\"name\"); String img = jsonObject.optString(\"img\"); mTxtUsername.setText(name); /** * Picasso 第三方开源框架 * load() 加载图片地址 * resize() 设置图片大小 * centerCrop() 设置图片圆角 * into() 显示到控件 */ Picasso.with(UserInfoActivity.this).load(img).resize(100, 100).centerCrop().into(mImgview); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; activity_user_info12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_user_info\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:orientation=\"vertical\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"com.izdo.okhttpdemo.UserInfoActivity\"&gt; &lt;Button android:id=\"@+id/btn_get\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"获取信息\"/&gt; &lt;ImageView android:id=\"@+id/imgview\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@mipmap/ic_launcher\"/&gt; &lt;TextView android:id=\"@+id/txt_name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"OKHttpDemo\"/&gt;&lt;/LinearLayout&gt; 首先将所有控件初始化，这里需要用到一个第三方框架ButterKnife以及Zelezny插件，绑定并初始化由ButterKnife完成。在按钮的点击事件中调用getUserInfo()方法。请求地址为一个用JSP模拟的本地服务器地址，主要代码如下: 12response.getWriter() .write(\"&#123;'id':'1','name':'香菜','img':'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1035293498,3690663067&amp;fm=23&amp;gp=0.jpg'&#125;\"); 请求由本地服务器模拟出来的JSON数据，用法基本与上文相同。当请求数据成功时调用showInfo()方法。需要注意的是onResponse()方法是在异步线程中进行的而不是在主线程，所以要操作UI必须在UI线程中进行，所以在showInfo()中需要调用runOnUiThread()方法，在UI线程中解析JSON数据。解析img时，由于获取到的是网络图片地址，所以这里需要用Picasso第三方开源框架加载图片，具体细节在代码中已体现。PS：String id = jsonObject.optString(“id”);中使用optString()而不使用getString()的原因是getString()在当key中的值不存在的时候会出现空指针异常，而optString()则会返回一个空字符串或者返回你指定的默认值。 修改默认启动的Activity1234567&lt;activity android:name=\".UserInfoActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\"/&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 效果图: POST请求 Form表单形式新建Java类LoginActivity(同时将默认启动的Activity改为LoginActivity)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.izdo.okhttpdemo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import org.json.JSONException;import org.json.JSONObject;import java.io.IOException;import butterknife.BindView;import butterknife.ButterKnife;import butterknife.OnClick;import okhttp3.Call;import okhttp3.Callback;import okhttp3.FormBody;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.RequestBody;import okhttp3.Response;public class LoginActivity extends AppCompatActivity &#123; @BindView(R.id.etxt_username) EditText mEtxtUsername; @BindView(R.id.etxt_password) EditText mEtxtPassword; @BindView(R.id.btn_login) Button mBtnLogin; private OkHttpClient httpClient; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); ButterKnife.bind(this); httpClient = new OkHttpClient(); &#125; @OnClick(R.id.btn_login) public void onViewClicked() &#123; String username = mEtxtUsername.getText().toString().trim(); String password = mEtxtPassword.getText().toString().trim(); loginWithForm(username, password); &#125; private void loginWithForm(String username, String password) &#123; String url = Config.API.BASE_URL ; // POST方式提交需要一个RequestBody封装参数 RequestBody body = new FormBody.Builder() .add(\"username\", username) .add(\"password\", password) .build(); final Request request = new Request.Builder() .url(url) .post(body) .build(); httpClient.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d(\"LoginActivity\", \"请求服务器出错\"); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; if (response.isSuccessful()) &#123; String json = response.body().string(); try &#123; JSONObject jsonObject = new JSONObject(json); final String message = jsonObject.optString(\"message\"); final int success = jsonObject.optInt(\"success\"); runOnUiThread(new Runnable() &#123; @Override public void run() &#123; if (success == 1) Toast.makeText(LoginActivity.this, \"登录成功\", Toast.LENGTH_SHORT).show(); else Toast.makeText(LoginActivity.this, message, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); &#125;&#125; activity_login123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_login\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"com.izdo.okhttpdemo.LoginActivity\"&gt; &lt;EditText android:id=\"@+id/etxt_username\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"请输入用户名\"/&gt; &lt;EditText android:id=\"@+id/etxt_password\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"请输入密码\"/&gt; &lt;Button android:id=\"@+id/btn_login\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"立即登录\"/&gt;&lt;/LinearLayout&gt; 本地服务器JSP12345678910111213141516171819&lt;%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"UTF-8\"%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort() + path + \"/\"; /* response.getWriter() .write(\"&#123;'id':'1','name':'香菜','img':'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1035293498,3690663067&amp;fm=23&amp;gp=0.jpg'&#125;\"); */ String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); if (username.equals(\"admin\") &amp;&amp; password.equals(\"123456\")) response.getWriter().write(\"&#123;'success':'1','message':'登录成功'&#125;\"); else response.getWriter().write( \"&#123;'success':'0','message':'用户名或密码错误'&#125;\");%&gt; 首先xml布局为一个基本的登录页面，无需解释。然后用ButterKnife绑定控件，详细操作见上文。在按钮的点击事件中，将用户名和密码框的text传递给loginWithForm()方法，然后在loginWithForm()方法中进行请求。由于本地服务器地址URL是固定的，所以将其封装为一个类Config，方便使用。 新建Config类123456789101112package com.izdo.okhttpdemo;/** * Created by iZdo on 2017/5/9. */public class Config &#123; public static class API&#123; public static final String BASE_URL = \"http://192.168.1.53:8080/myserver/\"; &#125;&#125; loginWithForm()方法 方法中大部分逻辑与OKHttp的基本用法大致相同，唯一不同的是，POST方式提交需要一个RequestBody实例来封装参数(实际上GET方式和POST方式需要一个body，只不过当使用的是GET方式时，body是为空的，这个上文有提及)，而由于RequestBody是一个抽象类，无法实例化，所以只能实例化继承了RequestBody的子类。 而通过了解发现，继承了RequestBody的子类有FormBody和MultitarBody，所以这里使用FormBody来实例化RequestBody。实例化RequestBody后在request创建时加上post(body)，表明请求方式为POST。接下来通过输入username和password发送请求，并解析接收到的message和success数据进行解析。 效果图： POST请求 JSON参数形式修改LoginActivity中的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@OnClick(R.id.btn_login) public void onViewClicked() &#123; String username = mEtxtUsername.getText().toString().trim(); String password = mEtxtPassword.getText().toString().trim(); //loginWithForm(username, password); loginWithJSON(username, password); &#125; private void loginWithJSON(String username, String password) &#123; String url = Config.API.BASE_URL; JSONObject jsonObject = new JSONObject(); try &#123; jsonObject.put(\"username\", username); jsonObject.put(\"password\", password); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; String jsonParams = jsonObject.toString(); RequestBody body = RequestBody.create(MediaType.parse(\"application/json;charset=utf-8\"), jsonParams); Request request = new Request.Builder() .url(url) .post(body) .build(); httpClient.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d(\"LoginActivity\", \"请求服务器出错\"); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; if (response.isSuccessful()) &#123; String json = response.body().string(); try &#123; JSONObject jsonObject = new JSONObject(json); final String message = jsonObject.optString(\"message\"); final int success = jsonObject.optInt(\"success\"); runOnUiThread(new Runnable() &#123; @Override public void run() &#123; if (success == 1) Toast.makeText(LoginActivity.this, \"登录成功\", Toast.LENGTH_SHORT).show(); else Toast.makeText(LoginActivity.this, message, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); &#125; 新增了loginWithJSON()方法，逻辑与loginWithForm()大致相同，并在点击事件改为调用loginWithJSON()方法。loginWithJSON()方法不同的是，发送请求时RequestBody需要调用RequestBody.create()封装JSON数据，并将封装好的jsonParams作为参数传入封装在body中。由于效果与Form方式差不多，这里就不放效果图了。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"}]},{"title":"围住神经猫游戏(二)","slug":"围住神经猫游戏(二)","date":"2017-04-16T06:22:23.456Z","updated":"2017-04-06T12:43:58.165Z","comments":true,"path":"2017/04/16/围住神经猫游戏(二)/","link":"","permalink":"https://izdo.github.io/2017/04/16/围住神经猫游戏(二)/","excerpt":"","text":"使用Android制作围住神经猫游戏(二)获取点击圆点的坐标 要响应屏幕的点击事件，需要实现OnTouchListener接口并重写其onTouch()方法。 1234567public PlayGround(Context context) &#123; ... setOnTouchListener(this); initGame(); &#125; 在PlayGround()中加入setOnTouchListener(this)，然后重写onTouch()方法。 1234567@Overridepublic boolean onTouch(View view, MotionEvent motionEvent) &#123; if(motionEvent.getAction()==MotionEvent.ACTION_UP) //获取当前点击的x,y的坐标值 Toast.makeText(getContext(), motionEvent.getX()+\":\"+motionEvent.getY(), Toast.LENGTH_SHORT).show(); return true;&#125; 通过if语句判断当前动作是否为ACTOIN_UP，然后通过Toast显示当前点击位置的坐标。 部署到模拟器查看效果: 实现点击之后圆点颜色改变效果修改onTouch()中的代码:12345678910111213141516171819202122 @Overridepublic boolean onTouch(View view, MotionEvent motionEvent) &#123; if (motionEvent.getAction() == MotionEvent.ACTION_UP) &#123; //获取当前点击的x,y的坐标值 //Toast.makeText(getContext(), motionEvent.getX()+\":\"+motionEvent.getY(), Toast.LENGTH_SHORT).show(); int x, y; // 获取当前点击的行数 y = (int) (motionEvent.getY() / WIDTH); if (y % 2 == 0) &#123; // 奇数行 x = (int) (motionEvent.getX() / WIDTH); &#125; else &#123; // 偶数行 x = (int) ((motionEvent.getX() - WIDTH / 2) / WIDTH); &#125; // 判断点击位置是否越界 if (x + 1 &gt; COL || y + 1 &gt; ROW) initGame(); else getDot(x, y).setStatus(Dot.STATUS_ON); redraw(); &#125; return true;&#125; 首先获取当前点击的行数，用当前点击的y坐标除以WIDTH即可获得。然后判断当前所点击位置是处于奇数行还是偶数行，因为由于偶数行有偏移所以这两种情况下的列数计算方式是不同的。计算没有偏移的行的列值与获取行数相同，而计算偏移的列值则需要当前点击位置的x坐标减去半个WIDTH后再除以WIDTH获得。 其次，为了避免我们点击到非圆点所在的位置，也就是游戏界面以外的空白区域造成越界，需要进行判断，如果所点位置越界，可以让其reutrn false，但是为了后边测试方便，这里设置成重新初始化游戏，如果所点位置不越界，就将其状态设置为已点击。 最后调用redraw()方法重绘界面。 部署并观看效果： 可以看到，效果跟我们所说的那样。 游戏逻辑——功能函数的实现修改PlayGround中的代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class PlayGround extends SurfaceView implements View.OnTouchListener &#123; ... // 判断当前点是否处于边界 private boolean isAtEdge(Dot d) &#123; if (d.getX() * d.getY() == 0 || d.getX() + 1 == COL || d.getY() + 1 == ROW) return true; return false; &#125; // 获取当前点周围六个点 private Dot getNeighbour(Dot one, int dir) &#123; switch (dir) &#123; // 左 case 1: return getDot(one.getX() - 1, one.getY()); // 左上 case 2: if (one.getY() % 2 == 0) &#123; // 偶数行 return getDot(one.getX() - 1, one.getY() - 1); &#125; else &#123; // 奇数行 return getDot(one.getX(), one.getY() - 1); &#125; // 右上 case 3: if (one.getY() % 2 == 0) &#123; // 偶数行 return getDot(one.getX(), one.getY() - 1); &#125; else &#123; // 奇数行 return getDot(one.getX() + 1, one.getY() - 1); &#125; // 右 case 4: return getDot(one.getX() + 1, one.getY()); // 右下 case 5: if (one.getY() % 2 == 0) &#123; // 偶数行 return getDot(one.getX(), one.getY() + 1); &#125; else &#123; // 奇数行 return getDot(one.getX() + 1, one.getY() + 1); &#125; // 左下 case 6: if (one.getY() % 2 == 0) &#123; // 偶数行 return getDot(one.getX() - 1, one.getY() + 1); &#125; else &#123; // 奇数行 return getDot(one.getX(), one.getY() + 1); &#125; default: break; &#125; return null; &#125; // 获得距离 private int getDistance(Dot one, int dir) &#123; int distance = 0; Dot ori = one, next; while (true) &#123; // 获取周围的点 next = getNeighbour(ori, dir); // 遇到障碍 if (next.getStatus() == Dot.STATUS_ON) return distance * -1; // 无障碍 if (isAtEdge(next)) &#123; distance++; return distance; &#125; distance++; ori = next; &#125; &#125; // 移动猫 private void MoveTo(Dot one) &#123; one.setStatus(Dot.STATUS_IN); getDot(cat.getX(), cat.getY()).setStatus(Dot.STATUS_OFF); cat.setXY(one.getX(), one.getY()); &#125; ... &#125; 这里我们主要加入了四个方法: isAtEdge(),getNeighbour(),getDistance(),MoveTo(),接下来我会一一解释这几个方法的作用。isAtEdge() 这个方法用来判断当前点是否处于边界，d.getX() * d.getY() == 0表示的是x和y中只要其中一个为0，相乘的结果也肯定为0，所以包含了上和左边界的判断，而d.getX() + 1 == COL || d.getY() + 1 == ROW分别是右边界和下边界的判断。getNeighbour() 这个方法用来获取当前点周围的六个点，首先我们需要对周围的点进行分析: 当前点的左右两边的坐标分别是(x-1,y)和(x+1,y)，这是毋庸置疑的，但是在左上，右上，右下，左下这四个点的位置是会因为当前点所在的行是奇数行还是偶数行而不同的。 在此我们规定当前点的左，左上，右上，右，右下，左下方向分别由数字1-6表示(后面都用数字来代表方向)，因此getNeighbour()方法需要两个参数，一个是当前点，另一个是方向值。 接着用一个switch语句进行判断当前需要获取的方向的点，1,4方向是固定的，而2,3,5,6方向需要分奇偶行。 在此之前，我已经将具体的情况通过图片绘制出来，先观察一下下面两幅图: 相信上面两幅图已经很好地诠释了周围的点的坐标值，接下来用one.getY() % 2 == 0判断当前点位于奇数行还是偶数行，然后将相应的点获取并return即可，这里不再多做解释。getDistance() 这个方法用于获取当前点指定方向到边界的距离，首先定义一个距离值distance和两个Dot类型的变量ori、next，ori用来存储当前点(由于当前点在此方法中会不断变化，所以需要用一个新的Dot类型来存储，否则在后面的while循环中会进入死循环)，next用来存储当前点的下一个点。 然后通过一个while循环不断的获取到下一个点，并将distance自增。 而在获取下一个点之前需要进行判断，当下一个点为障碍点时，将返回一个负数的distance，而如果直到边界都一路畅通，没有障碍的话就返回一个正数的distance，通过正负数，当前点在此方向上是否有障碍一目了然，这里可以进行一个测试。修改onTouch()中的方法: 12345678910111213141516171819@Override public boolean onTouch(View view, MotionEvent motionEvent) &#123; if (motionEvent.getAction() == MotionEvent.ACTION_UP) &#123; ... // 判断点击位置是否越界 if (x + 1 &gt; COL || y + 1 &gt; ROW) //return true; //initGame(); for (int i = 1; i &lt; 7; i++) &#123; Log.d(\"-----------\", \"第\" + i + \"个方向的距离为：\" + getDistance(cat, i)); &#125; ... &#125; return true; &#125; 将initGame()方法注释掉，然后用一个for循环打印出当前猫所在点六个方向上的距离值。部署项目并观看效果: 可以看到，当前猫所在点的六个方向上的距离值与打印出来的结果一一对应。 这里只是做一个测试，测试之后记得将越界时的逻辑还原成initGame()。 MoveTo() 这个方法用于将猫移动至指定点。 首选将当前传入的点的status设置为STATUS_IN,即猫在这个点上，然后将当前猫所在点的status设置为STATUS_OFF，最后再将猫设置到新的点上。 这样，游戏逻辑的实现就完成了一半了。 游戏逻辑——基本移动策略修改PlayGround中的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class PlayGround extends SurfaceView implements View.OnTouchListener &#123; ... // 让猫走动 private void move() &#123; // 判断猫是否在场景边界 if (isAtEdge(cat)) &#123; lose(); return; &#125; // 判断猫是否被路障包围 Vector&lt;Dot&gt; avaliable = new Vector&lt;&gt;(); for (int i = 1; i &lt; 7; i++) &#123; Dot n = getNeighbour(cat, i); if (n.getStatus() == Dot.STATUS_OFF) &#123; avaliable.add(n); &#125; &#125; if (avaliable.size() == 0) win(); else MoveTo(avaliable.get(0)); &#125; // 游戏失败 private void lose() &#123; Toast.makeText(getContext(), \"Lose\", Toast.LENGTH_SHORT).show(); &#125; // 游戏成功 private void win() &#123; Toast.makeText(getContext(), \"You Win！\", Toast.LENGTH_SHORT).show(); &#125; ... @Override public boolean onTouch(View view, MotionEvent motionEvent) &#123; if (motionEvent.getAction() == MotionEvent.ACTION_UP) &#123; //获取当前点击的x,y的坐标值 //Toast.makeText(getContext(), motionEvent.getX()+\":\"+motionEvent.getY(), Toast.LENGTH_SHORT).show(); int x, y; // 获取当前点击的行数 y = (int) (motionEvent.getY() / WIDTH); if (y % 2 == 0) &#123; // 奇数行 x = (int) (motionEvent.getX() / WIDTH); &#125; else &#123; // 偶数行 x = (int) ((motionEvent.getX() - WIDTH / 2) / WIDTH); &#125; // 判断点击位置是否越界 if (x + 1 &gt; COL || y + 1 &gt; ROW) //return true; initGame(); else if (getDot(x, y).getStatus() == Dot.STATUS_OFF) &#123; getDot(x, y).setStatus(Dot.STATUS_ON); move(); &#125; redraw(); &#125; return true; &#125;&#125; 在PlayGround中添加move()方法，lose()方法以及win()方法。 lose()和win()比较简单，只是负责显示相应的Toast。 而在onTouch()方法中，将else修改成 else if (getDot(x, y).getStatus() == Dot.STATUS_OFF)是为了防止猫所在的点被点击之后变成STATUS_ON状态，这样修改之后就算点击猫所在的点状态也不会发生改变了，接着再调用move()方法。move() 这个方法用于实现让猫走动的逻辑。 首先我们要考虑两个情况:1.当前猫是否处于场景边界 2.当前猫是否已经被路障包围 因此我们需要作出判断，当猫处于边界的话，就调用lose()方法并return结束游戏;而判断猫是否被包围则复杂一点，首先我们创建一个Vector集合用于存储猫周围的点，表示猫被多少个路障围住，然后用一个for循环判断猫周围六个点的状态，若点的状态为STATUS_OFF，则表示还未被设置成路障，将其放入Vector集合中，判断完所有的点后，若集合中没有任何元素，则表明猫周围没有可走的点，游戏胜利，否则调用MoveTo()让猫移动。 运行程序: 可以看到，猫已经可以走动了，但是我们在MoveTo()的时候，传入的是avaliable.get(0)，这样固定猫的走法的话，玩家在多次游戏之后很容易就能找到猫移动的规律，所以接下来还要对猫移动的算法逻辑进行优化。 优化游戏逻辑修改move()中的代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 让猫走动private void move() &#123; // 判断猫是否在场景边界 if (isAtEdge(cat)) &#123; lose(); return; &#125; // 判断猫是否被路障包围 Vector&lt;Dot&gt; avaliable = new Vector&lt;&gt;(); Vector&lt;Dot&gt; positive = new Vector&lt;&gt;(); HashMap&lt;Dot, Integer&gt; al = new HashMap&lt;&gt;(); for (int i = 1; i &lt; 7; i++) &#123; Dot n = getNeighbour(cat, i); if (n.getStatus() == Dot.STATUS_OFF) &#123; avaliable.add(n); al.put(n, i); if (getDistance(n, i) &gt; 0) &#123; positive.add(n); &#125; &#125; &#125; if (avaliable.size() == 0) win(); else if (avaliable.size() == 1) MoveTo(avaliable.get(0)); else &#123; Dot best = null; if (positive.size() != 0) &#123; // 存在可以直接到达边界的走向 int min = 9999; for (int i = 0; i &lt; positive.size(); i++) &#123; int a = getDistance(positive.get(i), al.get(positive.get(i))); if (a &lt; min) &#123; min = a; best = positive.get(i); &#125; &#125; &#125; else &#123; // 所有方向都存在路障 int max = 0; for (int i = 0; i &lt; avaliable.size(); i++) &#123; int k = getDistance(avaliable.get(i), al.get(avaliable.get(i))); if (k &lt;= max) &#123; max = k; best = avaliable.get(i); &#125; &#125; &#125; MoveTo(best); &#125;&#125; 首先将条件语句进行了修改，当可走点只有一个的时候，就只能选择那个方向，而当可选的点有两个以上的时候，就从没有路障的所有方向中选出离边界最近的路，具体实现逻辑是这样的: 定义一个Vector集合来存储当前点的六个方向中没有路障(即可以直接到达边界)的方向。然后在进行判断周围的点是否为STATUS_OFF之后再进行一次判断，用getDistance()获得的是正数或者负数来判断是否有直接到达边界的方向，若有，则添加进positive集合。 现在实现当可选的点有两个以上时的具体逻辑，首先定义一个Dot类型的best，用来存储最符合当前情况的下一个位置的点，然后进行判断，判断的情况有两种：1.positive里有元素，即当前点存在可以直接到达边界的方向;2.positive里没有元素，即所有方向都存在路障。针对这两种情况进行逻辑的修改。当前点存在可以直接到达边界的方向 在这种情况下，我们就需要找出这些可以直达边界的方向中最短的那个，以达到可以最快到达边界的目的。 首先创建一个int类型的min，用于存放最短路径，初始值尽可能地大，所以设置为9999。 接着通过一个for循环从可以直达边界的所有点的集合(即positive)中找出最短的路径，但是现在却出现了一个问题，我们需要从positive中取出点，一个一个进行判断，但我们并不知道这些点具体是哪个方向的，而且存入positive时我们也没有做相应的记录，所以这时候就需要用到一个HashMap来存储这个点对于源点来说是哪个方向的。 创建HashMap集合al，并在判断点的状态是否为STATUS_OFF之后将这个点以及方向放入al中，即al.put(n, i)。这样我们就可以不管加入positive的点的顺序，轻而易举地知道这些点的方向了。 继续之前的逻辑，定义一个int类型的a用来存储positive中的点的distance长度，而方向直接到al集合中取即可:al.get(avaliable.get(i))。最后进行判断，如果这个点的distance值a比min小，则将min的值修改为a，并且best也修改为这个点。 所有方向都存在路障 通过上面的分析，这种情况下的逻辑就比较容易理解了，基本差不多。 区别就是，当所有方向都存在路障的话，需要找出所有点距离路障的长度中，最大的那个长度值，因为只有往离路障越远的距离的方向走，猫逃出路障的几率才会更大。 这里定义一个int类型的max，用于存放最长路径，而且初始值要尽可能地小，这里就设置为0，而后面的操作基本都差不多。* 需要注意的是，判断条件为k&lt;=max，这是由于我们前文中将存在路障的路径的长度值设置为负数，而负数越大，其绝对值越小，所以判断条件才会是k&lt;=max。 最后无论是哪种情况，都需要将猫移动到best。 部署游戏： 可以明显看出，猫的移动没有之前那样容易找出规律了。 这样游戏基本就完成了，虽然UI并没有真正的围住神经猫游戏美观，但是游戏的具体逻辑算是比较完整了，这仅仅是一个demo，就不追求完美了。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"},{"name":"demo","slug":"demo","permalink":"https://izdo.github.io/tags/demo/"}]},{"title":"围住神经猫游戏(一)","slug":"围住神经猫游戏(一)","date":"2017-04-16T06:18:08.832Z","updated":"2017-04-16T06:18:00.027Z","comments":true,"path":"2017/04/16/围住神经猫游戏(一)/","link":"","permalink":"https://izdo.github.io/2017/04/16/围住神经猫游戏(一)/","excerpt":"","text":"使用Android制作围住神经猫游戏(一)新建工程CatchCrazyCat新建Java类PlayGround作为游戏背景1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.catchcrazycat;import android.content.Context;import android.graphics.Canvas;import android.graphics.Color;import android.view.SurfaceHolder;import android.view.SurfaceView;/** * Created by iZdo on 2017/3/28. */public class PlayGround extends SurfaceView &#123; public PlayGround(Context context) &#123; super(context); &#125; private void redraw() &#123; // 获得Canvas画布实例 Canvas c = getHolder().lockCanvas(); // 使用Canvas绘制背景 c.drawColor(Color.LTGRAY); // 设置背景 getHolder().unlockCanvasAndPost(c); &#125; // 为SurfaceHolder添加回调 SurfaceHolder.Callback callback = new SurfaceHolder.Callback() &#123; @Override public void surfaceCreated(SurfaceHolder surfaceHolder) &#123; // 在surface初始化时调用redraw()方法 redraw(); &#125; @Override public void surfaceChanged(SurfaceHolder surfaceHolder, int i, int i1, int i2) &#123; &#125; @Override public void surfaceDestroyed(SurfaceHolder surfaceHolder) &#123; &#125; &#125;;&#125; PlayGround类需要继承自SurfaceViewSurfaceView介绍 SurfaceView是继承自View用于显示图像的组件的。SurfaceView最大的特点就是它的双缓冲技术，所谓的双缓冲技术就是在它内部有两个线程，比如线程AB，当线程A更新界面时，B进行后台计算操作，当两个线程都完成各自的任务时，它们就会互相交换，A进行后台运算，B进行界面更新，两个线程无限循环交替更新和计算。由于SurfaceView的这种特性可以避免画图任务繁重而造成主线程阻塞，从而提高了程序的反应速度，因此在游戏开发中多用到SurfaceView，例如游戏中的背景、人物、动画等。 上面代码中我们首先在redraw()方法中通过getHolder获取SurfaceHolder，接着调用其lockCanvas()方法获取Canvas实例，然后调用drawColor()绘制背景，再调用unlockCanvasAndPost()方法将绘制的背景设置到SurfaceView界面上。 如果在onCreate()方法执行时，SurfaceHolder还没有完全创建好，这时候就会出现异常，这就需要给SurfaceHolder添加回调了。创建一个新的回调Callback，Callback是一个接口，所以需要重写其三个方法:surfaceCreated()、surfaceChanged()、surfaceDestroyed()，这三个方法分别是在surfaceView的holder被创建、被销毁以及surfaceView的大小发生变化时调用。 这里我们只需要在holder创建时调用redraw()方法即可。 最后再构造函数中添加Callback。 Canvas介绍 通常情况下，要在Android中绘图，需要创建一个集成自View的视图，并且在该类中重写其onDraw(Canvas canvas)方法，然后在Activity中添加该视图，这里需要传入一个Canvas协助绘图。Canvas类代表画布，通过该类提供的方法，可以绘制各种图形。 修改MainActivity1234567891011121314package com.catchcrazycat;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //setContentView(R.layout.activity_main); setContentView(new PlayGround(this)); &#125;&#125; 这里我们将原先加载的布局换成我们定义的PlayGround并传入上下文。 部署到Genymotion观看效果: 创建Java类Dot 这个类用于记录所有点的xy坐标以及它的状态。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.catchcrazycat;/** * Created by iZdo on 2017/3/28. */public class Dot &#123; int x, y; int status; public static final int STATUS_ON = 1; public static final int STATUS_OFF = 2; public static final int STATUS_IN = 3; public Dot(int x, int y) &#123; this.x = x; this.y = y; status = STATUS_OFF; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125; public int getStatus() &#123; return status; &#125; public void setStatus(int status) &#123; this.status = status; &#125; public void setXY(int x, int y) &#123; this.x = x; this.y = y; &#125;&#125; 首先创建int类型的x，y用于存储点的横纵坐标，然后创建一个status用于记录当前点的状态。 然后定义三个常量分别用于表示点的三种状态:点未被点(OFF)，点已被点(ON),猫在点中。 定义一个带参构造器，并将status的状态设置为STATUS_OFF。 除了给x，y，status提供对应的get、set方法之外，还需要提供一个setxy()方法用于设置xy。 修改PlayGround中的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.catchcrazycat;import android.content.Context;import android.graphics.Canvas;import android.graphics.Color;import android.view.SurfaceHolder;import android.view.SurfaceView;/** * Created by iZdo on 2017/3/28. */public class PlayGround extends SurfaceView &#123; private static final int ROW = 10; private static final int COL = 10; // 随机添加的路障数量 private static final int BLOCKS = 15; private Dot matrix[][]; private Dot cat; public PlayGround(Context context) &#123; super(context); getHolder().addCallback(callback); matrix = new Dot[ROW][COL]; // 将二维数组所有数据初始化为Dot类型 for (int i = 0; i &lt; ROW; i++) &#123; for (int j = 0; j &lt; COL; j++) &#123; matrix[i][j] = new Dot(j, i); &#125; &#125; initGame(); &#125; // 获取指定坐标的对应点 private Dot getDot(int x, int y) &#123; return matrix[y][x]; &#125; ... // 初始化所有点 private void initGame() &#123; for (int i = 0; i &lt; ROW; i++) &#123; for (int j = 0; j &lt; COL; j++) &#123; matrix[i][j].setStatus(Dot.STATUS_OFF); &#125; &#125; cat = new Dot(4, 5); getDot(4, 5).setStatus(Dot.STATUS_IN); for (int i = 0; i &lt; BLOCKS; ) &#123; int x = (int) ((Math.random() * 1000) % COL); int y = (int) ((Math.random() * 1000) % ROW); if (getDot(x, y).getStatus() == Dot.STATUS_OFF) &#123; getDot(x, y).setStatus(Dot.STATUS_ON); i++; &#125; &#125; &#125;&#125; 我们先来看看围住神经猫游戏的主界面: 可以看到，游戏主界面的背景是一个多行多列的方阵(行之间有偏移，但后面可以解决),所以我们可以用二维数组来储存。 创建数据类型为Dot的二维数组matrix[][]，在构造方法PlayGround()中用两层for循环将二维数组所有数据初始化。 在初始化点时，可以看到: matrix[i][j] = new Dot(j, i); matrix的第i行第j列的点对应的是Dot(j,i)，这是由于Dot的两个参数x，y分别代表的是横坐标和纵坐标，而横坐标所对应的是列数COL，纵坐标所对应的是行数ROW，是反过来的，不理解的话可以看一下下面的图: 而由于这样i，j和j，i转换会混乱我们的思维，因此我们可以将这种转换封装成getDot()方法，方便我们转换的同时又不会混乱我们。 而最后的initGame()用于初始化所有点的状态，同样是用两层for循环，将所有点初始化为OFF状态，并且将一开始创建的Dot类型的cat猫初始化在(4,5)的位置，并且将其状态设置为IN。 最后我们需要定义一个常量BLOCKS表示随机添加的路障数量，并且在initGame()方法中用for循环随机设置路障位置。 绘制场景 直接上代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class PlayGround extends SurfaceView &#123; private static int WIDTH = 40; ... private void redraw() &#123; // 获得Canvas画布实例 Canvas c = getHolder().lockCanvas(); // 使用Canvas绘制背景 c.drawColor(Color.LTGRAY); // 创建画笔 Paint paint = new Paint(); for (int i = 0; i &lt; ROW; i++) &#123; for (int j = 0; j &lt; COL; j++) &#123; Dot one = getDot(j, i); // 根据点的状态设置画笔的颜色 switch (one.getStatus()) &#123; case Dot.STATUS_OFF: paint.setColor(0xFFEEEEEE); break; case Dot.STATUS_ON: paint.setColor(0xFFFFAA00); break; case Dot.STATUS_IN: paint.setColor(0xFFFF0000); break; default: break; &#125; // 绘制圆点 c.drawOval(new RectF(one.getX() * WIDTH , one.getY() * WIDTH, (one.getX() + 1) * WIDTH , (one.getY() + 1) * WIDTH), paint); &#125; &#125; // 设置背景 getHolder().unlockCanvasAndPost(c); &#125; ...&#125; 首先定义一个Paint，Paint类代表画笔，用来描述图形的颜色和风格，如线宽、颜色、透明度和填充效果等信息。 同样用两层for循环进行绘制，用一个switch语句判断当前点的状态并根据其状态将画笔设置成不同的颜色，然后调用drawOval方法绘制圆点。 部署到Genymotion观看效果: 这样一个10*10的矩阵就绘制出来了，但这明显不是我们想要的效果，缺少了偏移，但比较好实现，修改redraw()中的代码: 12345678910111213141516171819private void redraw() &#123; ... for (int i = 0; i &lt; ROW; i++) &#123; int offset = 0; // 偶数行偏移 if (i % 2 != 0) &#123; offset = WIDTH / 2; &#125; for (int j = 0; j &lt; COL; j++) &#123; ... // 绘制圆点 c.drawOval(new RectF(one.getX() * WIDTH + offset, one.getY() * WIDTH, (one.getX() + 1) * WIDTH + offset, (one.getY() + 1) * WIDTH), paint); &#125; &#125; 添加一个偏移量offset，用if语句判断当偶数行时就将offset设置为WIDTH的一般，并且在绘制圆点时做出相应的修改，这样就完成了偏移。 部署到Genymotion观看效果: 这样错位偏移的效果也完成了，但是我们发现，绘制的圆点似乎不是很圆，边上会有类似锯齿一样的东西，这是由于我们用画笔画出来的图形是位图，是由一格一格像素组成的，所以会有锯齿，这是只要给画笔Paint设置抗锯齿就行了。 1paint.setFlags(Paint.ANTI_ALIAS_FLAG); 观看效果: 现在锯齿已经消失了，但是还有一个问题，我们可以看到，在模拟器上绘制的是一个10*10的矩阵，而由于模拟器分辨率比较高，所以在放满10个圆点之后还有一部分空白。 这也许不会影响什么，但如果在分辨率较小的手机上运行，就会出现超出边界之类的问题了，所以我们需要适配一下屏幕。 要适配屏幕，就需要在Callback中的surfaceChanged()方法中定义了，这个方法我们可能还不知道是用来做什么的，但是我们通过查看AndroidAPI文档可以知道，surfaceChanged()的最后两个参数分别代表的是surfaceView的宽和高。 修改surfaceChanged()方法12345@Overridepublic void surfaceChanged(SurfaceHolder surfaceHolder, int i, int i1, int i2) &#123; WIDTH = i1 / (COL + 1); redraw();&#125; 将WIDTH动态地设置成与surfaceView的宽相关的值，这样就可以适配其他分比率的屏幕了。 ps:为什么要除以(COL+1)而不是COL呢?这是因为我们绘制的场景要有偏移的效果，如果我们只除以COL的话，就只能恰好满足十列的宽度，也就是第一行的宽度，但由于第二行是向右偏倚了一个半径的宽度，所以如果只除以COL的话第二行最后一个圆点的一半会在屏幕之外，这样的用户体验是非常不好的，所以需要多加一个宽度来将偶数行也适配进去。 观看效果: 可以看到，屏幕适配也成功了。 这样一来，场景绘制的工作也完成了。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"},{"name":"demo","slug":"demo","permalink":"https://izdo.github.io/tags/demo/"}]},{"title":"Lambda表达式","slug":"Lambda表达式","date":"2017-04-08T06:07:17.010Z","updated":"2017-04-08T06:10:25.953Z","comments":true,"path":"2017/04/08/Lambda表达式/","link":"","permalink":"https://izdo.github.io/2017/04/08/Lambda表达式/","excerpt":"","text":"最近小编偶然接触到了一个叫做Lambda表达式的函数，于是就去了解了一下，觉得还挺有趣的，今天我们就一起来学习一下这个表达式。那么Lambda表达式是什么呢？首先让我们先看看百度对Lambda表达式的定义：“Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包（注意和数学传统意义上的不同）。（以上摘自百度百科） 是不是有点看不懂？没关系，定义的东西是这样的，接下来我们来看一下一个Java的例子： 首先我们定义一个接口，接口中只有一个待实现的方法sayHello()。 接下来我们定义一个类实现这个接口，这里我们不使用implements Example来实现接口，而是采用匿名内部类的方式来实现Example接口。 这是很常见的类实现接口的一段代码，但是久而久之我们就会发现这段代码存在一个问题：这段代码有好几行，而实际上却只有System.out.println(“Hello”); 这一行在工作，也就是说最终我们是通过这一行代码输出”Hello”，而其他不必要的代码却比在工作的代码多得多。匿名类型最大的问题就在于其冗余的语法，而很多时候我们为了方便又不得不使用匿名类型，那有什么办法可以解决这个问题吗？这就要用到我们前面提到的Lambda表达式了，Lambda表达式是Java8加入的新特性，而实际上Lambda表达式也是一种匿名方法，但是它既没有方法名，也没有访问修饰符和返回值类型，使得代码会更加简洁、易读。 使用Lambda表达式后可以这样写： 怎么样？是不是简洁了许多？不管是代码行数上还是缩进结构上来看，Lambda表达式的写法明显比传统的写法更加精简。 再来看一个例子，我们在Java多线程编程中，按以往的传统我们要开启一个子线程需要这样写： 而使用Lambda表达式后可以这样写： 那么为什么我们可以这样写呢？这是因为Thread类的构造函数接收的参数是一个Runnable接口，并且这个接口中只有一个待实现的方法： 通过查看源码我们发现Runnable接口中确实只有一个待实现的run()方法，也就是说，凡是这种只有一个待实现方法的接口，我们都可以使用Lambda表达式进行简写。 看到这里，也许很多人会说，使用Lambda表达式之后代码也没有减少多少啊。然而这仅仅是我们的一个例子，在实际开发中，代码量往往都是上千行的，而在这上千行代码中，我们是用Lambda表达式使其更简洁，减少代码量，增加可读性，确实是一件好事。你以为这就完了吗？接下来再来看看Java的“类型推断“，果断再看一个例子： 这里我们仍然使用之前的例子，只不过将sayHello()方法改成带两个参数的append(String a,int b)方法，这和之前的例子是基本一致的。 在我们使用Lambda表达式将其简化之后的代码是这样的： 这个我们没什么好说的，我要说的是Java8可以根据上下文自动推断出Lambda表达式中的参数类型，根据这个特性，我们又可以将代码这样写： 去掉参数后我们又能进一步偷懒了呢！这样使得代码简洁之后再简洁。 假设现在有一个方法是接收Example参数的： 那么我们在调用test()方法的时候就可以这样写： 最终打印的结果是：Lambda表达式666 接下来我们说说Android。由于Java8加入了许多新特性，但是由于很多新特性都只支持Android7.0以上的系统，我们显然不可能为了使用这些新特性而放弃兼容众多低版本的Android手机，毕竟现在使用Android7.0的手机还不是很多，大多数人都是使用着7.0以下的系统，7.0的普及还需要一段时间，这就使得其他新特性没有用武之地了，然而Lambda表达式却最低兼容到Android2.3系统，基本上可以覆盖所有的Android手机了。 而Android中除了前文说到的开启子线程可以运用Lambda表达式之外，像设置点击事件这类的功能也是非常适合使用Lambda表达式的。 比如，按照以往的写法，我们要给一个按钮设置点击事件需要这样写： 使用Lambda表达式之后，就可以简化成这样了： 看到这里，是不是觉得已经结束了？然而并没有，Lambda表达式不仅仅在Java中适用，其他一些语言同样支持Lambda表达式。作为一个良心的小编，我特地找了学过Python的不愿意透露性别的男同学简单地了解了一下：Lambda的主体是一个表达式，而不是一个代码块。仅仅能在Lambda表达式中封装有限的逻辑进去。Lambda表达式是起到一个函数速写的作用，允许在代码内嵌入一个函数的定义。不过Lamdba表达式一般不单独使用，而是结合其他的函数一起使用的。比如说这个例子： 使用Lambda表达式后省去了函数的定义，很明显减少了很多代码量。 而在其他语言中，Lambda表达式是ISO C++11标准引入的，C#同样也能使用Lambda表达式，这里就不再阐述，有兴趣的同学可以去了解一下。 至此，Lambda表达式的用法我们都已经知道了，可能有些人会不习惯Lambda表达式的写法，但Java8中新加入这个表达式，并不是说强制你用这种写法，你如果不喜欢这种写法的话，完全可以依照以前的写法，不管怎么说，Java8引入Lambda表达式只是提供了一种简化代码的方式，使用与否在于你个人。","categories":[{"name":"Java","slug":"Java","permalink":"https://izdo.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://izdo.github.io/tags/Java/"}]},{"title":"如何做一个简单的通讯录","slug":"制作通讯录","date":"2017-03-26T14:05:59.634Z","updated":"2017-04-06T12:42:17.985Z","comments":true,"path":"2017/03/26/制作通讯录/","link":"","permalink":"https://izdo.github.io/2017/03/26/制作通讯录/","excerpt":"","text":"如何做一个简单的通讯录获取手机通讯录信息创建新工程GetMyPhoneContacts为了模拟通讯录的效果，现在genymotion模拟器中添加几个联系人 效果图: 创建Java类 GetNumber12345678910111213141516171819202122232425262728293031package com.getmyphonecontacts;import android.content.Context;import android.database.Cursor;import android.provider.ContactsContract.CommonDataKinds.Phone;import android.util.Log;/** * Created by iZdo on 2017/3/26. */public class GetNumber &#123; public static String getNumber(Context context) &#123; // 查询系统通讯录 Cursor cursor = context.getContentResolver().query(Phone.CONTENT_URI, null, null, null, null); // 定义两个字符串用于获取姓名和电话号码 String phoneName; String phoneNumber; // 循环遍历 while (cursor.moveToNext()) &#123; phoneName = cursor.getString(cursor.getColumnIndex(Phone.DISPLAY_NAME)); phoneNumber = cursor.getString(cursor.getColumnIndex(Phone.NUMBER)); Log.d(\"MainActivity\", \"phoneName= \" + phoneName + \",phoneNumber= \" + phoneNumber); &#125; return null; &#125;&#125; 类中只有一个getNumber方法，这个方法用于获取手机通讯录的联系人 这个方法需要一个上下文Context对象作为参数，首先调用上下文的getContentResolver()方法获取一个内容解析者ContentResolver对象并且调用其query()方法查询系统联系人 query()方法第一个参数为一个Uri，这里传入Phone.CONTENT_URI即可，后面的四个参数为查询条件，目前我们不需要筛选联系人，因此全部传入null即可。 query()返回的是一个游标Cursor，用while循环不断遍历Cursor，从Cursor中取出联系人的姓名和号码。 1234567891011121314package com.getmyphonecontacts;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); GetNumber.getNumber(this); &#125;&#125; 在MAinActivity中调用GetNumber的getNumber()方法。 打印日志如下: D/MainActivity: phoneName= zhangsan,phoneNumber= 110 D/MainActivity: phoneName= lisi,phoneNumber= 119 D/MainActivity: phoneName= lin,phoneNumber= 666 可以看到，打印的结果和通讯录中的联系人吻合。 封装数据 现在要做的是将得到的数据封装起来新建Java类ContactInfo 1234567891011121314151617181920212223242526272829303132333435package com.getmyphonecontacts;/** * Created by iZdo on 2017/3/27. */public class ContactInfo &#123; private String name; private String number; // 构造器 public ContactInfo(String name, String number) &#123; this.name = name; this.number = number; &#125; // 对应的getter、setter方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getNumber() &#123; return number; &#125; public void setNumber(String number) &#123; this.number = number; &#125;&#125; 简单的JavaBean类，不多做解释 ps:number使用String类型而不适用int类型是因为号码会有地区之分，所以会出现”+86”的情况，所以不能只用int类型来存储。 修改GetNumber中的代码:12345678910111213141516171819public class GetNumber &#123; public static List&lt;ContactInfo&gt; contactInfoList = new ArrayList&lt;ContactInfo&gt;(); public static String getNumber(Context context) &#123; ... // 循环遍历 while (cursor.moveToNext()) &#123; phoneName = cursor.getString(cursor.getColumnIndex(Phone.DISPLAY_NAME)); phoneNumber = cursor.getString(cursor.getColumnIndex(Phone.NUMBER)); ContactInfo contactInfo = new ContactInfo(phoneName, phoneNumber); contactInfoList.add(contactInfo); Log.d(\"MainActivity\", \"phoneName= \" + phoneName + \",phoneNumber= \" + phoneNumber); &#125; return null; &#125;&#125; GetNumber中新创建了一个数据类型为ContactInfo的List集合，在getNumber()方法的while循环中，每一次循环都将新创建一个ContactInfo对象，并将获取的联系人姓名和号码存入ContactInfo对象中，再将其加入到List集合里，这样就将所有的联系人都存入到了List集合，实现了数据的封装。 ps:显示中的通讯录实际上不止姓名和号码两项，还有地址，电子邮箱等信息，这里为了方便救只使用姓名和号码这两项。 UI适配修改activity_main.xml文件123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.getmyphonecontacts.MainActivity\"&gt; &lt;ListView android:id=\"@+id/lv\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt;&lt;/RelativeLayout&gt; 这里使用ListView用于联系人数据的显示。 自定义适配器新建MyAdapter继承自BaseAdapter1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.getmyphonecontacts;import android.content.Context;import android.view.View;import android.view.ViewGroup;import android.widget.BaseAdapter;import java.util.List;/** * Created by iZdo on 2017/3/27. */public class MyAdapter extends BaseAdapter &#123; private List&lt;ContactInfo&gt; mContactInfoList; private Context mContext; public MyAdapter(List&lt;ContactInfo&gt; contactInfoList, Context context) &#123; mContactInfoList = contactInfoList; mContext = context; &#125; @Override public int getCount() &#123; return mContactInfoList.size(); &#125; @Override public Object getItem(int i) &#123; return mContactInfoList.get(i); &#125; @Override public long getItemId(int i) &#123; return i; &#125; @Override public View getView(int i, View view, ViewGroup viewGroup) &#123; return null; &#125;&#125; 此处需要创建一个数据类型为ContactInfo的List集合和一个上下文对象COntext。 再创建一个构造器，其参数为一个List集合和一个上下文对象。 继承BaseAdapter需要重写四个方法:getCount()、getItem()、getItemId()、getView(): public int getCount():用于得到Item的总数，这里返回我们创建的List集合的长度即可。 public Object getItem(int i):用于根据i得到某个Item的对象，这里需要返回List集合对应位置i的对象。 public long getItemId(int i):用于根据i得到某个Item的id，由于位置i代表的就是其相应Item的id，这里返回i即可。 public View getView(int i, View view, ViewGroup viewGroup):用于得到相应的i对应的Item视图，i当前的位置以及converView复用的View对象，在写这个方法之前，我们需要再新建一个Item布局来展示具体数据。 新建布局文件contact.xml1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\"&gt; &lt;RelativeLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt; &lt;ImageView android:id=\"@+id/iv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@mipmap/ic_launcher\"/&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_alignBottom=\"@id/iv\" android:layout_alignTop=\"@id/iv\" android:layout_toRightOf=\"@id/iv\" android:gravity=\"center_vertical\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"111\" android:textSize=\"15sp\"/&gt; &lt;TextView android:id=\"@+id/number\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"222\" android:textSize=\"10sp\"/&gt; &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt;&lt;/LinearLayout&gt; 效果图如下: 简单的布局，左边是一个ImageView，右边是两个TextView，具体实现如代码所示，此处不再阐述。 修改MyAdapter的代码将getView()方法的内容补充完整12345678910@Overridepublic View getView(int i, View view, ViewGroup viewGroup) &#123; LayoutInflater inflater = LayoutInflater.from(mContext); LinearLayout layout = (LinearLayout) inflater.inflate(R.layout.contact, null); TextView nametv = (TextView) layout.findViewById(R.id.name); TextView numbertv = (TextView) layout.findViewById(R.id.number); nametv.setText(mContactInfoList.get(i).getName()); numbertv.setText(mContactInfoList.get(i).getNumber()); return layout;&#125; 首先创建一个打气筒将刚才创建的Item布局文件转化为一个View，然后初始化两个TextView控件并为其填充相应位置的联系人信息，最后将layout返回。 ps:LayoutInflater.from()方法需要传入一个上下文对象Context，这里就需要用到此前创建的成员变量mContext，而mContext是通过构造器得到的，因此在构造器里设置Context为参数的好处就是当某个活动创建我们自定义的适配器MyAdapter的时候就会同时将其上下文传入，使得活动与适配器联系了起来。 修改MainActivity中的代码123456789101112131415161718192021package com.getmyphonecontacts;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.ListView;public class MainActivity extends AppCompatActivity &#123; private ListView lv; private MyAdapter mAdapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); GetNumber.getNumber(this); lv = (ListView) findViewById(R.id.lv); mAdapter = new MyAdapter(GetNumber.contactInfoList, this); lv.setAdapter(mAdapter); &#125;&#125; 创建一个ListView 创建一个MyAdapter适配器 这里没什么好说的，需要注意的一点是MyAdapter的两个参数分别传入GetNumber中的List集合(静态成员变量，可通过类名直接调用)和this即可。 部署到Genymotion模拟器上观看效果效果如下: 可以看到，联系人的信息都显示在了每一行Item上了。 ps:ImageView上的图片事先并无准备，所以就用了系统自带的ic_launcher图片。 复用历史缓存对象进行优化 ListView其实是一个比较难用的控件，因为它有很多细节可以优化，运行效率就是其中很重要的一点，我们上面写的ListView运行效率是很低的，因为在getView()方法中，每次都将布局重新加载了一遍，当ListView快速滚动的时候，会明显出现卡顿的现象(由于我们的数据量比较少，无法体现出卡顿效果，当数据量比较大的时候能够明显看出)，这时候我们就需要优化ListView的，我们可以发现getView()方法里还有一个view(原先是convertView)是我们没用到的，这是一个缓存对象，就是用于优化ListView的。 修改MyAdapter中的代码:12345678910111213141516171819202122232425262728293031323334public class MyAdapter extends BaseAdapter &#123; ... @Override public View getView(int i, View view, ViewGroup viewGroup) &#123; // LayoutInflater inflater = LayoutInflater.from(mContext); // LinearLayout layout = (LinearLayout) inflater.inflate(R.layout.contact, null); // TextView nametv = (TextView) layout.findViewById(R.id.name); // TextView numbertv = (TextView) layout.findViewById(R.id.number); // nametv.setText(mContactInfoList.get(i).getName()); // numbertv.setText(mContactInfoList.get(i).getNumber()); ViewHolder holder; if (view == null) &#123; view = LayoutInflater.from(mContext).inflate(R.layout.contact, null); holder = new ViewHolder(); holder.nametv = (TextView) view.findViewById(R.id.name); holder.numbertv = (TextView) view.findViewById(R.id.number); holder.nametv.setText(mContactInfoList.get(i).getName()); holder.numbertv.setText(mContactInfoList.get(i).getNumber()); view.setTag(holder); &#125; else &#123; holder = (ViewHolder) view.getTag(); holder.nametv.setText(mContactInfoList.get(i).getName()); holder.numbertv.setText(mContactInfoList.get(i).getNumber()); &#125; return view; &#125; private static class ViewHolder &#123; TextView nametv; TextView numbertv; &#125;&#125; 首先创建了一个内部类ViewHolder，用于对控件的实例进行缓存。 在getView方法中，创建了一个ViewHolder对象，当缓存view为空时，就将联系人的信息封装在ViewHolder里，然后调用setTag()方法将ViewHolder储存在view中，而当缓存不为空时，就调用getTag()方法取出ViewHolder，这样就实现了缓存的复用。 继续改进 通过复用缓存对象我们对ListView进行了优化，而通过观察getView()方法，我们发现不管缓存view为空时，新建ViewHolder去缓存实例还是缓存view不为空时，取出缓存，我们都需要用这个ViewHolder对TextView进行设置文本内容，所以我们又可以进一步优化代码: 123456789101112131415161718192021222324252627public class MyAdapter extends BaseAdapter &#123; ... @Override public View getView(int i, View view, ViewGroup viewGroup) &#123; ... ViewHolder holder; if (view == null) &#123; view = LayoutInflater.from(mContext).inflate(R.layout.contact, null); holder = new ViewHolder(); holder.nametv = (TextView) view.findViewById(R.id.name); holder.numbertv = (TextView) view.findViewById(R.id.number); view.setTag(holder); &#125; else holder = (ViewHolder) view.getTag(); holder.nametv.setText(mContactInfoList.get(i).getName()); holder.numbertv.setText(mContactInfoList.get(i).getNumber()); return view; &#125; ... &#125; 这里我们将holder.nametv.setText(mContactInfoList.get(i).getName())和 holder.numbertv.setText(mContactInfoList.get(i).getNumber())放到判断语句外边，减少了代码的重复(其实就是之前忘了放)。 这样就完成了从手机系统通讯录中取出数据放到我们自己的通讯录上的效果。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"},{"name":"demo","slug":"demo","permalink":"https://izdo.github.io/tags/demo/"}]},{"title":"如何做一个简单的倒计时","slug":"制作倒计时","date":"2017-03-25T08:36:11.032Z","updated":"2017-04-06T12:43:41.271Z","comments":true,"path":"2017/03/25/制作倒计时/","link":"","permalink":"https://izdo.github.io/2017/03/25/制作倒计时/","excerpt":"","text":"如何做一个简单的倒计时1. 创建新工程CountTime2. 布局文件activity_main.xml:123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"com.counttime.MainActivity\"&gt; &lt;EditText android:id=\"@+id/inputtime\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:ems=\"10\"/&gt; &lt;Button android:id=\"@+id/gettime\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"获取倒计时时间\"/&gt; &lt;TextView android:id=\"@+id/time\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; &lt;Button android:id=\"@+id/starttime\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"开始计时\"/&gt; &lt;Button android:id=\"@+id/stoptime\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"停止计时\"/&gt;&lt;/LinearLayout&gt; inputtime用于输入倒计时时间gettime用于显示inputtime输入的时间time用于显示倒计时时间starttime、stoptime分别用于开始和停止倒计时 效果图: 3. MainActivity逻辑:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.counttime;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import java.util.Timer;import java.util.TimerTask;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private EditText inputet; private Button getTime, startTime, stopTime; private TextView time; private int i = 0; private Timer timer = null; private TimerTask task = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //调用初始化控件方法 initView(); &#125; // 初始化控件 private void initView() &#123; inputet = (EditText) findViewById(R.id.inputtime); getTime = (Button) findViewById(R.id.gettime); startTime = (Button) findViewById(R.id.starttime); stopTime = (Button) findViewById(R.id.stoptime); time = (TextView) findViewById(R.id.time); getTime.setOnClickListener(this); startTime.setOnClickListener(this); stopTime.setOnClickListener(this); &#125; // 设置点击事件 @Override public void onClick(View view) &#123; switch (view.getId()) &#123; // 点击gettime按钮获取inputet上的时间值 case R.id.gettime: time.setText(inputet.getText().toString()); i = Integer.parseInt(inputet.getText().toString()); break; case R.id.starttime: startTime(); break; case R.id.stoptime: stopTime(); break; default: break; &#125; &#125; // 使用Handler实现对主线程的更新UI操作 private Handler mHandler = new Handler() &#123; // 调用handleMessage处理消息 public void handleMessage(Message msg) &#123; time.setText(msg.arg1 + \"\"); startTime(); &#125; &#125;; public void startTime() &#123; // 创建计时器和计时任务 timer = new Timer(); task = new TimerTask() &#123; @Override public void run() &#123; i--; Message message = mHandler.obtainMessage(); message.arg1 = i; mHandler.sendMessage(message); &#125; &#125;; timer.schedule(task, 1000); &#125; public void stopTime() &#123; // 取消计时器 timer.cancel(); &#125;&#125; 由于主线程不允许子线程更新UI，因此这里需要用到Handler实现子线程更新UI的操作。 首先创建一个Handler并调用handleMessage方法处理sendMessage传递过来的消息，需要注意的是，TextView的setText方法只能传入String类型的参数，因此不能单单传入msg.arg1，一种简单的处理方式就是在后面加上“”将其转换成字符串:time.setText(msg.arg1 + “”);。 Timer和TimerTask一般是配合使用的(由TimerTask实现任务内容，然后将任务放入计时器Timer),在TimerTask的run()方法里创建一个Message用于向Handler发送消息，这里传入的是i(此前已经将inputet中的数字赋给i)，并调用sendMessage方法将Message发送给Handler，最后调用schedule()方法将TimerTask放入计时器。 timer.schedule(task, 1);第一个参数表示要放入的TimerTask任务，第二个参数是一个毫秒值，表示多少时间之后启动任务，这里放入1000毫秒(1秒)。 最后调用cancel()方法取消任务。 ps:在startTime()中调用sendMessage()方法向Handler发送消息，而在Handler的handleMessage中又调用startTime()方法，这样就形成了sendMessage()-&gt;handleMessage()-&gt;sendMessage()-&gt;handleMessage()-&gt;…的循环。 4. 部署到Genymotion观看效果: 5. 改进 这里存在这一个问题就是计时器读数到0后会变成负数，所以下面需要修改一些代码使计时器归0后停止计时。1234567891011public void startTime() &#123; ... @Override public void run() &#123; i--; if(i&lt;0)&#123; stopTime(); return; &#125; ... &#125; 这里在startTime()方法中的run()方法中加入一个if判断，当i小于0的时候就调用stopTime()方法并且return。(这里判断条件是小于0而不是等于0是逻辑顺序的问题) 为了更好地看到”刹车”效果，将任务间隔设置为1毫秒。 1timer.schedule(task, 1); 效果如下: 对于目前的程序，由于从inputet获取的值为int类型，但当我们输入小数或者字符和其他符号时，程序会崩溃，这里可以使用正则表达式限制输入。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"},{"name":"demo","slug":"demo","permalink":"https://izdo.github.io/tags/demo/"}]}]}