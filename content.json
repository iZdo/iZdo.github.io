{"meta":{"title":"iZdo's Blog","subtitle":"bonbolu","description":null,"author":"iZdo","url":"https://izdo.github.io"},"pages":[{"title":"categories","date":"2017-03-23T14:14:27.000Z","updated":"2017-03-23T14:14:51.148Z","comments":true,"path":"categories/index.html","permalink":"https://izdo.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-03-23T05:20:30.000Z","updated":"2017-03-23T05:21:03.041Z","comments":false,"path":"tags/index.html","permalink":"https://izdo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"围住神经猫游戏","slug":"围住神经猫游戏","date":"2017-03-29T06:23:06.543Z","updated":"2017-03-29T06:22:44.999Z","comments":true,"path":"2017/03/29/围住神经猫游戏/","link":"","permalink":"https://izdo.github.io/2017/03/29/围住神经猫游戏/","excerpt":"","text":"使用Android制作围住神经猫游戏新建工程CatchCrazyCat新建Java类PlayGround作为游戏背景1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.catchcrazycat;import android.content.Context;import android.graphics.Canvas;import android.graphics.Color;import android.view.SurfaceHolder;import android.view.SurfaceView;/** * Created by iZdo on 2017/3/28. */public class PlayGround extends SurfaceView &#123; public PlayGround(Context context) &#123; super(context); &#125; private void redraw() &#123; // 获得Canvas画布实例 Canvas c = getHolder().lockCanvas(); // 使用Canvas绘制背景 c.drawColor(Color.LTGRAY); // 设置背景 getHolder().unlockCanvasAndPost(c); &#125; // 为SurfaceHolder添加回调 SurfaceHolder.Callback callback = new SurfaceHolder.Callback() &#123; @Override public void surfaceCreated(SurfaceHolder surfaceHolder) &#123; // 在surface初始化时调用redraw()方法 redraw(); &#125; @Override public void surfaceChanged(SurfaceHolder surfaceHolder, int i, int i1, int i2) &#123; &#125; @Override public void surfaceDestroyed(SurfaceHolder surfaceHolder) &#123; &#125; &#125;;&#125; PlayGround类需要继承自SurfaceViewSurfaceView介绍 SurfaceView是继承自View用于显示图像的组件的。SurfaceView最大的特点就是它的双缓冲技术，所谓的双缓冲技术就是在它内部有两个线程，比如线程AB，当线程A更新界面时，B进行后台计算操作，当两个线程都完成各自的任务时，它们就会互相交换，A进行后台运算，B进行界面更新，两个线程无限循环交替更新和计算。由于SurfaceView的这种特性可以避免画图任务繁重而造成主线程阻塞，从而提高了程序的反应速度，因此在游戏开发中多用到SurfaceView，例如游戏中的背景、人物、动画等。 上面代码中我们首先在redraw()方法中通过getHolder获取SurfaceHolder，接着调用其lockCanvas()方法获取Canvas实例，然后调用drawColor()绘制背景，再调用unlockCanvasAndPost()方法将绘制的背景设置到SurfaceView界面上。 如果在onCreate()方法执行时，SurfaceHolder还没有完全创建好，这时候就会出现异常，这就需要给SurfaceHolder添加回调了。创建一个新的回调Callback，Callback是一个接口，所以需要重写其三个方法:surfaceCreated()、surfaceChanged()、surfaceDestroyed()，这三个方法分别是在surfaceView的holder被创建、被销毁以及surfaceView的大小发生变化时调用。 这里我们只需要在holder创建时调用redraw()方法即可。 最后再构造函数中添加Callback。 Canvas介绍 通常情况下，要在Android中绘图，需要创建一个集成自View的视图，并且在该类中重写其onDraw(Canvas canvas)方法，然后在Activity中添加该视图，这里需要传入一个Canvas协助绘图。Canvas类代表画布，通过该类提供的方法，可以绘制各种图形。 修改MainActivity1234567891011121314package com.catchcrazycat;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //setContentView(R.layout.activity_main); setContentView(new PlayGround(this)); &#125;&#125; 这里我们将原先加载的布局换成我们定义的PlayGround并传入上下文。部署到Genymotion观看效果: 创建Java类Dot 这个类用于记录所有点的xy坐标以及它的状态。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.catchcrazycat;/** * Created by iZdo on 2017/3/28. */public class Dot &#123; int x, y; int status; public static final int STATUS_ON = 1; public static final int STATUS_OFF = 2; public static final int STATUS_IN = 3; public Dot(int x, int y) &#123; this.x = x; this.y = y; status = STATUS_OFF; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125; public int getStatus() &#123; return status; &#125; public void setStatus(int status) &#123; this.status = status; &#125; public void setXY(int x, int y) &#123; this.x = x; this.y = y; &#125;&#125; 首先创建int类型的x，y用于存储点的横纵坐标，然后创建一个status用于记录当前点的状态。 然后定义三个常量分别用于表示点的三种状态:点未被点(打开)，点已被点(关闭),猫在点中。 定义一个带参构造器，并将status的状态设置为STATUS_OFF。 除了给x，y，status提供对应的get、set方法之外，还需要提供一个setxy()方法用于设置xy。 修改PlayGround中的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.catchcrazycat;import android.content.Context;import android.graphics.Canvas;import android.graphics.Color;import android.view.SurfaceHolder;import android.view.SurfaceView;/** * Created by iZdo on 2017/3/28. */public class PlayGround extends SurfaceView &#123; private static final int ROW = 10; private static final int COL = 10; // 随机添加的路障数量 private static final int BLOCKS = 15; private Dot matrix[][]; private Dot cat; public PlayGround(Context context) &#123; super(context); getHolder().addCallback(callback); matrix = new Dot[ROW][COL]; // 将二维数组所有数据初始化为Dot类型 for (int i = 0; i &lt; ROW; i++) &#123; for (int j = 0; j &lt; COL; j++) &#123; matrix[i][j] = new Dot(j, i); &#125; &#125; initGame(); &#125; // 获取指定坐标的对应点 private Dot getDot(int x, int y) &#123; return matrix[y][x]; &#125; ... // 初始化所有点 private void initGame() &#123; for (int i = 0; i &lt; ROW; i++) &#123; for (int j = 0; j &lt; COL; j++) &#123; matrix[i][j].setStatus(Dot.STATUS_OFF); &#125; &#125; cat = new Dot(4, 5); getDot(4, 5).setStatus(Dot.STATUS_IN); for (int i = 0; i &lt; BLOCKS; ) &#123; int x = (int) ((Math.random() * 1000) % COL); int y = (int) ((Math.random() * 1000) % ROW); if (getDot(x, y).getStatus() == Dot.STATUS_OFF) &#123; getDot(x, y).setStatus(Dot.STATUS_ON); i++; &#125; &#125; &#125;&#125; 我们先来看看围住神经猫游戏的主界面: 可以看到，游戏主界面的背景是一个多行多列的方阵(行之间有偏移，但后面可以解决),所以我们可以用二维数组来储存。 创建数据类型为Dot的二维数组matrix[][]，在构造方法PlayGround()中用两层for循环将二维数组所有数据初始化。 在初始化点时，可以看到: matrix[i][j] = new Dot(j, i); matrix的第i行第j列的点对应的是Dot(j,i)，这是由于Dot的两个参数x，y分别代表的是横坐标和纵坐标，而横坐标所对应的是列数COL，纵坐标所对应的是行数ROW，是反过来的，不理解的话可以看一下下面的图: 而由于这样i，j和j，i转换会混乱我们的思维，因此我们可以将这种转换封装成getDot()方法，方便我们转换的同时又不会混乱我们。 而最后的initGame()用于初始化所有点的状态，同样是用两层for循环，将所有点初始化为OFF状态，并且将一开始创建的Dot类型的cat猫初始化在(4,5)的位置，并且将其状态设置为IN。 最后我们需要定义一个常量BLOCKS表示随机添加的路障数量，并且在initGame()方法中用for循环随机设置路障位置。 绘制场景 直接上代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class PlayGround extends SurfaceView &#123; private static int WIDTH = 40; ... private void redraw() &#123; // 获得Canvas画布实例 Canvas c = getHolder().lockCanvas(); // 使用Canvas绘制背景 c.drawColor(Color.LTGRAY); // 创建画笔 Paint paint = new Paint(); for (int i = 0; i &lt; ROW; i++) &#123; for (int j = 0; j &lt; COL; j++) &#123; Dot one = getDot(j, i); // 根据点的状态设置画笔的颜色 switch (one.getStatus()) &#123; case Dot.STATUS_OFF: paint.setColor(0xFFEEEEEE); break; case Dot.STATUS_ON: paint.setColor(0xFFFFAA00); break; case Dot.STATUS_IN: paint.setColor(0xFFFF0000); break; default: break; &#125; // 绘制圆点 c.drawOval(new RectF(one.getX() * WIDTH , one.getY() * WIDTH, (one.getX() + 1) * WIDTH , (one.getY() + 1) * WIDTH), paint); &#125; &#125; // 设置背景 getHolder().unlockCanvasAndPost(c); &#125; ...&#125; 首先定义一个Paint，Paint类代表画笔，用来描述图形的颜色和风格，如线宽、颜色、透明度和填充效果等信息。 同样用两层for循环进行绘制，用一个switch语句判断当前点的状态并根据其状态将画笔设置成不同的颜色，然后调用drawOval方法绘制圆点。 部署到Genymotion观看效果: 这样一个10*10的矩阵就绘制出来了，但这明显不是我们想要的效果，缺少了偏移，但比较好实现，修改redraw()中的代码: 12345678910111213141516171819private void redraw() &#123; ... for (int i = 0; i &lt; ROW; i++) &#123; int offset = 0; // 偶数行偏移 if (i % 2 != 0) &#123; offset = WIDTH / 2; &#125; for (int j = 0; j &lt; COL; j++) &#123; ... // 绘制圆点 c.drawOval(new RectF(one.getX() * WIDTH + offset, one.getY() * WIDTH, (one.getX() + 1) * WIDTH + offset, (one.getY() + 1) * WIDTH), paint); &#125; &#125; 添加一个偏移量offset，用if语句判断当偶数行时就将offset设置为WIDTH的一般，并且在绘制圆点时做出相应的修改，这样就完成了偏移。 部署到Genymotion观看效果: 这样错位偏移的效果也完成了，但是我们发现，绘制的圆点似乎不是很圆，边上会有类似锯齿一样的东西，这是由于我们用画笔画出来的图形是位图，是由一格一格像素组成的，所以会有锯齿，这是只要给画笔Paint设置抗锯齿就行了。 1paint.setFlags(Paint.ANTI_ALIAS_FLAG); 观看效果: 现在锯齿已经消失了，但是还有一个问题，我们可以看到，在模拟器上绘制的是一个10*10的矩阵，而由于模拟器分辨率比较高，所以在放满10个圆点之后还有一部分空白。 这也许不会影响什么，但如果在分辨率较小的手机上运行，就会出现超出边界之类的问题了，所以我们需要适配一下屏幕。 要适配屏幕，就需要在Callback中的surfaceChanged()方法中定义了，这个方法我们可能还不知道是用来做什么的，但是我们通过查看AndroidAPI文档可以知道，surfaceChanged()的最后两个参数分别代表的是surfaceView的宽和高。 修改surfaceChanged()方法12345@Overridepublic void surfaceChanged(SurfaceHolder surfaceHolder, int i, int i1, int i2) &#123; WIDTH = i1 / (COL + 1); redraw();&#125; 将WIDTH动态地设置成与surfaceView的宽相关的值，这样就可以适配其他分比率的屏幕了。 ps:为什么要除以(COL+1)而不是COL呢?这是因为我们绘制的场景要有偏移的效果，如果我们只除以COL的话，就只能恰好满足十列的宽度，也就是第一行的宽度，但由于第二行是向右偏倚了一个半径的宽度，所以如果只除以COL的话第二行最后一个圆点的一半会在屏幕之外，这样的用户体验是非常不好的，所以需要多加一个宽度来将偶数行也适配进去。 观看效果: 可以看到，屏幕适配也成功了。 这样一来，场景绘制的工作也完成了。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"}]},{"title":"如何做一个简单的通讯录","slug":"制作通讯录","date":"2017-03-26T14:05:59.634Z","updated":"2017-03-28T04:53:48.013Z","comments":true,"path":"2017/03/26/制作通讯录/","link":"","permalink":"https://izdo.github.io/2017/03/26/制作通讯录/","excerpt":"","text":"如何做一个简单的通讯录获取手机通讯录信息创建新工程GetMyPhoneContacts为了模拟通讯录的效果，现在genymotion模拟器中添加几个联系人 效果图: 创建Java类 GetNumber12345678910111213141516171819202122232425262728293031package com.getmyphonecontacts;import android.content.Context;import android.database.Cursor;import android.provider.ContactsContract.CommonDataKinds.Phone;import android.util.Log;/** * Created by iZdo on 2017/3/26. */public class GetNumber &#123; public static String getNumber(Context context) &#123; // 查询系统通讯录 Cursor cursor = context.getContentResolver().query(Phone.CONTENT_URI, null, null, null, null); // 定义两个字符串用于获取姓名和电话号码 String phoneName; String phoneNumber; // 循环遍历 while (cursor.moveToNext()) &#123; phoneName = cursor.getString(cursor.getColumnIndex(Phone.DISPLAY_NAME)); phoneNumber = cursor.getString(cursor.getColumnIndex(Phone.NUMBER)); Log.d(\"MainActivity\", \"phoneName= \" + phoneName + \",phoneNumber= \" + phoneNumber); &#125; return null; &#125;&#125; 类中只有一个getNumber方法，这个方法用于获取手机通讯录的联系人 这个方法需要一个上下文Context对象作为参数，首先调用上下文的getContentResolver()方法获取一个内容解析者ContentResolver对象并且调用其query()方法查询系统联系人 query()方法第一个参数为一个Uri，这里传入Phone.CONTENT_URI即可，后面的四个参数为查询条件，目前我们不需要筛选联系人，因此全部传入null即可。 query()返回的是一个游标Cursor，用while循环不断遍历Cursor，从Cursor中取出联系人的姓名和号码。 1234567891011121314package com.getmyphonecontacts;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); GetNumber.getNumber(this); &#125;&#125; 在MAinActivity中调用GetNumber的getNumber()方法。 打印日志如下: D/MainActivity: phoneName= zhangsan,phoneNumber= 110 D/MainActivity: phoneName= lisi,phoneNumber= 119 D/MainActivity: phoneName= lin,phoneNumber= 666 可以看到，打印的结果和通讯录中的联系人吻合。 封装数据 现在要做的是将得到的数据封装起来新建Java类ContactInfo 1234567891011121314151617181920212223242526272829303132333435package com.getmyphonecontacts;/** * Created by iZdo on 2017/3/27. */public class ContactInfo &#123; private String name; private String number; // 构造器 public ContactInfo(String name, String number) &#123; this.name = name; this.number = number; &#125; // 对应的getter、setter方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getNumber() &#123; return number; &#125; public void setNumber(String number) &#123; this.number = number; &#125;&#125; 简单的JavaBean类，不多做解释 ps:number使用String类型而不适用int类型是因为号码会有地区之分，所以会出现”+86”的情况，所以不能只用int类型来存储。 修改GetNumber中的代码:12345678910111213141516171819public class GetNumber &#123; public static List&lt;ContactInfo&gt; contactInfoList = new ArrayList&lt;ContactInfo&gt;(); public static String getNumber(Context context) &#123; ... // 循环遍历 while (cursor.moveToNext()) &#123; phoneName = cursor.getString(cursor.getColumnIndex(Phone.DISPLAY_NAME)); phoneNumber = cursor.getString(cursor.getColumnIndex(Phone.NUMBER)); ContactInfo contactInfo = new ContactInfo(phoneName, phoneNumber); contactInfoList.add(contactInfo); Log.d(\"MainActivity\", \"phoneName= \" + phoneName + \",phoneNumber= \" + phoneNumber); &#125; return null; &#125;&#125; GetNumber中新创建了一个数据类型为ContactInfo的List集合，在getNumber()方法的while循环中，每一次循环都将新创建一个ContactInfo对象，并将获取的联系人姓名和号码存入ContactInfo对象中，再将其加入到List集合里，这样就将所有的联系人都存入到了List集合，实现了数据的封装。 ps:显示中的通讯录实际上不止姓名和号码两项，还有地址，电子邮箱等信息，这里为了方便救只使用姓名和号码这两项。 UI适配修改activity_main.xml文件123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.getmyphonecontacts.MainActivity\"&gt; &lt;ListView android:id=\"@+id/lv\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt;&lt;/RelativeLayout&gt; 这里使用ListView用于联系人数据的显示。 自定义适配器新建MyAdapter继承自BaseAdapter1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.getmyphonecontacts;import android.content.Context;import android.view.View;import android.view.ViewGroup;import android.widget.BaseAdapter;import java.util.List;/** * Created by iZdo on 2017/3/27. */public class MyAdapter extends BaseAdapter &#123; private List&lt;ContactInfo&gt; mContactInfoList; private Context mContext; public MyAdapter(List&lt;ContactInfo&gt; contactInfoList, Context context) &#123; mContactInfoList = contactInfoList; mContext = context; &#125; @Override public int getCount() &#123; return mContactInfoList.size(); &#125; @Override public Object getItem(int i) &#123; return mContactInfoList.get(i); &#125; @Override public long getItemId(int i) &#123; return i; &#125; @Override public View getView(int i, View view, ViewGroup viewGroup) &#123; return null; &#125;&#125; 此处需要创建一个数据类型为ContactInfo的List集合和一个上下文对象COntext。 再创建一个构造器，其参数为一个List集合和一个上下文对象。 继承BaseAdapter需要重写四个方法:getCount()、getItem()、getItemId()、getView(): public int getCount():用于得到Item的总数，这里返回我们创建的List集合的长度即可。 public Object getItem(int i):用于根据i得到某个Item的对象，这里需要返回List集合对应位置i的对象。 public long getItemId(int i):用于根据i得到某个Item的id，由于位置i代表的就是其相应Item的id，这里返回i即可。 public View getView(int i, View view, ViewGroup viewGroup):用于得到相应的i对应的Item视图，i当前的位置以及converView复用的View对象，在写这个方法之前，我们需要再新建一个Item布局来展示具体数据。 新建布局文件contact.xml1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\"&gt; &lt;RelativeLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt; &lt;ImageView android:id=\"@+id/iv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@mipmap/ic_launcher\"/&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_alignBottom=\"@id/iv\" android:layout_alignTop=\"@id/iv\" android:layout_toRightOf=\"@id/iv\" android:gravity=\"center_vertical\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"111\" android:textSize=\"15sp\"/&gt; &lt;TextView android:id=\"@+id/number\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"222\" android:textSize=\"10sp\"/&gt; &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt;&lt;/LinearLayout&gt; 效果图如下: 简单的布局，左边是一个ImageView，右边是两个TextView，具体实现如代码所示，此处不再阐述。 修改MyAdapter的代码将getView()方法的内容补充完整12345678910@Overridepublic View getView(int i, View view, ViewGroup viewGroup) &#123; LayoutInflater inflater = LayoutInflater.from(mContext); LinearLayout layout = (LinearLayout) inflater.inflate(R.layout.contact, null); TextView nametv = (TextView) layout.findViewById(R.id.name); TextView numbertv = (TextView) layout.findViewById(R.id.number); nametv.setText(mContactInfoList.get(i).getName()); numbertv.setText(mContactInfoList.get(i).getNumber()); return layout;&#125; 首先创建一个打气筒将刚才创建的Item布局文件转化为一个View，然后初始化两个TextView控件并为其填充相应位置的联系人信息，最后将layout返回。 ps:LayoutInflater.from()方法需要传入一个上下文对象Context，这里就需要用到此前创建的成员变量mContext，而mContext是通过构造器得到的，因此在构造器里设置Context为参数的好处就是当某个活动创建我们自定义的适配器MyAdapter的时候就会同时将其上下文传入，使得活动与适配器联系了起来。 修改MainActivity中的代码123456789101112131415161718192021package com.getmyphonecontacts;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.ListView;public class MainActivity extends AppCompatActivity &#123; private ListView lv; private MyAdapter mAdapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); GetNumber.getNumber(this); lv = (ListView) findViewById(R.id.lv); mAdapter = new MyAdapter(GetNumber.contactInfoList, this); lv.setAdapter(mAdapter); &#125;&#125; 创建一个ListView 创建一个MyAdapter适配器 这里没什么好说的，需要注意的一点是MyAdapter的两个参数分别传入GetNumber中的List集合(静态成员变量，可通过类名直接调用)和this即可。 部署到Genymotion模拟器上观看效果效果如下: 可以看到，联系人的信息都显示在了每一行Item上了。 ps:ImageView上的图片事先并无准备，所以就用了系统自带的ic_launcher图片。 复用历史缓存对象进行优化 ListView其实是一个比较难用的控件，因为它有很多细节可以优化，运行效率就是其中很重要的一点，我们上面写的ListView运行效率是很低的，因为在getView()方法中，每次都将布局重新加载了一遍，当ListView快速滚动的时候，会明显出现卡顿的现象(由于我们的数据量比较少，无法体现出卡顿效果，当数据量比较大的时候能够明显看出)，这时候我们就需要优化ListView的，我们可以发现getView()方法里还有一个view(原先是convertView)是我们没用到的，这是一个缓存对象，就是用于优化ListView的。 修改MyAdapter中的代码:12345678910111213141516171819202122232425262728293031323334public class MyAdapter extends BaseAdapter &#123; ... @Override public View getView(int i, View view, ViewGroup viewGroup) &#123; // LayoutInflater inflater = LayoutInflater.from(mContext); // LinearLayout layout = (LinearLayout) inflater.inflate(R.layout.contact, null); // TextView nametv = (TextView) layout.findViewById(R.id.name); // TextView numbertv = (TextView) layout.findViewById(R.id.number); // nametv.setText(mContactInfoList.get(i).getName()); // numbertv.setText(mContactInfoList.get(i).getNumber()); ViewHolder holder; if (view == null) &#123; view = LayoutInflater.from(mContext).inflate(R.layout.contact, null); holder = new ViewHolder(); holder.nametv = (TextView) view.findViewById(R.id.name); holder.numbertv = (TextView) view.findViewById(R.id.number); holder.nametv.setText(mContactInfoList.get(i).getName()); holder.numbertv.setText(mContactInfoList.get(i).getNumber()); view.setTag(holder); &#125; else &#123; holder = (ViewHolder) view.getTag(); holder.nametv.setText(mContactInfoList.get(i).getName()); holder.numbertv.setText(mContactInfoList.get(i).getNumber()); &#125; return view; &#125; private static class ViewHolder &#123; TextView nametv; TextView numbertv; &#125;&#125; 首先创建了一个内部类ViewHolder，用于对控件的实例进行缓存。 在getView方法中，创建了一个ViewHolder对象，当缓存view为空时，就将联系人的信息封装在ViewHolder里，然后调用setTag()方法将ViewHolder储存在view中，而当缓存不为空时，就调用getTag()方法取出ViewHolder，这样就实现了缓存的复用。 继续改进 通过复用缓存对象我们对ListView进行了优化，而通过观察getView()方法，我们发现不管缓存view为空时，新建ViewHolder去缓存实例还是缓存view不为空时，取出缓存，我们都需要用这个ViewHolder对TextView进行设置文本内容，所以我们又可以进一步优化代码: 123456789101112131415161718192021222324252627public class MyAdapter extends BaseAdapter &#123; ... @Override public View getView(int i, View view, ViewGroup viewGroup) &#123; ... ViewHolder holder; if (view == null) &#123; view = LayoutInflater.from(mContext).inflate(R.layout.contact, null); holder = new ViewHolder(); holder.nametv = (TextView) view.findViewById(R.id.name); holder.numbertv = (TextView) view.findViewById(R.id.number); view.setTag(holder); &#125; else holder = (ViewHolder) view.getTag(); holder.nametv.setText(mContactInfoList.get(i).getName()); holder.numbertv.setText(mContactInfoList.get(i).getNumber()); return view; &#125; ... &#125; 这里我们将holder.nametv.setText(mContactInfoList.get(i).getName())和 holder.numbertv.setText(mContactInfoList.get(i).getNumber())放到判断语句外边，减少了代码的重复(其实就是之前忘了放)。 这样就完成了从手机系统通讯录中取出数据放到我们自己的通讯录上的效果。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"}]},{"title":"如何做一个简单的倒计时","slug":"制作倒计时","date":"2017-03-25T08:36:11.032Z","updated":"2017-03-26T13:43:12.842Z","comments":true,"path":"2017/03/25/制作倒计时/","link":"","permalink":"https://izdo.github.io/2017/03/25/制作倒计时/","excerpt":"","text":"如何做一个简单的倒计时1. 创建新工程CountTime2. 布局文件activity_main.xml:123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"com.counttime.MainActivity\"&gt; &lt;EditText android:id=\"@+id/inputtime\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:ems=\"10\"/&gt; &lt;Button android:id=\"@+id/gettime\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"获取倒计时时间\"/&gt; &lt;TextView android:id=\"@+id/time\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; &lt;Button android:id=\"@+id/starttime\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"开始计时\"/&gt; &lt;Button android:id=\"@+id/stoptime\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"停止计时\"/&gt;&lt;/LinearLayout&gt; inputtime用于输入倒计时时间gettime用于显示inputtime输入的时间time用于显示倒计时时间starttime、stoptime分别用于开始和停止倒计时 效果图: 3. MainActivity逻辑:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.counttime;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import java.util.Timer;import java.util.TimerTask;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private EditText inputet; private Button getTime, startTime, stopTime; private TextView time; private int i = 0; private Timer timer = null; private TimerTask task = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //调用初始化控件方法 initView(); &#125; // 初始化控件 private void initView() &#123; inputet = (EditText) findViewById(R.id.inputtime); getTime = (Button) findViewById(R.id.gettime); startTime = (Button) findViewById(R.id.starttime); stopTime = (Button) findViewById(R.id.stoptime); time = (TextView) findViewById(R.id.time); getTime.setOnClickListener(this); startTime.setOnClickListener(this); stopTime.setOnClickListener(this); &#125; // 设置点击事件 @Override public void onClick(View view) &#123; switch (view.getId()) &#123; // 点击gettime按钮获取inputet上的时间值 case R.id.gettime: time.setText(inputet.getText().toString()); i = Integer.parseInt(inputet.getText().toString()); break; case R.id.starttime: startTime(); break; case R.id.stoptime: stopTime(); break; default: break; &#125; &#125; // 使用Handler实现对主线程的更新UI操作 private Handler mHandler = new Handler() &#123; // 调用handleMessage处理消息 public void handleMessage(Message msg) &#123; time.setText(msg.arg1 + \"\"); startTime(); &#125; &#125;; public void startTime() &#123; // 创建计时器和计时任务 timer = new Timer(); task = new TimerTask() &#123; @Override public void run() &#123; i--; Message message = mHandler.obtainMessage(); message.arg1 = i; mHandler.sendMessage(message); &#125; &#125;; timer.schedule(task, 1000); &#125; public void stopTime() &#123; // 取消计时器 timer.cancel(); &#125;&#125; 由于主线程不允许子线程更新UI，因此这里需要用到Handler实现子线程更新UI的操作。 首先创建一个Handler并调用handleMessage方法处理sendMessage传递过来的消息，需要注意的是，TextView的setText方法只能传入String类型的参数，因此不能单单传入msg.arg1，一种简单的处理方式就是在后面加上“”将其转换成字符串:time.setText(msg.arg1 + “”);。 Timer和TimerTask一般是配合使用的(由TimerTask实现任务内容，然后将任务放入计时器Timer),在TimerTask的run()方法里创建一个Message用于向Handler发送消息，这里传入的是i(此前已经将inputet中的数字赋给i)，并调用sendMessage方法将Message发送给Handler，最后调用schedule()方法将TimerTask放入计时器。 timer.schedule(task, 1);第一个参数表示要放入的TimerTask任务，第二个参数是一个毫秒值，表示多少时间之后启动任务，这里放入1000毫秒(1秒)。 最后调用cancel()方法取消任务。 ps:在startTime()中调用sendMessage()方法向Handler发送消息，而在Handler的handleMessage中又调用startTime()方法，这样就形成了sendMessage()-&gt;handleMessage()-&gt;sendMessage()-&gt;handleMessage()-&gt;…的循环。 4. 部署到Genymotion观看效果: 5. 改进 这里存在这一个问题就是计时器读数到0后会变成负数，所以下面需要修改一些代码使计时器归0后停止计时。1234567891011public void startTime() &#123; ... @Override public void run() &#123; i--; if(i&lt;0)&#123; stopTime(); return; &#125; ... &#125; 这里在startTime()方法中的run()方法中加入一个if判断，当i小于0的时候就调用stopTime()方法并且return。(这里判断条件是小于0而不是等于0是逻辑顺序的问题) 为了更好地看到”刹车”效果，将任务间隔设置为1毫秒。 1timer.schedule(task, 1); 效果如下: 对于目前的程序，由于从inputet获取的值为int类型，但当我们输入小数或者字符和其他符号时，程序会崩溃，这里可以使用正则表达式限制输入。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"}]}]}