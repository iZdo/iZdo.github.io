{"meta":{"title":"iZdo's Blog","subtitle":"bonbolu","description":null,"author":"iZdo","url":"https://izdo.github.io"},"pages":[{"title":"categories","date":"2017-03-23T14:14:27.000Z","updated":"2017-03-23T14:14:51.148Z","comments":true,"path":"categories/index.html","permalink":"https://izdo.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-03-23T05:20:30.000Z","updated":"2017-03-23T05:21:03.041Z","comments":false,"path":"tags/index.html","permalink":"https://izdo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"如何做一个简单的通讯录","slug":"制作通讯录","date":"2017-03-26T14:05:59.634Z","updated":"2017-03-28T03:22:55.202Z","comments":true,"path":"2017/03/26/制作通讯录/","link":"","permalink":"https://izdo.github.io/2017/03/26/制作通讯录/","excerpt":"","text":"如何做一个简单的通讯录获取手机通讯录信息1. 创建新工程GetMyPhoneContacts2. 为了模拟通讯录的效果，现在genymotion模拟器中添加几个联系人 效果图: 3. 创建Java类 GetNumber12345678910111213141516171819202122232425262728293031package com.getmyphonecontacts;import android.content.Context;import android.database.Cursor;import android.provider.ContactsContract.CommonDataKinds.Phone;import android.util.Log;/** * Created by iZdo on 2017/3/26. */public class GetNumber &#123; public static String getNumber(Context context) &#123; // 查询系统通讯录 Cursor cursor = context.getContentResolver().query(Phone.CONTENT_URI, null, null, null, null); // 定义两个字符串用于获取姓名和电话号码 String phoneName; String phoneNumber; // 循环遍历 while (cursor.moveToNext()) &#123; phoneName = cursor.getString(cursor.getColumnIndex(Phone.DISPLAY_NAME)); phoneNumber = cursor.getString(cursor.getColumnIndex(Phone.NUMBER)); Log.d(\"MainActivity\", \"phoneName= \" + phoneName + \",phoneNumber= \" + phoneNumber); &#125; return null; &#125;&#125; 类中只有一个getNumber方法，这个方法用于获取手机通讯录的联系人 这个方法需要一个上下文Context对象作为参数，首先调用上下文的getContentResolver()方法获取一个内容解析者ContentResolver对象并且调用其query()方法查询系统联系人 query()方法第一个参数为一个Uri，这里传入Phone.CONTENT_URI即可，后面的四个参数为查询条件，目前我们不需要筛选联系人，因此全部传入null即可。 query()返回的是一个游标Cursor，用while循环不断遍历Cursor，从Cursor中取出联系人的姓名和号码。 1234567891011121314package com.getmyphonecontacts;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); GetNumber.getNumber(this); &#125;&#125; 在MAinActivity中调用GetNumber的getNumber()方法。 打印日志如下: D/MainActivity: phoneName= zhangsan,phoneNumber= 110 D/MainActivity: phoneName= lisi,phoneNumber= 119 D/MainActivity: phoneName= lin,phoneNumber= 666 可以看到，打印的结果和通讯录中的联系人吻合。 封装数据 现在要做的是将得到的数据封装起来新建Java类ContactInfo 1234567891011121314151617181920212223242526272829303132333435package com.getmyphonecontacts;/** * Created by iZdo on 2017/3/27. */public class ContactInfo &#123; private String name; private String number; // 构造器 public ContactInfo(String name, String number) &#123; this.name = name; this.number = number; &#125; // 对应的getter、setter方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getNumber() &#123; return number; &#125; public void setNumber(String number) &#123; this.number = number; &#125;&#125; 简单的JavaBean类，不多做解释 ps:number使用String类型而不适用int类型是因为号码会有地区之分，所以会出现”+86”的情况，所以不能只用int类型来存储。 修改GetNumber中的代码:12345678910111213141516171819public class GetNumber &#123; public static List&lt;ContactInfo&gt; contactInfoList = new ArrayList&lt;ContactInfo&gt;(); public static String getNumber(Context context) &#123; ... // 循环遍历 while (cursor.moveToNext()) &#123; phoneName = cursor.getString(cursor.getColumnIndex(Phone.DISPLAY_NAME)); phoneNumber = cursor.getString(cursor.getColumnIndex(Phone.NUMBER)); ContactInfo contactInfo = new ContactInfo(phoneName, phoneNumber); contactInfoList.add(contactInfo); Log.d(\"MainActivity\", \"phoneName= \" + phoneName + \",phoneNumber= \" + phoneNumber); &#125; return null; &#125;&#125; GetNumber中新创建了一个数据类型为ContactInfo的List集合，在getNumber()方法的while循环中，每一次循环都将新创建一个ContactInfo对象，并将获取的联系人姓名和号码存入ContactInfo对象中，再将其加入到List集合里，这样就将所有的联系人都存入到了List集合，实现了数据的封装。 ps:显示中的通讯录实际上不止姓名和号码两项，还有地址，电子邮箱等信息，这里为了方便救只使用姓名和号码这两项。 UI适配修改activity_main.xml文件123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.getmyphonecontacts.MainActivity\"&gt; &lt;ListView android:id=\"@+id/lv\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt;&lt;/RelativeLayout&gt; 这里使用ListView用于联系人数据的显示。 自定义适配器新建MyAdapter继承自BaseAdapter1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.getmyphonecontacts;import android.content.Context;import android.view.View;import android.view.ViewGroup;import android.widget.BaseAdapter;import java.util.List;/** * Created by iZdo on 2017/3/27. */public class MyAdapter extends BaseAdapter &#123; private List&lt;ContactInfo&gt; mContactInfoList; private Context mContext; public MyAdapter(List&lt;ContactInfo&gt; contactInfoList, Context context) &#123; mContactInfoList = contactInfoList; mContext = context; &#125; @Override public int getCount() &#123; return mContactInfoList.size(); &#125; @Override public Object getItem(int i) &#123; return mContactInfoList.get(i); &#125; @Override public long getItemId(int i) &#123; return i; &#125; @Override public View getView(int i, View view, ViewGroup viewGroup) &#123; return null; &#125;&#125; 此处需要创建一个数据类型为ContactInfo的List集合和一个上下文对象COntext。 再创建一个构造器，其参数为一个List集合和一个上下文对象。 继承BaseAdapter需要重写四个方法:getCount()、getItem()、getItemId()、getView(): public int getCount():用于得到Item的总数，这里返回我们创建的List集合的长度即可。 public Object getItem(int i):用于根据i得到某个Item的对象，这里需要返回List集合对应位置i的对象。 public long getItemId(int i):用于根据i得到某个Item的id，由于位置i代表的就是其相应Item的id，这里返回i即可。 public View getView(int i, View view, ViewGroup viewGroup):用于得到相应的i对应的Item视图，i当前的位置以及converView复用的View对象，在写这个方法之前，我们需要再新建一个Item布局来展示具体数据。 新建布局文件contact.xml1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\"&gt; &lt;RelativeLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt; &lt;ImageView android:id=\"@+id/iv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@mipmap/ic_launcher\"/&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_alignBottom=\"@id/iv\" android:layout_alignTop=\"@id/iv\" android:layout_toRightOf=\"@id/iv\" android:gravity=\"center_vertical\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"111\" android:textSize=\"15sp\"/&gt; &lt;TextView android:id=\"@+id/number\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"222\" android:textSize=\"10sp\"/&gt; &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt;&lt;/LinearLayout&gt; 效果图如下: 简单的布局，左边是一个ImageView，右边是两个TextView，具体实现如代码所示，此处不再阐述。 修改MyAdapter的代码将getView()方法的内容补充完整12345678910@Overridepublic View getView(int i, View view, ViewGroup viewGroup) &#123; LayoutInflater inflater = LayoutInflater.from(mContext); LinearLayout layout = (LinearLayout) inflater.inflate(R.layout.contact, null); TextView nametv = (TextView) layout.findViewById(R.id.name); TextView numbertv = (TextView) layout.findViewById(R.id.number); nametv.setText(mContactInfoList.get(i).getName()); numbertv.setText(mContactInfoList.get(i).getNumber()); return layout;&#125; 首先创建一个打气筒将刚才创建的Item布局文件转化为一个View，然后初始化两个TextView控件并为其填充相应位置的联系人信息，最后将layout返回。 ps:LayoutInflater.from()方法需要传入一个上下文对象Context，这里就需要用到此前创建的成员变量mContext，而mContext是通过构造器得到的，因此在构造器里设置Context为参数的好处就是当某个活动创建我们自定义的适配器MyAdapter的时候就会同时将其上下文传入，使得活动与适配器联系了起来。 修改MainActivity中的代码123456789101112131415161718192021package com.getmyphonecontacts;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.ListView;public class MainActivity extends AppCompatActivity &#123; private ListView lv; private MyAdapter mAdapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); GetNumber.getNumber(this); lv = (ListView) findViewById(R.id.lv); mAdapter = new MyAdapter(GetNumber.contactInfoList, this); lv.setAdapter(mAdapter); &#125;&#125; 创建一个ListView 创建一个MyAdapter适配器 这里没什么好说的，需要注意的一点是MyAdapter的两个参数分别传入GetNumber中的List集合(静态成员变量，可通过类名直接调用)和this即可。 部署到Genymotion模拟器上观看效果效果如下: 可以看到，联系人的信息都显示在了每一行Item上了。 ps:ImageView上的图片事先并无准备，所以就用了系统自带的ic_launcher图片。 复用历史缓存对象进行优化 ListView其实是一个比较难用的控件，因为它有很多细节可以优化，运行效率就是其中很重要的一点，我们上面写的ListView运行效率是很低的，因为在getView()方法中，每次都将布局重新加载了一遍，当ListView快速滚动的时候，会明显出现卡顿的现象(由于我们的数据量比较少，无法体现出卡顿效果，当数据量比较大的时候能够明显看出)，这时候我们就需要优化ListView的，我们可以发现getView()方法里还有一个view(原先是convertView)是我们没用到的，这是一个缓存对象，就是用于优化ListView的。 ### 修改MyAdapter中的代码:12345678910111213141516171819202122232425262728293031323334public class MyAdapter extends BaseAdapter &#123; ... @Override public View getView(int i, View view, ViewGroup viewGroup) &#123; // LayoutInflater inflater = LayoutInflater.from(mContext); // LinearLayout layout = (LinearLayout) inflater.inflate(R.layout.contact, null); // TextView nametv = (TextView) layout.findViewById(R.id.name); // TextView numbertv = (TextView) layout.findViewById(R.id.number); // nametv.setText(mContactInfoList.get(i).getName()); // numbertv.setText(mContactInfoList.get(i).getNumber()); ViewHolder holder; if (view == null) &#123; view = LayoutInflater.from(mContext).inflate(R.layout.contact, null); holder = new ViewHolder(); holder.nametv = (TextView) view.findViewById(R.id.name); holder.numbertv = (TextView) view.findViewById(R.id.number); holder.nametv.setText(mContactInfoList.get(i).getName()); holder.numbertv.setText(mContactInfoList.get(i).getNumber()); view.setTag(holder); &#125; else &#123; holder = (ViewHolder) view.getTag(); holder.nametv.setText(mContactInfoList.get(i).getName()); holder.numbertv.setText(mContactInfoList.get(i).getNumber()); &#125; return view; &#125; private static class ViewHolder &#123; TextView nametv; TextView numbertv; &#125;&#125; 首先创建了一个内部类ViewHolder，用于对控件的实例进行缓存。 在getView方法中，创建了一个ViewHolder对象，当缓存view为空时，就将联系人的信息封装在ViewHolder里，然后调用setTag()方法将ViewHolder储存在view中，而当缓存不为空时，就调用getTag()方法取出ViewHolder，这样就实现了缓存的复用。 继续改进 通过复用缓存对象我们对ListView进行了优化，而通过观察getView()方法，我们发现不管缓存view为空时，新建ViewHolder去缓存实例还是缓存view不为空时，取出缓存，我们都需要用这个ViewHolder对TextView进行设置文本内容，所以我们又可以进一步优化代码: 123456789101112131415161718192021222324252627public class MyAdapter extends BaseAdapter &#123; ... @Override public View getView(int i, View view, ViewGroup viewGroup) &#123; ... ViewHolder holder; if (view == null) &#123; view = LayoutInflater.from(mContext).inflate(R.layout.contact, null); holder = new ViewHolder(); holder.nametv = (TextView) view.findViewById(R.id.name); holder.numbertv = (TextView) view.findViewById(R.id.number); view.setTag(holder); &#125; else holder = (ViewHolder) view.getTag(); holder.nametv.setText(mContactInfoList.get(i).getName()); holder.numbertv.setText(mContactInfoList.get(i).getNumber()); return view; &#125; ... &#125; 这里我们将holder.nametv.setText(mContactInfoList.get(i).getName())和 holder.numbertv.setText(mContactInfoList.get(i).getNumber())放到判断语句外边，减少了代码的重复(其实就是之前忘了放)。 这样就完成了从手机系统通讯录中取出数据放到我们自己的通讯录上的效果。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"}]},{"title":"如何做一个简单的倒计时","slug":"制作倒计时","date":"2017-03-25T08:36:11.032Z","updated":"2017-03-26T13:43:12.842Z","comments":true,"path":"2017/03/25/制作倒计时/","link":"","permalink":"https://izdo.github.io/2017/03/25/制作倒计时/","excerpt":"","text":"如何做一个简单的倒计时1. 创建新工程CountTime2. 布局文件activity_main.xml:123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"com.counttime.MainActivity\"&gt; &lt;EditText android:id=\"@+id/inputtime\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:ems=\"10\"/&gt; &lt;Button android:id=\"@+id/gettime\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"获取倒计时时间\"/&gt; &lt;TextView android:id=\"@+id/time\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; &lt;Button android:id=\"@+id/starttime\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"开始计时\"/&gt; &lt;Button android:id=\"@+id/stoptime\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"停止计时\"/&gt;&lt;/LinearLayout&gt; inputtime用于输入倒计时时间gettime用于显示inputtime输入的时间time用于显示倒计时时间starttime、stoptime分别用于开始和停止倒计时 效果图: 3. MainActivity逻辑:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.counttime;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import java.util.Timer;import java.util.TimerTask;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private EditText inputet; private Button getTime, startTime, stopTime; private TextView time; private int i = 0; private Timer timer = null; private TimerTask task = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //调用初始化控件方法 initView(); &#125; // 初始化控件 private void initView() &#123; inputet = (EditText) findViewById(R.id.inputtime); getTime = (Button) findViewById(R.id.gettime); startTime = (Button) findViewById(R.id.starttime); stopTime = (Button) findViewById(R.id.stoptime); time = (TextView) findViewById(R.id.time); getTime.setOnClickListener(this); startTime.setOnClickListener(this); stopTime.setOnClickListener(this); &#125; // 设置点击事件 @Override public void onClick(View view) &#123; switch (view.getId()) &#123; // 点击gettime按钮获取inputet上的时间值 case R.id.gettime: time.setText(inputet.getText().toString()); i = Integer.parseInt(inputet.getText().toString()); break; case R.id.starttime: startTime(); break; case R.id.stoptime: stopTime(); break; default: break; &#125; &#125; // 使用Handler实现对主线程的更新UI操作 private Handler mHandler = new Handler() &#123; // 调用handleMessage处理消息 public void handleMessage(Message msg) &#123; time.setText(msg.arg1 + \"\"); startTime(); &#125; &#125;; public void startTime() &#123; // 创建计时器和计时任务 timer = new Timer(); task = new TimerTask() &#123; @Override public void run() &#123; i--; Message message = mHandler.obtainMessage(); message.arg1 = i; mHandler.sendMessage(message); &#125; &#125;; timer.schedule(task, 1000); &#125; public void stopTime() &#123; // 取消计时器 timer.cancel(); &#125;&#125; 由于主线程不允许子线程更新UI，因此这里需要用到Handler实现子线程更新UI的操作。 首先创建一个Handler并调用handleMessage方法处理sendMessage传递过来的消息，需要注意的是，TextView的setText方法只能传入String类型的参数，因此不能单单传入msg.arg1，一种简单的处理方式就是在后面加上“”将其转换成字符串:time.setText(msg.arg1 + “”);。 Timer和TimerTask一般是配合使用的(由TimerTask实现任务内容，然后将任务放入计时器Timer),在TimerTask的run()方法里创建一个Message用于向Handler发送消息，这里传入的是i(此前已经将inputet中的数字赋给i)，并调用sendMessage方法将Message发送给Handler，最后调用schedule()方法将TimerTask放入计时器。 timer.schedule(task, 1);第一个参数表示要放入的TimerTask任务，第二个参数是一个毫秒值，表示多少时间之后启动任务，这里放入1000毫秒(1秒)。 最后调用cancel()方法取消任务。 ps:在startTime()中调用sendMessage()方法向Handler发送消息，而在Handler的handleMessage中又调用startTime()方法，这样就形成了sendMessage()-&gt;handleMessage()-&gt;sendMessage()-&gt;handleMessage()-&gt;…的循环。 4. 部署到Genymotion观看效果: 5. 改进 这里存在这一个问题就是计时器读数到0后会变成负数，所以下面需要修改一些代码使计时器归0后停止计时。1234567891011public void startTime() &#123; ... @Override public void run() &#123; i--; if(i&lt;0)&#123; stopTime(); return; &#125; ... &#125; 这里在startTime()方法中的run()方法中加入一个if判断，当i小于0的时候就调用stopTime()方法并且return。(这里判断条件是小于0而不是等于0是逻辑顺序的问题) 为了更好地看到”刹车”效果，将任务间隔设置为1毫秒。 1timer.schedule(task, 1); 效果如下: 对于目前的程序，由于从inputet获取的值为int类型，但当我们输入小数或者字符和其他符号时，程序会崩溃，这里可以使用正则表达式限制输入。","categories":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://izdo.github.io/tags/Android/"}]}]}